<HTML XPOS=20% YPOS=BOTTOM WIDTH=80% HEIGHT=100%>
<HEAD>
<!-- extra bytes: 03 00 14 14 00 08 00 11 50 00 64 00 --><TITLE>The PARSE instruction</TITLE>
</HEAD>
<BODY>
<H1>The PARSE instruction</H1><!-- entering slot 251 --><A AUTO VIEWPORT DEPENDENT GROUP=4100 HREF="107_L4_Menu.html">[Autolink] Menu</A><P><!-- extra bytes: 4C 06 04 10 04 00 -->
<P>

<P>
This section contains a more detailed description of the PARSE</A> instruction.

<P>
<!--0xfb-->---------- * ----------
<BR>

<P>
<B>General</B>
<P>
The format of the PARSE</A> instruction is  <B> PARSE {UPPER|LOWER|CASELESS}
<B><I>source</B></I> {<B><I>template</B></I>}
<BR>

<P>
where<!-- lm: 0x2 1 -->
<UL>
<P>
<B>UPPER</B><!-- lm: 0x11 4 -->
<UL> Translate the source to uppercase before
parsing. This parameter is optional .<!-- lm: 0x2 1 -->
</UL><B> LOWER</B><!-- lm: 0x11 4 -->
<UL> Translate
the source to lowercase before parsing. This parameter is optional (Object
REXX only!).<!-- lm: 0x2 1 -->
</UL><B> CASELESS</B><!-- lm: 0x11 4 -->
<UL> Parse
the source ignoring the case (e.g. A-Z is equal to a-z). This parameter
is optional (Object REXX only!). <!-- lm: 0x2 1 -->
</UL><B><B><I> source
</B></I><!-- lm: 0x11 4 -->
<UL>The source to parse (see below)<!-- lm: 0x2 1 -->
</UL><B><B><I> template
</B></I><!-- lm: 0x11 4 -->
<UL>This parameter specifies how to parse the
source (see below). This parameter is optional.<!-- lm: 0x2 1 -->
</UL>
<P>
<!--0xfb--><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI>
<P>
<B><I>source</B></I> may be one of the following:<!-- lm: 0x2 1 -->
<P>
<B>ARG</B><!-- lm: 0x11 4 -->
<UL> Use the arguments for the program or
procedure as source<!-- lm: 0x2 1 -->
</UL><B> LINEIN</B><!-- lm: 0x11 4 -->
<UL> Use
the next input line from the keyboard as source.<B> PARSE LINEIN</B> is
a short form of<B> PARSE VALUE LINEIN() WITH</B><!-- lm: 0x2 1 -->
</UL><B> PULL
</B><!-- lm: 0x11 4 -->
<UL>Use the next line from the default REXX queue
or the next line from the keyboard if the queue is empty as source<!-- lm: 0x2 1 -->
</UL><B> SOURCE
</B><!-- lm: 0x11 4 -->
<UL>Use the program's source information as source
(see <A HREF="255_L3_PARSESOURCE.html">PARSE SOURCE</A>)<!-- lm: 0x2 1 -->
</UL><B> VALUE
<B><I>expression</B></I><B> WITH</B><!-- lm: 0x11 4 -->
<UL> Use the result
of the expression<B><I> expression</B></I> as source.<B><I> expression</B></I> may
be any legal REXX expression.<!-- lm: 0x2 1 -->
</UL><B> VAR<B><I> name
</B></I><!-- lm: 0x11 4 -->
<UL>Use the contents of the variable<B><I> name
</B></I>as source<!-- lm: 0x2 1 -->
</UL><B> VERSION</B><!-- lm: 0x11 4 -->
<UL> Use
the REXX interpreter version information as source (see <A HREF="256_L3_PARSEVERSION.html">PARSE
VERSION</A>)<!-- lm: 0x2 1 -->
</UL>
<P>
<!--0xfb--><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI>
<P>
<B><I>template</B></I> can be any combination of the following patterns:
<!-- lm: 0x2 1 -->
<P>
<B>variable name</B><!-- lm: 0x11 4 -->
<UL> a variable to be assigned a
value<!-- lm: 0x2 1 -->
</UL><B> literal string</B><!-- lm: 0x11 4 -->
<UL> a
literal string used as string pattern to split the source<!-- lm: 0x2 1 -->
</UL><B> (variable
name)</B><!-- lm: 0x11 4 -->
<UL> a literal string saved in a variable used
as a string pattern to split the source<!-- lm: 0x2 1 -->
</UL><B> .</B> (a
single period)<!-- lm: 0x11 4 -->
<UL> a placeholder for unused parts of
the source. You must use at least one space to separate periods from other
patterns.<!-- lm: 0x2 1 -->
</UL><B> #</B> (# is an integer value, e.g.
<B>4</B> )<!-- lm: 0x11 4 -->
<UL> an absolute character position within
the source<!-- lm: 0x2 1 -->
</UL><B> =#</B> (# is an integer value, e.g.
<B>=4</B> )<!-- lm: 0x11 4 -->
<UL> an absolute character position within
the source<!-- lm: 0x2 1 -->
</UL><B> +#</B> (# is an integer value, e.g.
<B>+4</B> )<!-- lm: 0x11 4 -->
<UL> a relative character position within
the source (move right)<!-- lm: 0x2 1 -->
</UL><B> -#</B> (# is an integer
value, e.g.<B> -4</B> )<!-- lm: 0x11 4 -->
<UL> a relative character position
within the source (move left)<!-- lm: 0x2 1 -->
</UL><B> =(variable name)
</B><!-- lm: 0x11 4 -->
<UL>a variable containing an absolute character
position within the source<!-- lm: 0x2 1 -->
</UL><B> +(variable name)</B><!-- lm: 0x11 4 -->
<UL> a
variable containing a relative character position within the source (move
right)<!-- lm: 0x2 1 -->
</UL><B> -(variable name)</B><!-- lm: 0x11 4 -->
<UL> a
variable containing a relative character position within the source (move
left)<!-- lm: 0x2 1 -->
</UL>
<P>
<!--0xfb--><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI><LI>
<P>
<B>General notes</B>
<P>
Templates are processed from left to right. The PARSE</A> instruction does
not change the source string (i.e., if you don't force it to do this; see
below).
<P>
<!--0xfb-->---------- * ----------
<BR>

<P>
<B>Hints for selecting the proper template</B>
<P>
Use only variables if you want to split the string into words.
<BR>
Example:
<PRE> 
/* parse into words                                                   */

  testString = "This    is       a       Test "

  parse var TestString var1 var2 var3 var4

        /* result:                                                    */
        /* -&gt; var1 = "This", var2 = "is", var3 = "a" and              */
        /*    var4 = "       Test "                                   */

</PRE>

<P>
In this example PARSE</A> splits the source string into words (separated
with one or more blanks) and copies these words into the variables used
in the template. The blanks between the words are not saved in a variable
-- with one exception:<B> The blanks around the word(s) for the last variable
are saved in the last variable</B>. To avoid this, you may add a period
at the end of the template.
<BR>
Example:
<PRE> 
  /* parse into words                                                 */
  /* use a period at the end of the template to suppress the spaces   */
  /* surrounding the string in the last variable                      */

  testString = "This    is       a       Test "

  parse var TestString var1 var2 var3 var4 <B>.</B>

        /* result:                                                    */
        /* -&gt; var1 = "This", var2 = "is", var3 = "a" and              */
        /*    var4 = "Test"                                           */
</PRE>

<P>

<BR>
 Note that if there's only one variable in the template, that variable is
also the last variable!
<P>
Further note that PARSE</A> only uses spaces as the word delimiter. If,
for example, the source string uses tabulators ("09"x) to separate the words,
you can either use parsing with string patterns (see below) or you can use
the function translate</A> before parsing the string.
<BR>
Example:
<PRE> 
  /* translate tabulator to spaces and parse into words               */

  testString = "This    is" || "09"x || "another    Test"

                    /* translate tabulators to spaces                 */
  TestString = translate( testString, " ", "09"x )
  parse var TestString var1 var2 var3 var4 <B>.</B>

        /* result:                                                    */
        /* -&gt; var1 = "This", var2 = "is", var3 = "another" and        */
        /*    var4 = "Test"                                           */
</PRE>

<P>
<!--0xfb-->----- * -----
<BR>

<P>
Use<B> string patterns</B> if you want to split the string after one or
more special substrings.
<BR>
Example:
<PRE> 
/* parse with string patterns                                         */

  testString = "datafields=data1//data2//data3"

  parse var testString keyName "=" value1 "//" value2 "//" value3

        /* result:                                                    */
        /* -&gt; keyName = "datafields", value1 = "data1",               */
        /*    value2 = "data2" and value3 = "data3"                   */
</PRE>

<P>
In this example PARSE</A> splits the string into substrings before and
after the string patterns. The string patterns are not saved in a variable.

<P>
<!--0xfb-->----- * -----
<BR>

<P>
Use<B> positional parsing</B> if the source is built out of fields with
fixed length.
<BR>
Example:
<PRE> 
/* absolute positional parsing                                        */

/*              0        1         2         3         4         5    */
/*    position: <!-- entering slot 252 -->12345678901234567890123456789012345678901234567890123 */
  testString = "Doe       John M.   03/03/65  New York            USA";

  parse var testString name1 11 name2 21 birthday 31 town 51 country

        /* result:                                                    */
        /*                0        1         2         3              */
        /*                123456789012345678901234567890              */
        /* -&gt; name1    = "Doe       "                                 */
        /*    name2    = "John M.   "                                 */
        /*    birthday = "03/03/65  "                                 */
        /*    town     = "New York            "                       */
        /*    country  = "USA"                                        */
</PRE>

<P>
In this example PARSE</A> splits the source string at the given positions
into substrings and copies these substrings into the variables. All characters
from the source string (including the spaces) are saved in a variable.
<P>
You can also use<B> relative positional parsing</B> in this case.
<BR>
Example:
<PRE> 
/* relative positional parsing                                        */

/*              0        1         2         3         4         5    */
/*    position: 12345678901234567890123456789012345678901234567890123 */
  testString = "Doe       John M.   03/03/65  New York            USA";

  parse var testString name1 +10 name2 +10 birthday +10 town +20 country

        /* result:                                                    */
        /*                0        1         2         3              */
        /*                123456789012345678901234567890              */
        /* -&gt; name1    = "Doe       "                                 */
        /*    name2    = "John M.   "                                 */
        /*    birthday = "03/03/65  "                                 */
        /*    town     = "New York            "                       */
        /*    country  = "USA"                                        */
</PRE>

<P>
Positional patterns that specify a position beyond the end of the parse
data are considered to match the end of the data.  Positional patterns that
specify a position to the left of the beginning of the parse data are considered
to match the beginning of the parse data.
<P>
<!--0xfb-->----- * -----
<BR>

<P>
You can also mix string patterns, positional parsing and variables in one
PARSE</A> instruction.
<BR>
Example:
<PRE> 
/* mixed parsing                                                      */

/*              0        1         2         3         4         5    */
/*    position: 1234567890123456789012345678901234567890123456789012  */
  testString = "This a remark field (up to 39 chars)   44 55 //66    77";

  parse var testString 40 data1 data2 <B>.</B> "//" data3 data4 <B>.</B>

        /* result:                                                    */
        /* -&gt; data1 = "44", data2 = "55", data3 = "66" and            */
        /*    data4 = "77"                                            */
</PRE>

<P>
<!--0xfb-->----- * -----
<BR>

<P>
<B>Further considerations</B>
<P>
Use the placeholder<B> .</B> (period) to ignore parts of the source.
<BR>
Example:
<PRE> 
/* parsing into word using periods in templates                       */

  testString = "data1 garbage data2 garbage garbage data3 garbage";

  parse var testString resultStr1 <B>.</B> resultStr2 <B>.</B> <B>.</B> resultStr3 <B>.</B>

        /* result:                                                    */
        /* -&gt; resultStr1 = "data1", resultStr2 = "data2" and          */
        /*    resultStr3 = "data3"                                    */
</PRE>

<P>
Note that the placeholder is not necessary in all cases.
<BR>
Example:
<PRE> 
/* examples for using the placeholder                                 */

  testString = "data1-data2-data3"
  parse var testString . '-' resultStr '-' .
        /* -&gt; resultStr = "data2"                                     */

  /* is equal to */
  parse var testString '-' resultStr '-'
        /* -&gt; resultStr = "data2"                                     */

  parse var testString . 7 resultStr +5 .
        /* -&gt; resultStr = "data2"                                     */

  /* is equal to */
  parse var testString 7 resultStr +5
        /* -&gt; resultStr = "data2"                                     */

</PRE>

<P>
<!--0xfb-->----- * -----
<BR>

<P>
<B>All</B> variables in a template receive new values. If there are no more
words for one or more variables in the source, the remaining variables receive
an empty string.
<BR>
Example:
<PRE> 
/* further parsing example                                            */

  parse value "word1 word2" WITH resultStr1 resultStr2 resultStr3

        /* result:                                                    */
        /* -&gt; resultStr1 = "word1", resultStr2 = "word2" and          */
        /*    resultStr3 = ""                                         */
</PRE>

<P>
In this example the variable<B><I> resultStr3</B></I> contains an empty
string after the PARSE</A> instruction because there are two words in the
source but the template contains three variables.
<BR>
Another example
<PRE> 
/* further parsing example                                            */

  parse value "s1 // s2 s3" WITH resStr1 "//" resStr2 "--" resStr3

        /* result:                                                    */
        /* -&gt; resStr1 = "s1 ", resStr2 = " s2 s3", resStr3 = ""       */
</PRE>

<P>
In this example the variable<B><I> resStr3</B></I> contains an empty string
after the PARSE</A> instruction because there is no match for the string
pattern "--" in the source string.
<P>
<!--0xfb-->----- * -----
<BR>

<P>
If there are more words in the source than variables in the template, the
last variable receives all words remaining in the source.
<BR>
Example:
<PRE> 
/* further parsing example                                            */

  parse value "word1 word2 word3" WITH resultStr1 resultStr2

        /* result:                                                    */
        /* -&gt; resultStr1 = "word1", resultStr2 = "word2 word3"        */
</PRE>

<P>
In this example the variable<B><I> resultStr2</B></I> contains "word2 word3"
because there are three words in the source but only two variables in the
template.
<P>
<!--0xfb-->----- * -----
<BR>

<P>
An empty string (e.g.<B> ""</B>) in the template is never found. It always
matches the end of the string (see <A HREF="262_L4_Getthefirstandthelas.html">Get
the first and the last char of a string</A> for an example).
<BR>
Example:
<PRE> 
/* parse a string from the end                                        */

  testString = "anything not needed      44 55 66 77"

  parse var testString "" -2 var1 +2 -5 var2 +2 -5 var3 +2 -5 var4 +2

        /* result:                                                    */
        /* -&gt; var1 = "77", var2 = "66", var3 = "55" and var4 = "44"   */
</PRE>

<P>
<!--0xfb-->----- * -----
<BR>

<P>
In PARSE VAR</A> instructions you can use the source in the template. You
can use this method to process a variable word by word.
<BR>
Example:
<PRE> 
/* process a string word by word                                      */

  testString = "Otto Karl Heinrich Klaus Peter"

  do until testString = ""

                    /* copy the 1. word of testString into curName    */
                    /* remove it from testString                      */
    parse var testString curName testString

    say "Current word is " || curName
    say "Remaining words in testString are " || testString
  end /* do until testString = "" */
</PRE>

<P>
<!--0xfb-->----- * -----
<BR>

<P>
You can set a variable in a template and use it in the remaining template.

<BR>
Example:
<PRE> 
/* further parsing example                                            */

  testString = "*data1*data2*data3*"

  parse var TestString sep 2 resStr1 (sep) resStr2 (sep) resStr3 (sep)
        /*             \ /             |             |             |  */
        /*              |              \-------------+-------------/  */
        /*             set the            use the variable "sep"      */
        /*             variable "sep"                                 */
        /*                                                            */
        /* result:                                                    */
        /* -&gt; resStr1 = "data1", resStr2 = "data2", resStr3 = "data3" */
        /*    sep = "*"                                               */
</PRE>

<P>
<!--0xfb-->----- * -----
<BR>

<P>
Only PARSE ARG</A> can have more than one source string (separate the source
strings with commas).
<BR>
Example:
<PRE> 
/* further parsing example                                            */

  call TestFunc "data11,data12" , "data21data22"

RETURN

TestFunc:
    /* Note the <!-- entering slot 253 -->difference meaning of the commas in the template!     */

  parse arg arg1_part1 ',' arg1_part2 , arg2_part1 7 arg2_part2

        /* result:                                                    */
        /* -&gt; arg1_part1 = "data11", arg1_part2 = "data12"            */
        /*    arg2_part1 = "data21", arg2_part2 = "data22"            */
RETURN
</PRE>

<P>
Note that a REXX program called from the command line always retrieves only
<B>one</B> parameter (see also <A HREF="175_L3_ParametersforaREXXpr.html">Parameters
for a REXX program</A>).
<P>
<!--0xfb-->----- * -----
<BR>

<P>
Using positional parsing you can parse the source string with different
templates in one PARSE</A> instruction.
<BR>
Example:
<PRE> 
/* sample for parsing a string with different templates in one PARSE  */
/* instruction                                                        */

  testString = "a--b c++d r//g"

  parse value testString with   word1 word2 word3 ,
                          1 part1 "--" part2 "++" part3 "//" part4 ,
                          1 char1 2 4 char2 5 9 char3 10 char4 11 14 char5

        /* result:                                                    */
        /* -&gt; word1 = "a--b", word2 = "c++d", word3 = "r//g"          */
        /*    part1 = "a", part2 = "b c", part3 = "d r"               */
        /*    char1 = "a", char2 = "b", char3 = "d", char4 = "r",     */
        /*    char5 = "g"                                             */
</PRE>

<P>
<!--0xfb-->---------- * ----------
<BR>

<P>
See the <A HREF="254_L3_PARSEinstructionexam.html">next chapter</A> for
some further examples. 

<P><HR>

<A HREF="252_L3_Queuesversusfiles.html">[Back: Queues versus files]</A> <BR>
<A HREF="254_L3_PARSEinstructionexam.html">[Next: PARSE instruction examples]</A> 
</BODY>
</HTML>
