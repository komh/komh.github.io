<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>VioGlobalReg</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>VioGlobalReg</H1><!-- entering slot 716 -->Bindings:  <A HREF="711_L2H_VioGlobalReg.html">C</A>,
<A HREF="755_L2H_VioGlobalReg.html">MASM</A>
<BR>

<P>
VioGlobalReg allows a subsystem to receive notification at the completion
of VIO calls issued by all applications running in full-screen sessions.
<!-- lm: 0x2 1 -->
<UL>
<P>
VioGlobalReg<!-- lm: 0x2 17 -->
<UL> (ModuleName, EntryPoint, FunctionMask1,
FunctionMask2, 0)<!-- lm: 0x2 1 -->
</UL><!-- lm: 0x2 1 -->
<P>
<B>ModuleName</B> (PSZ) - input<!-- lm: 0x11 4 -->
<UL> Address of the ASCIIZ
string containing the 1-8 character file name of the subsystem.  The maximum
length of the ASCIIZ string is 9 bytes including the terminating byte of
zero.  The module must be a dynamic link library but the name supplied must
not include the .DLL extension.<!-- lm: 0x2 1 -->
</UL><B> EntryPoint</B> (PSZ)
- input<!-- lm: 0x11 4 -->
<UL> Address of the ASCIIZ name string containing
the dynamic link entry point name of the routine in the subsystem to receive
control when any of the registered functions is called.  The maximum length
of the ASCIIZ string is 33 bytes including the terminating byte of zero.
<!-- lm: 0x2 1 -->
</UL><B>FunctionMask1</B> (ULONG) - input<!-- lm: 0x11 4 -->
<UL> A
bit mask where each bit identifies a video function being registered.  The
bit definitions are shown below.  The first word pushed onto the stack contains
the high-order 16 bits of the function mask, and the second word contains
the low-order 16 bits.
<PRE>
  BIT   REGISTERED FUNCTION         BIT   REGISTERED FUNCTION
 ──────────────────────────────────────────────────────────────────
  31    VioPrtScToggle              15    VioWrtCharStr
  30    VioEndPopUp                 14    VioWrtTTY
  29    VioPopUp                    13    VioWrtNCell
  28    VioSavRedrawUndo            12    VioWrtNAttr
  27    VioSavRedrawWait            11    VioWrtNChar
  26    VioScrUnLock                10    VioReadCellStr
  25    VioScrLock                  9     VioReadCharStr
  24    VioPrtSc                    8     VioShowBuf
  23    VioGetAnsi                  7     VioSetMode
  22    VioSetAnsi                  6     VioSetCurType
  21    VioScrollRt                 5     VioSetCurPos
  20    VioScrollLf                 4     VioGetPhysBuf
  19    VioScrollDn                 3     VioGetBuf
  18    VioScrollUp                 2     VioGetMode
  17    VioWrtCellStr               1     VioGetCurType
  16    VioWrtCharStrAtt            0     VioGetCurPos
</PRE>
<!-- lm: 0x2 1 -->
</UL><B>FunctionMask2</B> (ULONG) - input<!-- lm: 0x11 4 -->
<UL> A
bit mask where each bit identifies a video function being registered.  The
bit mask has the format shown below.  The first word pushed onto the stack
contains the high order 16 bits of the function mask, and the second word
contains the low order 16 bits. Unused bits are reserved and must be set
to zero.<!-- lm: 0x2 4 -->
<P>
Bit<!-- lm: 0x2 14 -->
<UL> Registered Function<!-- lm: 0x2 4 -->
</UL> <!-- lm: 0x2 14 -->
<UL>  <!-- lm: 0x2 4 -->
</UL>31-11<!-- lm: 0x2 14 -->
<UL> Reserved, must be set to zero.<!-- lm: 0x2 4 -->
</UL>10<!-- lm: 0x2 14 -->
<UL> VioDeRegister<!-- lm: 0x2 4 -->
</UL>9<!-- lm: 0x2 14 -->
<UL> VioRegister<!-- lm: 0x2 4 -->
</UL>8<!-- lm: 0x2 14 -->
<UL> VioSetState<!-- lm: 0x2 4 -->
</UL>7<!-- lm: 0x2 14 -->
<UL> VioGetState<!-- lm: 0x2 4 -->
</UL>6<!-- lm: 0x2 14 -->
<UL> VioSetFont<!-- lm: 0x2 4 -->
</UL>5<!-- lm: 0x2 14 -->
<UL> VioGetCp<!-- lm: 0x2 4 -->
</UL>4<!-- lm: 0x2 14 -->
<UL> VioSetCp<!-- lm: 0x2 4 -->
</UL>3<!-- lm: 0x2 14 -->
<UL> VioGetConfig<!-- lm: 0x2 4 -->
</UL>2<!-- lm: 0x2 14 -->
<UL> VioGetFont<!-- lm: 0x2 4 -->
</UL>1<!-- lm: 0x2 14 -->
<UL> VioModeUndo<!-- lm: 0x2 4 -->
</UL>0<!-- lm: 0x2 14 -->
<UL> VioModeWait<!-- lm: 0x2 1 -->
</UL><B> Reserved
</B>(LONG) - input<!-- lm: 0x11 4 -->
<UL> Reserved and must be zero.<!-- lm: 0x2 1 -->
</UL><B> rc
</B>(USHORT) - return<!-- lm: 0x11 4 -->
<UL> Return code descriptions are:
<!-- lm: 0x2 4 -->
<P>
<LI><!-- lm: 0x2 14 -->NO_ERROR<!-- lm: 0x2 4 --> 349<!-- lm: 0x2 14 -->
<UL> ERROR_VIO_INVALID_MASK
<!-- lm: 0x2 4 -->
</UL>403<!-- lm: 0x2 14 -->
<UL> ERROR_VIO_INVALID_ASCIIZ<!-- lm: 0x2 4 -->
</UL>426<!-- lm: 0x2 14 -->
<UL> ERROR_VIO_REGISTER<!-- lm: 0x2 4 -->
</UL>494<!-- lm: 0x2 14 -->
<UL> ERROR_VIO_EXTENDED_SG<!-- lm: 0x2 1 -->
</UL><B>Remarks</B>
<P>
Notification of VIO calls issued within the hard error handler and DOS (real
mode) sessions is not provided.
<P>
When control is routed to EntryPoint, the stack appears as it did after
the original VIO call except that four additional values have been<!-- entering slot 717 -->
pushed onto the stack.  The first is the index number (WORD) of the routine
called.  The second is a near pointer (WORD).  The third is the caller's
DS register (WORD).  The fourth is the return address (DWORD) to the VIO
router.
<P>
For example, if <A HREF="686_L2_VioSetCurPos.html">VioSetCurPos</A> were
a registered function, the stack would appear as if the following instruction
sequence were executed if <A HREF="686_L2_VioSetCurPos.html">VioSetCurPos
</A>were called and control routed to EntryPoint:
<PRE> ┌───────────────────────────────────────────────────────┐
 │ PUSH     WORD     Row                                 │
 │ PUSH     WORD     Column                              │
 │ PUSH     WORD     VioHandle                           │
 │ CALL     FAR      VioSetCurPos                        │
 │ PUSH     WORD     Index                               │
 │ CALL     NEAR     Entry point in Vio router           │
 │ PUSH     WORD     Caller's DS                         │
 │ CALL     FAR      Dynamic link entry point            │
 └───────────────────────────────────────────────────────┘
</PRE>

<P>
The index numbers that correspond to the registered functions are listed
below:<!-- lm: 0x2 1 -->
<P>
<LI><LI><LI>VioGetPhysBuf<!-- lm: 0x2 27 -->
<UL> 22 VioSetAnsi<!-- lm: 0x2 1 -->
</UL>1  VioGetBuf<!-- lm: 0x2 27 -->
<UL> 23 VioGetAnsi<!-- lm: 0x2 1 -->
</UL>2  VioShowBuf<!-- lm: 0x2 27 -->
<UL> 24 VioPrtSc<!-- lm: 0x2 1 -->
</UL>3  VioGetCurPos<!-- lm: 0x2 27 -->
<UL> 25 VioScrLock<!-- lm: 0x2 1 -->
</UL>4  VioGetCurType<!-- lm: 0x2 27 -->
<UL> 26 VioScrUnLock<!-- lm: 0x2 1 -->
</UL>5  VioGetMode<!-- lm: 0x2 27 -->
<UL> 27 VioSavRedrawWait<!-- lm: 0x2 1 -->
</UL>6  VioSetCurPos<!-- lm: 0x2 27 -->
<UL> 28 VioSavRedrawUndo<!-- lm: 0x2 1 -->
</UL>7  VioSetCurType<!-- lm: 0x2 27 -->
<UL> 29 VioPopUp<!-- lm: 0x2 1 -->
</UL>8  VioSetMode<!-- lm: 0x2 27 -->
<UL> 30 VioEndPopUp<!-- lm: 0x2 1 -->
</UL>9  VioReadCharStr<!-- lm: 0x2 27 -->
<UL> 31 VioPrtScToggle<!-- lm: 0x2 1 -->
</UL>10 VioReadCellStr<!-- lm: 0x2 27 -->
<UL> 32 VioModeWait<!-- lm: 0x2 1 -->
</UL>11 VioWrtNChar<!-- lm: 0x2 27 -->
<UL> 33 VioModeUndo<!-- lm: 0x2 1 -->
</UL>12 VioWrtNAttr<!-- lm: 0x2 27 -->
<UL> 34 VioGetFont<!-- lm: 0x2 1 -->
</UL>13 VioWrtNCell<!-- lm: 0x2 27 -->
<UL> 35 VioGetConfig<!-- lm: 0x2 1 -->
</UL>14 VioWrtCharStr<!-- lm: 0x2 27 -->
<UL> 36 VioSetCp<!-- lm: 0x2 1 -->
</UL>15 VioWrtCharStrAtt<!-- lm: 0x2 27 -->
<UL> 37 VioGetCp<!-- lm: 0x2 1 -->
</UL>16 VioWrtCellStr<!-- lm: 0x2 27 -->
<UL> 38 VioSetFont<!-- lm: 0x2 1 -->
</UL>17 VioWrtTTY<!-- lm: 0x2 27 -->
<UL> 39 VioGetState<!-- lm: 0x2 1 -->
</UL>18 VioScrollUp<!-- lm: 0x2 27 -->
<UL> 40 VioSetState<!-- lm: 0x2 1 -->
</UL>19 VioScrollDn<!-- lm: 0x2 27 -->
<UL> 41 VioRegister<!-- lm: 0x2 1 -->
</UL>20 VioScrollLf<!-- lm: 0x2 27 -->
<UL> 42 VioDeRegister<!-- lm: 0x2 1 -->
</UL>21 VioScrollRt<!-- lm: 0x2 27 -->
<UL>  <!-- lm: 0x2 1 -->
</UL>
<P>
On entry to the global subsystem, AX contains the return code that is returned
to the application that issued the VIO call.  The global subsystem must
return with all stack parameters and all general purpose registers, including
AX, restored to the same values as on entry.
<P>
All VIO functions within a session are serialized on a thread basis.  That
is, when a global subsystem receives control, it can safely assume that
it is not called again from the same session until the current call has
completed.  Note, however, that VIO calls across different sessions are
not serialized.
<P>
VioGlobalReg may only be issued during system initialization. After system
initialization, VioGlobalReg returns ERROR_VIO_REGISTER.  A globally registered
subsystem is active for the life of the system.
<P>
If multiple global subsystems are registered, they<!-- entering slot 718 -->
are given control in the order that they are registered.
<P>
A globally registered subsystem receives control on VIO calls issued from
all full-screen sessions except the hard error handler and DOS (real mode)
sessions.

<P><HR>

<A HREF="666_L2_VioGetState.html">[Back: VioGetState]</A> <BR>
<A HREF="668_L2_VioModeUndo.html">[Next: VioModeUndo]</A> 
</BODY>
</HTML>
