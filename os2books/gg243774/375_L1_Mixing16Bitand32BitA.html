<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Mixing 16-Bit and 32-Bit Application Modules</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Mixing 16-Bit and 32-Bit Application Modules</H1><!-- entering slot 417 -->
<P>
Under OS/2 Version 2.0, 32-bit applications may make use of existing 16-bit
application code and resources; this practice is known as <A HREF="619_L2_mixedmodelprogrammin.html"><B>mixed
model programming</B></A>. For example, a 32-bit Presentation Manager application
may access an object window procedure contained in a 16-bit DLL created
for OS/2 Version 1.3.  This capability allows 32-bit applications to make
use of existing application objects, avoiding the necessity to rewrite existing
object libraries to accommodate the 32-bit programming environment.
<P>
Applications that make use of 16-bit modules and resources must be aware
of the particular characteristics of the 16-bit environment, which affect
the way that application modules interface with one another and pass parameters
or messages.  Such characteristics include:<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Pointers in the 16-bit environment are made up of
a segment selector and an offset; this addressing scheme is therefore known
as <A HREF="720_L2_1616.html"><B>16</B></A>. Pointers in the 32-bit environment
are composed of a linear offset only; hence the addressing scheme is known
as <A HREF="719_L2_032.html"><B>0:32</B></A>.  Note that this difference
in representation applies not only to memory pointers, but also to window
and resource handles under Presentation Manager.<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Memory objects passed as parameters between 16-bit
and 32-bit routines must not be greater than 64KB in size, in order to avoid
problems with the 16-bit segmented memory model.<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Memory objects passed as parameters from 32-bit applications
to 16-bit routines must not lie across a segment boundary.<!-- lm: 0x2 0 -->
<BR>

<P>
Obviously, conversion of pointers and possible realignment of memory objects
is required when passing control between 16-bit and 32-bit modules. This
conversion between addressing schemes is known under OS/2 Version 2.0 as
<A HREF="699_L2_thunking.html"><B>thunking</B></A>. Thunking is performed
using a simple algorithm known as the <A HREF="528_L2_compatabilityregionm.html"><B>Compatibility
Region Mapping Algorithm</B> (<B>CRMA</B>)</A>.  This algorithm, along with
sample code, is described in<I> OS/2 Version 2.0 - Volume 1:  Control Program</I>.


<P><HR>

<A HREF="374_L2_Summary.html">[Back: Summary]</A> <BR>
<A HREF="376_L2_FunctionCallsto16Bit.html">[Next: Function Calls to 16-Bit Modules]</A> 
</BODY>
</HTML>
