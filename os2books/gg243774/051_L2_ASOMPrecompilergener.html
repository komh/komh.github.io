<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>A SOM Precompiler-generated Function Stub</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>A SOM Precompiler-generated Function Stub</H1><!-- entering slot 52 -->
<PRE>/*
 *
 *  METHOD:   QueryInfo                                   PRIVATE
 *
 *  PURPOSE:  Copy the PWFolder instance data into
 *            the PWF_INFO structure that pPWFolderInfo
 *            points to.
 *                           ┌─────2
 */                          │                           ┌──────3
                                                        .
SOM_Scope BOOL     SOMLINK pwFolder_QueryInfo(PWFolder *somSelf,
                               PPWF_INFO pPWFolderInfo)
{              └───1
    PWFolderData *somThis = PWFolderGetData(somSelf); 4
    PWFolderMethodDebug("PWFolder","pwfolder_QueryInfo"); 5

    &lt;application logic&gt; 6

    return((BOOL)0);
}             
              └────7
</PRE>

<P>
<B>Notes:</B>
<P>
1 SOM_Scope declares the function scope according to the language being
used. For example, in C++, SOM_Scope would be defined as<I> extern C</I> but
in C it is simply defined as<I> extern</I>.
<P>
2 It can be seen that the external prefix "pwfolder_", which was specified
in the class definition file, has been placed in front of the function as
expected.  Note that the SOM Precompiler generates a macro for this function
in the private header file:
<PRE>   #define _QueryInfo PWFolder_QueryInfo
</PRE>

<P>
This avoids the necessity for the programmer to type the full function name,
and helps make the code more readable.
<P>
3 Since SOM uses the C language, methods from SOM objects cannot be referenced
in a very elegant manner.  The first parameter to a SOM method must be a
pointer to an object that can invoke that method.  In the actual method
function, this pointer is given the name<I> somSelf</I>.  For example, the
difference between C and C++ is as follows:
<PRE>   /* Let us say */

        pMyObject =  (pointer to an object);

   // in C++ the following syntax may be used

        pMyObject-&gt;Method(param1, param2....);

   /* but in C the following is required */

        Method(pMyObject, param1, param2....);
</PRE>

<P>
4 This statement uses the pointer to the object to initialize a pointer
to access the object's instance data.  See <A HREF="271_L3_Methods.html">Methods
(Method Processing and Instance Data)</A> for further information on instance
data.
<P>
5 This line will perform tracing.  Tracing is switched on whenever the SOM
global variable<I> SOM_TraceLevel</I> is set to a non-zero value.
<P>
6 This section is left blank by the SOM Precompiler for the developer to
fill with the applicaton logic.  This logic may include access to system
and/or Presentation Manager resources.  For the password-protected folder
example, the<I> _QueryInfo</I> method must copy the instance variables to
the PWF_INFO data structure defined in the passthru section of the class
definition file. The code required to do this is as follows:
<PRE>   strcpy(pPWFolderInfo-&gt;szPassword, _szPassword);
   strcpy(pPWFolderInfo-&gt;szCurrentPassword, _szCurrentPassword);
   strcpy(pPWFolderInfo-&gt;szUserid, _szUserid);
</PRE>

<P>
This code must be inserted in the C source file by the programmer, after
the file is generated by the SOM Precompiler.  This may be done using a
normal text editor.
<P>
7 Finally, the SOM Precompiler provides a default zero return statement,
typecast with the return data type of the method as declared in the methods
section of the class definition file.  This statement may be altered by
the programmer if required, provided that consistency with the method's
prototype and<!-- entering slot 53 --> declaration is maintained. 

<P><HR>

<A HREF="050_L2_InvokingaMethodinAno.html">[Back: Invoking a Method in Another Object Class]</A> <BR>
<A HREF="052_L2_RegisteringaWorkplac.html">[Next: Registering a Workplace Shell Object Class]</A> 
</BODY>
</HTML>
