<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Direct Manipulation</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Direct Manipulation</H1><!-- entering slot 233 -->
<P>
In OS/2 Version 1.3, a set of functions and messages were provided for direct
manipulation, but each program had to provide its own code to take advantage
of these functions, and define its own protocols to be observed during drag/drop
operations, so that each program knew what type of information was being
transferred.
<P>
These protocols are called<I> Rendering Mechanisms</I>. Three standard ones
were defined in OS/2 Version 1.3:<!-- lm: 0x2 0 -->
<P>
<B>Print</B><!-- lm: 0x2 13 -->
<UL> Provided a mechanism to enable printing
by direct manipulation<!-- lm: 0x2 0 -->
</UL><B> OS/2 File</B><!-- lm: 0x2 13 -->
<UL> Intended
to be used by PM programs that wanted to move and copy files by direct manipulation
(such as the File Manager)<!-- lm: 0x2 0 -->
</UL><B> DDE</B><!-- lm: 0x2 13 -->
<UL> Enabled
Dynamic Data Exchange links to be established by direct manipulation.<!-- lm: 0x2 0 -->
</UL>
<P>
Since PM did not provide common objects, such as printers and shredders,
to implement these protocols the value of these rendering mechanisms was
reduced. The apparent complexity of the direct manipulation functions and
protocols also inhibited their use.
<P>
More importantly, however, the non-object-oriented structure of most PM
applications made designing direct manipulation into existing programs both
difficult and largely ineffectual. The benefit of direct manipulation is
directly proportional to the granularity of the objects being manipulated;
where the finest grained object is a file, the only other objects it can
interact with are containers and devices. Such interactions can as easily
be implemented by the shell, as is shown by the implementation of the WPS.

<P>
OS/2 Version 2.0 provides many common objects which can be used by applications,
all of which are drag/drop enabled. When an icon (representing a WPS object
or something dragged from a PM program) is dragged over a WPS object, that
target object will send a message to the source object to try to complete
a direct manipulation operation.
<P>
That message says what the target icon does, so a successful drop depends
on the source and target object implementing a common rendering mechanism;
that is, the source object must be able to:<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Understand the message<!-- lm: 0x2 0 --> <!-- lm: 0x2 2 -->
<UL>Perform
the action carried in the message.<!-- lm: 0x2 0 -->
</UL>
<P>
If the source icon represents something that is unsuitable for dropping
on this target object, then a drop will not be allowed and the user will
be informed by the pointer changing to a "no-entry" symbol.
<P>
Where possible, the WPS includes standard PM rendering mechanisms (for example,
DM_DISCARDOBJECT) as well as its own WP messages (for example, (WP_DELETE).
It is therefore possible for a PM application to interact with WPS devices
by coding appropriate responses into the application using the drag/drop
APIs. To do this, the programmer must know and understand the rendering
mechanisms used by each WPS object.
<P>
This is made more difficult because the WPS, for performance reasons, often
implements functions within the core classes rather than leaving it to objects
derived from the base classes, such as<I> WPFileSystem</I>, to carry out
the action.<!-- entering slot 234 --> Thus, when dragging a file to the
shredder, the file does not receive the WP_Delete message; instead, the
shredder program tells the OS/2 file system to delete the file.

<P><HR>

<A HREF="210_L3_FileAssociations.html">[Back: File Associations]</A> <BR>
<A HREF="212_L3_WPSEventsMessages.html">[Next: WPS Events/Messages]</A> 
</BODY>
</HTML>
