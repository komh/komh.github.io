<HTML>
<HEAD>
<TITLE>Infinity and NaN Support</TITLE>
</HEAD>
<BODY>
<H1>Infinity and NaN Support</H1><!-- entering slot 48 -->
<P>
<I>The IBM Developer's Toolkit for OS/2 Warp Version 4</I> compiler supports
the use of infinity and NaN (not-a-number) values. Infinity is a value with
an associated sign that is mathematically greater in magnitude than any
binary floating-point number. A NaN is a value in floating-point computations
that is not interpreted as a mathematical value, and that contains a mask
state and a sequence of binary digits.
<P>
The value of infinity can be computed from 1.0 / 0.0. The value of a NaN
can be computed from 0.0 / 0.0.
<P>
Depending on its bit pattern, a NaN can be either quiet (NaNQ) or signaling
(NaNS), as defined in the<I> ANSI/IEEE Standard for Binary Floating-Point
Arithmetic</I> (754-1982). A NaNQ is masked and never generates exceptions.
A NaNS may be masked and may generate an exception, but does not necessarily
do so.<I> The Developer's Toolkit for OS/2 Warp Version 4</I> compiler supports
only quiet NaN values; all NaN values discussed below refer to quiet NaNs.

<P>
NaN and infinity values are defined as macro constants in the &lt;float.h&gt;
header file. The macros are:  compact break=fit.<B><!-- lm: 0x2 1 -->
<UL>
<P>
Macro<!-- lm: 0x2 13 -->
<UL> Description</B><!-- lm: 0x2 1 -->
</UL> _INFINITYF
<!-- lm: 0x2 13 -->
<UL>Infinity of type<B> float</B><!-- lm: 0x2 1 -->
</UL> _INFINITY
<!-- lm: 0x2 13 -->
<UL>Infinity of type<B> double</B><!-- lm: 0x2 1 -->
</UL> _INFINITYL
<!-- lm: 0x2 13 -->
<UL>Infinity of type<B> long double</B><!-- lm: 0x2 1 -->
</UL>  
<!-- lm: 0x2 13 -->
<UL> <!-- lm: 0x2 1 -->
</UL> _INFF<!-- lm: 0x2 13 -->
<UL> Same
as _INFINITYF<!-- lm: 0x2 1 -->
</UL> _INF<!-- lm: 0x2 13 -->
<UL> Same
as _INFINITY<!-- lm: 0x2 1 -->
</UL> _INFL<!-- lm: 0x2 13 -->
<UL> Same
as _INFINITYL<!-- lm: 0x2 1 -->
</UL>  <!-- lm: 0x2 13 -->
<UL>  <!-- lm: 0x2 1 -->
</UL> _NANF
<!-- lm: 0x2 13 -->
<UL>Quiet NaN of type<B> float</B><!-- lm: 0x2 1 -->
</UL> _NAN
<!-- lm: 0x2 13 -->
<UL>Quiet NaN of type<B> double</B><!-- lm: 0x2 1 -->
</UL> _NANL
<!-- lm: 0x2 13 -->
<UL>Quiet NaN of type<B> long double</B>.<!-- lm: 0x2 1 -->
</UL>
<P>
You can get the corresponding negative values by using the unary minus operator
(for example, -_INF).
<P>
<B>Note: </B> The value of 0.0 can also be positive or negative. For example,
1.0 / (-0.0) results in -_INF.<!-- lm: 0x2 1 -->
<P>

<P>
Because these macros are actually references to constant variables, you
cannot use them to initialize static variables. For example, the following
statements are not allowed:
<PRE>   static double infval = _INF;   static float nanval = 1.0 + _NANF;
</PRE>
However, you can initialize static variables to the numeric values of infinity
and NaN:
<PRE>   static double infval = 1.0 / 0.0;
   static float nanval =  0.0 / 0.0;
</PRE>

<P>
<B>Note: </B> Although positive and negative infinities are specific bit
patterns, NaNs are not. A NaN value is not equal to itself or to any other
value. For example, if you assign a NaN value to a variable x, you cannot
check the value of x with the statement if (_NAN == x). Instead, use the
statement if (x != x).
<P>
All relational and equality expressions involving NaN values always evaluate
to FALSE or zero (0), with the exception of not equal (!=), which always
evaluates to TRUE or one (1).<!-- lm: 0x2 1 -->
<P>

<P>
For information on the bit mapping and storage mapping of NaN and infinity
values, see the<I> User's Guide</I>.

<P><HR>

<A HREF="047_L3_HeapSpecificFunction.html">[Back: Heap-Specific Functions]</A> <BR>
<A HREF="049_L3_InfinityandNaNinLibr.html">[Next: Infinity and NaN in Library Functions]</A> 
</BODY>
</HTML>
