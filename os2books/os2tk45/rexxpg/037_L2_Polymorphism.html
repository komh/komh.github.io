<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Polymorphism</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Polymorphism</H1><!-- entering slot 41 -->
<P>
REXX lets you send the same message to objects that may be dissimilar:
<PRE>'!iH'~reverse  /* Reverses the characters "!iH" to form "Hi!"  */
pen~reverse     /* Reverses the direction of a plotter pen      */
ball~reverse    /* Reverses the direction of a moving ball      */
</PRE>

<P>
As long as the dissimilar objects (like the preceding !iH-string, pen, and
ball) each have their own REVERSE method corresponding with the message,
REVERSE will run even though the programming implementation may be very
different for each object. This ability to hide different functions behind
a common interface is called<I> polymorphism</I>. As a result of information
hiding, each object in the above example knows only its own version of REVERSE.
And even though the objects are dissimilar, each will reverse itself as
dictated by its own code.
<P>
Although the !iH object's REVERSE code is different from the plotter pen's,
the method name can be the same because REXX keeps track of the methods
each object owns. The ability to reuse the same method name so that one
message can initiate more than one function is another feature of polymorphism.
You don't need to have multiple message names like REVERSE_STRING, REVERSE_PEN,
REVERSE_BALL, REVERSE_<I>anyobject.</I> This keeps method-naming schemes
simpler and makes complex programs easier to follow and modify.
<P>
The ability to hide the various implementations of a method while leaving
the interface the same illustrates polymorphism at its lowest level. On
a higher level, polymorphism permits extensive code reuse.
<P>


<P><HR>

<A HREF="036_L2_MethodsAreCodedActio.html">[Back: Methods Are "Coded Actions"]</A> <BR>
<A HREF="038_L2_ClassesandInstances.html">[Next: Classes and Instances]</A> 
</BODY>
</HTML>
