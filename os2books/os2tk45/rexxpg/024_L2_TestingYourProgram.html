<HTML>
<HEAD>
<TITLE>Testing Your Program</TITLE>
</HEAD>
<BODY>
<H1>Testing Your Program</H1><!-- entering slot 24 -->
<P>
When writing your program, you can conveniently test statements as you go
along using the REXXTRY command from the OS/2 command prompt. REXXTRY is
a kind of REXX mini-interpreter that checks REXX statements one at a time.
If you run it with no parameter, or with a question mark as a parameter,
REXXTRY will also briefly describe itself.
<P>
From your current OS/2 window, just open another window and from the command
prompt type:
<PRE>rexxtry
</PRE>

<P>
REXXTRY will describe itself and ask you for a REXX statement to test. Enter
your statement; REXXTRY will run it and return any information, or display
an error message if a problem is encountered. REXXTRY remembers any previous
statements you have entered during the session, so to continue just type
the next line in your program and REXXTRY will check it for you.
<P>
Enter an equal sign (=) to repeat your previous statement, or a question
mark (?) to invoke system-provided online information about the REXX language.

<P>
When you're done, type:
<PRE>exit
</PRE>

<P>
and press Enter to leave REXXTRY.
<P>
You can also enter a REXX statement directly on the command line for immediate
processing and exit:
<PRE>rexxtry call show
</PRE>

<P>
In this case, entering CALL SHOW displays the user variables provided by
REXXTRY.
<P>
Whereas REXXTRY runs and debugs one REXX statement at a time, you can use
PMREXX to do the same for an entire REXX procedure. PMREXX is a windowed
application that shows, in a PMREXX window, any results displayed by your
REXX procedure. You can scroll through the window using its scroll bar to
view all the output.
<P>
PMREXX also provides a single line input field, so that you can supply input
to the REXX procedure or to any commands called by it.
<P>
PMREXX is an OS/2 installation option; it is available if you select it
during OS/2 installation. Assuming you've done this and PMREXX is available,
you start it by entering PMREXX from an OS/2 command prompt, followed by
the name of a REXX procedure you want to run; for example:
<PRE>pmrexx myprog
</PRE>

<P>
You can also supply arguments for the REXX procedure. In the next example,
PMREXX will run the procedure MYPROG and pass MYPROG the argument c:\test\test.data:

<PRE>pmrexx myprog c:\test\test.data
</PRE>

<P>
PMREXX will run the REXX procedure and display any output generated by it
in a scrollable output box that is part of the PMREXX window. If the procedure
prompts for input, the prompt is displayed in the output box. You would
then type the response in the<I> smaller input box</I> near the top of the
PMREXX window.
<P>
To try it, start an OS/2 session and create this REXX procedure:
<PRE>/* DIRTEST.CMD -- displays directory contents */
do forever
   say 'Enter the name of a directory'
   parse upper pull response
   if response='QUIT' then leave
   'dir' response
end
exit
</PRE>

<P>
Then start PMREXX again for the DIRTEST procedure:
<PRE>pmrexx dirtest
</PRE>

<P>
When the PMREXX window is displayed, you'll see the prompt in the output
box. Position the cursor in the input box, type the name of a directory,
and press Enter. The contents of the directory will be listed in the output
box, and another prompt will be displayed.
<P>
When the amount of displayed output exceeds the size of the output box,
a slider box appears in the scroll bar.
<P>
To end the DIRTEST program, type:
<PRE>quit
</PRE>

<P>
in the input box and press Enter.
<P>
When you run your REXX programs with PMREXX, you can use a function called
RxMessageBox to display messages. This example uses it to display an error
message:
<PRE>/* ERROR.CMD -- Check the input parameter */
arg count
if count~datatype('Whole') &lt;&gt; 0 then do
  RxMessageBox("Argument" count "is not a whole number")
  exit
end
</PRE>

<P>
RxMessageBox displays a Presentation Manager message box titled<B> Error!
</B>and an<B><!-- entering slot 25 --> OK</B> button. The REXX program waits
until you click<B> OK</B>.
<P>
You can change the message box title and buttons, and add a colorful icon
to the message box:
<PRE>/* FILECHK.CMD -- Does the file exist? */
if file~Query('Exists') &lt;&gt; ''
  then do
    reply = RxMessageBox("Do you want to replace file",,
        "Replace File?", "YesNo", "Question")
    if reply = 7 then exit         /* user pressed 'No' */
  end
</PRE>

<P>
FILECHK.CMD displays a question in a message box with a question-mark icon
and two buttons, labeled<B> Yes</B> and<B> No.</B> Clicking<B> Yes</B> or
<B>No</B> gives your program the number of the button you chose. (<B>Yes
</B>is 6 and<B> No</B> is 7.)
<P>
To use PMREXX as a miniature development environment for your procedures,
run PMREXX in one OS/2 session and an editor in another session. Use the
editor to change and save the procedure being developed. Then switch to
the PMREXX session to run the modified procedure.
<P>
You can restart a procedure from PMREXX by selecting<B> Trace</B> from the
action bar in the PMREXX window. If the procedure is running, select<B> Halt
procedure</B> to stop it, then select<B> Restart</B> from the menu. Otherwise,
just select<B> Restart</B>. The latest version of the procedure will run
again.
<P>
PMREXX includes several functions useful for debugging your procedures.
You can, for instance, start an interactive trace from PMREXX without having
to add a TRACE instruction to your procedure. Select<B> Trace</B> on the
action bar, and then select<B> Interactive trace on</B>. A check mark on
the menu shows that interactive tracing is on. To stop the interactive trace,
just select<B> Interactive trace on</B> again. One advantage of using the
interactive trace from PMREXX is that you can turn the trace on and off
while the program is running.
<P>
Once tracing is active, you can step through your procedure one clause at
a time, re-do a clause that was just processed, or enter a line of REXX
clauses for immediate processing. The ability to enter REXX clauses is especially
useful if you want to try a fix to a problem interactively or if you want
to test instruction paths that are otherwise difficult to trigger.
<P>
For example, you might want to test some error handling instructions, but
cannot easily create the condition that would cause the error. By using
the interactive trace, you can add REXX instructions at the right moment
to fake the conditions that would cause the error handling instructions
to be processed.
<P>
To process a line of one or more REXX clauses, type the line in the PMREXX
input box when tracing is active and press Enter. For example, you could
enter:
<PRE>do i=1 to 10; say 'hello' i; end
</PRE>

<P>
The line is processed before the next REXX clause in the program is processed.
If you simply want to step ahead to the next clause, press Enter without
typing anything in the input area. You can also step ahead by selecting
<B>Trace next clause</B> from the<B> Trace</B> menu. If you want to process
the last REXX clause again, select<B> Re-do last clause</B> from the<B> Trace
</B>menu.
<P>
To stop tracing, select<B> Trace off</B> from the<B> Trace</B> menu. This
item is not selectable when the REXX procedure is waiting for user input.
In this case select<B> Interactive trace on</B> again to stop the trace.

<P>


<P><HR>

<A HREF="023_L2_WritingYourProgram.html">[Back: Writing Your Program]</A> <BR>
<A HREF="025_L2_VariablesConstantsan.html">[Next: Variables, Constants, and Literal Strings]</A> 
</BODY>
</HTML>
