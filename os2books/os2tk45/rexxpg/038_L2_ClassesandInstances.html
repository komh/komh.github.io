<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Classes and Instances</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Classes and Instances</H1><!-- entering slot 42 -->
<P>

<P>
In REXX, objects are organized into classes. The reason is not unlike why
biologists categorize living things in hierarchies--to organize them by
their similarities and lines of inheritance.<I> Classes</I> are like templates;
they define the methods and variables a group of similar objects have in
common. Rather than replicate the same methods and variables over and over
for each similar object in your program, classes provide an efficient way
to store these common actions and characteristics in one place.
<P>
If you were writing a program to manipulate some screen icons, for example,
you might create an Icon class. In that Icon class you could include all
the icon objects with similar actions and characteristics:
<BR>
A simple class
<BR>

<BR>
  ┌───────────────────
<BR>
  │
<BR>
  │
<BR>
Icon class
<BR>

<BR>
OS/2 system icon instance
<BR>
shredder icon instance
<BR>
information icon instance
<BR>
.
<BR>
.
<BR>
.
<BR>

<BR>

<P>
All the icon objects might use common methods like DRAW or ERASE. They might
contain common variables like position or color or size. What makes each
icon object different from one another is the data assigned in its variables.
Perhaps for the OS/2 system icon, position='20,20', while for shredder it's
'20,30' and for information it's '20,40':
<BR>
Icon class
<BR>

<BR>
  ┌───────────────────
<BR>
  │
<BR>
  │
<BR>
Icon class
<BR>

<BR>
OS/2 system icon instance
<BR>
 (position='20,20')
<BR>

<BR>
shredder icon instance
<BR>
 (position='20,30')
<BR>

<BR>
information icon instance
<BR>
 (position='20,40')
<BR>

<BR>

<P>
Objects that belong to a class are called<I> instances</I> of that class.
As instances of the Icon class, the OS/2 system icon, shredder icon, and
information icon<I> acquire</I> the methods and variables of that class.
The instance objects behave exactly as if they each had their own separate
methods and variables of the same names. All the instances actually store,
however, are their own unique properties--the<I> data</I> associated with
the variables. Everything else can be retained at the class level.
<BR>
Instances of the Icon class
<BR>

<BR>
  ┌───────────────────
<BR>
  │
<BR>
  │
<BR>
Icon class
<BR>
 (position=)
<BR>

<BR>
OS/2 system icon instance
<BR>
 ('20,20')
<BR>

<BR>
shredder icon instance
<BR>
 ('20,30')
<BR>

<BR>
information icon instance
<BR>
 ('20,40')
<BR>

<BR>

<P>
A very useful thing about this arrangement is that, should it become necessary
to update or change a particular method, you would only have to change it
in one place, at the class level. This single update would then be acquired
by every new instance that used the method. In cases where a class has hundreds
of instances, the efficiency of this approach is clear.
<P>
A class that can create instance objects is called an<I> object class.</I> Our
hypothetical Icon class is an object class you can use to create other objects
with like properties. In the future you may want to create an application
icon or a drives icon.
<P>
An object class can produce objects as a cookie cutter produces cookies.
It is like a factory for producing objects. In particular, these are a class's
<I>instance</I> objects.
<P>


<P><HR>

<A HREF="037_L2_Polymorphism.html">[Back: Polymorphism]</A> <BR>
<A HREF="039_L2_DataAbstraction.html">[Next: Data Abstraction]</A> 
</BODY>
</HTML>
