<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Execution</TITLE>
</HEAD>
<BODY>
<H1>Execution</H1><!-- entering slot 50 -->
<P>
386 execution consists of the classic pattern of fetching an instruction
from memory and executing it, then repeating the process.  The instructions
are always found in a code segment accessed via the descriptor designated
by the selector in the CS register.  The current privilege level of the
program is contained by the two low order bits in the CS register.  The
offset of the next instruction is contained in the instruction pointer,
(IP or EIP) which is incremented as each instruction is fetched. The 386
and following generations recognize a great number of instructions, but
compilers generate a very small subset of the whole instruction set.  Much
of that subset will be discussed here. If you cannot ascertain what an instruction
does when you encounter it, look it up in the appropriate reference manual.
Instructions are generally executed sequentially, and the processor attempts
to fetch instructions well in advance, to increase execution speed. The
flow of control departs from sequential when a jump, call, return, interrupt
or interrupt return is encountered.  Jumps are conditional or unconditional.
 Conditional jumps are used to implement decisions and contain a relative
offset which is combined with IP by signed addition to cause a different
instruction in the same segment to be executed next.  Calls, returns and
unconditional jumps come in two varieties:  NEAR and FAR.  The NEAR variety
update only IP and leave CS untouched.  The FAR variety update both CS and
IP and are potentially quite complex.  CALL, RETurn and interrupts require
a stack.  Most instructions reference the registers.

<P><HR>

<A HREF="037_L3_RegisterReview.html">[Back: Register Review]</A> <BR>
<A HREF="039_L3_GeneralRegisters.html">[Next: General Registers]</A> 
</BODY>
</HTML>
