<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Semaphores</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Semaphores</H1><!-- entering slot 142 -->
<P>
The least intrusive way to guarantee serial access to a shared resource
is to associate a semaphore with it, and to acquire ownership of the semaphore
before accessing the resource. The application threads will be suspended
only when there is actual contention for the resource.
<P>
This does require all of the programmers involved to be careful to request
the semaphore before accessing the resource, and to remember to free it
when done.  The classic solution to this is to build a low-level function
which includes the serialization.
<P>
Semaphores are of three categories:<!-- lm: 0x2 2 -->
<UL>
<P>
 <LI><LI><!-- lm: 0x2 6 -->Kernel Semaphores, or KSEMS.<!-- lm: 0x2 1 -->
</UL> KSEMS
will be discussed later, because we will focus first on items available
to the application programmer.<!-- lm: 0x2 2 -->
<UL>
<P>
 <LI><LI><!-- lm: 0x2 6 -->16-bit semaphores.<!-- lm: 0x2 1 -->
</UL> There
are two basic kinds of 16-bit semaphores, and an add-on structure which
makes a third type by aggregation.
<P>
They are the System Semaphore, the RamSem, and the FastSafe RamSem, which
is an accounting structure prefixed onto a RamSem.<!-- lm: 0x2 2 -->
<UL>
<P>
 <LI><LI><!-- lm: 0x2 6 -->32-bit semaphores.<!-- lm: 0x2 1 -->
</UL> There
are two types of 32-bit semaphores, Mutual Exclusion, or MutEx and Event
Semaphores. It is also possible to wait on a list of EventSems or MutexSems,
but all semaphores in a list must be of the same type.<!-- lm: 0x2 1 -->
<BR>


<P><HR>

<A HREF="115_L3_DosSuspendThread&Dos.html">[Back: DosSuspendThread & DosResumeThread]</A> <BR>
<A HREF="117_L3_16bitSemaphores.html">[Next: 16-bit Semaphores]</A> 
</BODY>
</HTML>
