<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>Unicode Functions (OS/2 Warp)</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="Namo WebEditor v1.10">
</head>
<body bgcolor="#FFFFFF" text="#000000" >

<h1>Unicode Functions (OS/2 Warp)</h1>
<p><b>Second Edition (October 1997)</b></p>
<p>This document describes the OS/2 Warp Universal Language Support (ULS)
functions.  These functions provide APIs and data types to support
internationalization of applications.
<p>This document is broken up into four major sections:
<ul type="disc">
<li><a href="#ToC_100"><b>Locale and Character Classification Functions</b></a>
<li><a href="#ToC_98"><b>Codepage Conversion Functions</b></a>
<li><a href="#ToC_9"><b>ULS Data Types</b></a>
<li><a href="#NOTICES"><b>Notices</b></a>
</ul>
<p><hr></p>
<h2><a name="ToC">Table of Contents</a></h2>
<p><b><a href="#HDRUNILSF" name="ToC_100">Locale and Character Classification Functions</a></b><br>
<ul type="disc">
<li><a href="#LENSM50304" name="ToC_304">UniCompleteUserLocale</a>
<li><a href="#LENSM50098" name="ToC_1">UniCreateAttrObject</a>
<li><a href="#LENSM50099" name="ToC_2">UniCreateLocaleObject</a>
<li><a href="#LENSM50100" name="ToC_3">UniCreateTransformObject</a>
<li><a href="#LENSM50303" name="ToC_303">UniDeleteUserLocale</a>
<li><a href="#LENSM50101" name="ToC_4">UniFreeAttrObject</a>
<li><a href="#LENSM50102" name="ToC_5">UniFreeLocaleInfo</a>
<li><a href="#LENSM50103" name="ToC_6">UniFreeLocaleObject</a>
<li><a href="#LENSM50104" name="ToC_7">UniFreeMem</a>
<li><a href="#LENSM50105" name="ToC_8">UniFreeTransformObject</a>
<li><a href="#LENSM50107" name="ToC_10">UniLocaleStrToToken</a>
<li><a href="#LENSM50108" name="ToC_11">UniLocaleTokenToStr</a>
<li><a href="#LENSM50302" name="ToC_302">UniMakeUserLocale</a>
<li><a href="#LENSM50180" name="ToC_70">UniMapCtryToLocale</a>
<li><a href="#LENSM50109" name="ToC_12">UniQueryAlnum</a>
<li><a href="#LENSM50111" name="ToC_13">UniQueryAlpha</a>
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50113" name="ToC_14">UniQueryBlank</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_15">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
<li><a href="#LENSM50116" name="ToC_16">UniQueryCntrl</a>
<li><a href="#LENSM50307" name="ToC_307">UniQueryCountryName</a>
<li><a href="#LENSM50118" name="ToC_17">UniQueryDigit</a>
<li><a href="#LENSM50120" name="ToC_18">UniQueryGraph</a>
<li><a href="#LENSM50306" name="ToC_306">UniQueryLanguageName</a>
<li><a href="#LENSM50123" name="ToC_20">UniQueryLocaleInfo</a>
<li><a href="#LENSM50124" name="ToC_21">UniQueryLocaleItem</a>
<li><a href="#LENSM50305" name="ToC_305">UniQueryLocaleList</a>
<li><a href="#LENSM50125" name="ToC_22">UniQueryLocaleObject</a>
<li><a href="#LENSM50300" name="ToC_300">UniQueryLocaleValue</a>
<li><a href="#LENSM50126" name="ToC_23">UniQueryLower</a>
<li><a href="#LENSM50313" name="ToC_313">UniQueryNumericValue</a>
<li><a href="#LENSM50128" name="ToC_24">UniQueryPrint</a>
<li><a href="#LENSM50130" name="ToC_25">UniQueryPunct</a>
<li><a href="#LENSM50132" name="ToC_26">UniQuerySpace</a>
<li><a href="#LENSM50310" name="ToC_310">UniQueryStringType</a>
<li><a href="#LENSM50134" name="ToC_27">UniQueryUpper</a>
<li><a href="#LENSM50136" name="ToC_28">UniQueryXdigit</a>
<li><a href="#LENSM50138" name="ToC_29">UniScanForAttr</a>
<li><a href="#LENSM50301" name="ToC_301">UniSetUserLocaleItem</a>
<li><a href="#LENSM50139" name="ToC_30">UniStrcat</a>
<li><a href="#LENSM50140" name="ToC_31">UniStrchr</a>
<li><a href="#LENSM50141" name="ToC_32">UniStrcmp</a>
<li><a href="#LENSM50142" name="ToC_33">UniStrcmpi</a>
<li><a href="#LENSM50143" name="ToC_34">UniStrcoll</a>
<li><a href="#LENSM50144" name="ToC_35">UniStrcpy</a>
<li><a href="#LENSM50145" name="ToC_36">UniStrcspn</a>
<li><a href="#LENSM50146" name="ToC_37">UniStrfmon</a>
<li><a href="#LENSM50147" name="ToC_38">UniStrftime</a>
<li><a href="#LENSM50148" name="ToC_39">UniStrlen</a>
<li><a href="#LENSM50149" name="ToC_40">UniStrlwr</a>
<li><a href="#LENSM50150" name="ToC_41">UniStrncat</a>
<li><a href="#LENSM50151" name="ToC_42">UniStrncmp</a>
<li><a href="#LENSM50152" name="ToC_43">UniStrncmpi</a>
<li><a href="#LENSM50153" name="ToC_44">UniStrncpy</a>
<li><a href="#LENSM50154" name="ToC_45">UniStrpbrk</a>
<li><a href="#LENSM50155" name="ToC_46">UniStrptime</a>
<li><a href="#LENSM50156" name="ToC_47">UniStrrchr</a>
<li><a href="#LENSM50157" name="ToC_48">UniStrspn</a>
<li><a href="#LENSM50158" name="ToC_49">UniStrstr</a>
<li><a href="#LENSM50159" name="ToC_50">UniStrtod</a>
<li><a href="#LENSM50160" name="ToC_51">UniStrtol</a>
<li><a href="#LENSM50161" name="ToC_52">UniStrtok</a>
<li><a href="#LENSM50162" name="ToC_53">UniStrtoul</a>
<li><a href="#LENSM50163" name="ToC_54">UniStrupr</a>
<li><a href="#LENSM50164" name="ToC_55">UniStrxfrm</a>
<li><a href="#LENSM50166" name="ToC_57">UniTolower</a>
<li><a href="#LENSM50167" name="ToC_58">UniToupper</a>
<li><a href="#LENSM50168" name="ToC_59">UniTransformStr</a>
<li><a href="#LENSM50169" name="ToC_60">UniTransLower</a>
<li><a href="#LENSM50170" name="ToC_61">UniTransUpper</a>
</ul>
<p><b><a href="#HDRUNICF" name="ToC_98">Codepage Conversion Functions</a></b><br>
<ul type="disc">
<li><a href="#LENSM50177" name="ToC_67">UniCreateUconvObject</a>
<li><a href="#LENSM50178" name="ToC_68">UniFreeUconvObject</a>
<li><a href="#LENSM50179" name="ToC_69">UniMapCpToUcsCp</a>
<li><a href="#LENSM50181" name="ToC_71">UniQueryUconvObject</a>
<li><a href="#LENSM50182" name="ToC_72">UniSetUconvObject</a>
<li><a href="#LENSM50183" name="ToC_73">UniUconvFromUcs</a>
<li><a href="#LENSM50184" name="ToC_74">UniUconvToUcs</a>
<li><a href="#LENSM50185" name="ToC_75">UniStrFromUcs</a>
<li><a href="#LENSM50186" name="ToC_76">UniStrToUcs</a>
</ul>
<p><b><a href="#HDRUNIDATA" name="ToC_9">ULS Data Types</a></b><br>
<ul type="disc">
<li><a href="#LENSM50290" name="ToC_180">AttrObject</a>
<li><a href="#LENSM50203" name="ToC_93">conv_endian_t</a>
<li><a href="#LENSM50291" name="ToC_181">LocaleItem</a>
<li><a href="#LENSM50289" name="ToC_179">LocaleObject</a>
<li><a href="#LENSM50292" name="ToC_182">LocaleToken</a>
<li><a href="#LENSM50293" name="ToC_183">struct UniLconv</a>
<li><a href="#LENSM50285" name="ToC_175">uconv_attribute_t</a>
<li><a href="#LENSM50294" name="ToC_184">UconvObject</a>
<li><a href="#LENSM50286" name="ToC_176">udcrange_t</a>
<li><a href="#LENSM50295" name="ToC_185">ulsBool</a>
<li><a href="#LENSM50288" name="ToC_178">UniChar</a>
<li><a href="#LENSM70999" name="ToC_799">UNICTYPE</a>
<li><a href="#LENSM50296" name="ToC_186">XformObject</a>
</ul>


<p><hr> </p>
<h1><a href="#ToC_100" name="HDRUNILSF">Universal Language Support Functions</a></h1>
<p>Internationalized applications are required to operate in a variety of environments based on some territory, language, and/or
cultural definition. These environments are identified by a <i>locale</i>, an object which encapsulates culturally specific
information. The locale identifies the culture, language, and territory that it supports. </p>
<h2><a href="#ToC_304" name="LENSM50304">UniCompleteUserLocale</a></h2>
<p>UniCompleteUserLocale is used to finish a locale modification. This API is called after one or more UniSetLocaleItem calls
to cause the new user defined locale file to be saved. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniCompleteUserLocale </b>
<dd><b>(void)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> </p>
<p>None required. </p>
<p><strong>Returns</strong> <a name="SPTSP60304">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniCompleteUserLocale returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b><a name="SPTSV61304">&nbsp;</a>
<dd>Successful completion; overridden items have been written to a file.
<dt><b>ERROR_OPEN_FAILED </b><a name="SPTSV62304">&nbsp;</a>
<dd>DosOpen failed to open the locale file.
<dt><b>ERROR_ACCESS_DENIED </b><a name="SPTSV63304">&nbsp;</a>
<dd>DosWrite failed due to denied access.
<dt><b>ULS_NOMEMORY </b>
<dd><a name="SPTSV64304">&nbsp;</a> Insufficient memory to create a buffer for writing the new locale.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniCompleteUserLocale is used to complete the process of defining a new locale or modifying an existing locale. An
application will use the UniQueryLocale API's and UniSetUserLocaleItem API to take an existing locale definition and
customize that definition to form a new locale. When the customization process is complete, the UniCompleteUserLocale
API is invoked to save the results as a new locale. </p>
<p>The result of calling this API is that the locale is saved to disk as a new user locale or changes to an existing locale are saved
to disk to represent the newly created locale. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50303" name="ToC_303">UniDeleteUserLocale</a>
<li><a href="#LENSM50302" name="ToC_302">UniMakeUserLocale</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to complete a user locale after modifying
one or more locale items.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;

/* Array containing user locales */
UniChar     *uniUsrLocales;
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }

         /* allocate space for the user defined locales */
         uniUsrLocales = (UniChar *) malloc(4096);

         /* Query the list of user defined locales available to modify */
         rc = UniQueryLocaleList(UNI_USER_LOCALES, uniUsrLocales, 2048);

         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleList error: return code = %u\n&quot;, rc);
           return 1;
         }

         .
         .
         .
         /* Change locale definition by calling UniSetUserLocaleItem to make
            locale item changes.
         */
         .
         .
         .


         /* Write the current set of user locales to disk */
         rc = UniCompleteUserLocale();
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCompleteUserLocale error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;
         </pre>
<p>} </p>
<h2><a href="#ToC_1" name="LENSM50098">UniCreateAttrObject</a></h2>
<p>UniCreateAttrObject creates an attribute object that is used to determine character classifications. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniCreateAttrObject </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*AttrName, AttrObject&nbsp;*attr_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50453">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>Locale object created by a call to UniCreateLocaleObject() or NULL. <a name="SPTSP50454">&nbsp;</a>
<dd>&nbsp;
<dt>AttrName &nbsp;(const UniChar *)&nbsp;
<dd>A UniChar string that specifies the attribute names for which an attribute object should be created. Multiple attribute
names are specified as a string of separate names. <a name="SPTSP50455">&nbsp;</a>
<dd>&nbsp;
<dt>attr_object &nbsp;(AttrObject *)&nbsp;
<dd>An address that will receive a pointer to an attribute object upon successful completion of UniCreateAttrObject.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50456">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniCreateLocaleObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b><a name="SPTSV50173">&nbsp;</a>
<dd>Successful completion; attr_object points to a valid attribute object.
<dt><b>ULS_UNSUPPORTED </b><a name="SPTSV50174">&nbsp;</a>
<dd>The attribute name specified in AttrName is not supported by the locale_object.
<dt><b>ULS_NOMEMORY </b><a name="SPTSV50175">&nbsp;</a>
<dd>Insufficient memory to create the attribute object.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniCreateAttrObject allocates resources associated with an attribute defined in the LC_CTYPE category of the locale
indicated by the locale_object argument. </p>
<p>The locale_object argument specifies a locale object handle returned by UniCreateLocaleObject. It should not be a NULL
pointer. </p>
<p>The AttrName argument specifies the attribute names for which an attribute object handle should be created. Multiple
attribute names are specified as a string of space-separated names. </p>
<p>When UniCreateAttrObject completes without errors, the attr_object argument specifies a valid pointer to an attribute
object. </p>
<p>The attribute object pointer should be used in all subsequent calls to the UniQueryCharAttr. If the function result is other
than ULS_SUCCESS, the contents of the area pointed to by attr_object are undefined. </p>
<p>The following attribute names are the base POSIX attributes.  All attribute
names which can be specified in
<a href="#LENSM50309">UniQueryCharAttr</a>
are allowed.  Those attributes which start with underscore (_) or hash (#)
may not be combined with other attributes.
<dl>
<dt><b>alnum </b>
<dd>True when alpha or digit is true.
<dt><b>alpha </b>
<dd>True when upper or lower is true, or when none of cntrl, digit, punct, or space is true.
<dt><b>blank </b>
<dd>True for the characters space and horizontal tab.
<dt><b>cntrl </b>
<dd>True for any control character; the following attributes must be false: upper, lower, alpha, digit, xdigit, graph, print,
and punct.
<dt><b>digit </b>
<dd>True for the digits 0, 1, 2 3, 4, 5, 6, 7, 8, and 9.
<dt><b>graph </b>
<dd>True for any character with the print attribute, except the space
<dt><b>character </b>
<dd>(Code element 0x0020).
<dt><b>lower </b>
<dd>True for any character that is a lowercase letter and none of cntrl, digit, punct, or space is true.
<dt><b>print </b>
<dd>True for upper, lower, alpha, digit, xdigit, punct, or any printing character including the space character (code element
0x0020).
<dt><b>punct </b>
<dd>True for any printing character that is neither the space character (code element 0x0020) nor a character for which
alnum is true.
<dt><b>space </b>
<dd>True for any character that corresponds to a standard white-space character or is one of the set of white-space
characters in the locale as indicated by the locale_object argument for which alnum is false. The standard white-space
characters are the following: space, form feed, newline, carriage return, horizontal tab, and vertical tab.
<dt><b>upper </b>
<dd>True for any character that is an uppercase letter and none of cntrl, digit, punct, or space is true.
<dt><b>xdigit </b>
<dd>true for 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E F, a, b, c, d, e, and f.
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and use a character attribute object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
AttrObject   attr_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'a';    /* Unicode lowercase Latin letter a */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an alphabetic attribute object */
         rc = UniCreateAttrObject(locale_object,
                                 (UniChar *)L&quot;alpha&quot;, &amp;attr_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateAttrObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Make call to determine if character is alphabetic */
         result = UniQueryCharAttr(attr_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is alphabetic\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not alphabetic\n&quot;, uni_char);
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_2" name="LENSM50099">UniCreateLocaleObject</a></h2>
<p>UniCreateLocaleObject creates a locale object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniCreateLocaleObject </b>
<dd><b>(int&nbsp;LocaleSpecType, const void&nbsp;*LocaleSpec, LocaleObject&nbsp;*locale_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50457">&nbsp;</a>
<dl>
<dt>LocaleSpecType &nbsp;(int)&nbsp;
<dd>Identifies the type of value in the <b>LocaleSpec</b> argument.
<p>The constant names of the values of <b>LocaleSpecType</b> are defined in the header <b>unidef.h</b>:
<dl>
<dt><b>UNI_TOKEN_POINTER </b>
<dd>LocaleSpec points to a locale token.
<dt><b>UNI_MBS_STRING_POINTER </b>
<dd>LocaleSpec points to a multibyte character string.
<dt><b>UNI_UCS_STRING_POINTER </b>
<dd>LocaleSpec points to a UCS character string.
</dl>
<p><a name="SPTSP50458">&nbsp;</a>
<dt>LocaleSpec &nbsp;(const void *)&nbsp;
<dd>The <b>LocaleSpec</b> argument points to either a character string or a locale token, as indicated by the value of the
<b>LocaleSpecType</b> argument. <a name="SPTSP50459">&nbsp;</a>
<dd>&nbsp;
<dt>locale_object &nbsp;(LocaleObject *)&nbsp;
<dd>An address that will receive a pointer to a locale object upon successful completion of UniCreateLocaleObject.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50460">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniCreateLocaleObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The specified locale is supported and a valid locale object was created.
<dt><b>ULS_UNSUPPORTED </b>
<dd>The specified locale is not supported; the locale object pointer points to undefined data.
<dt><b>ULS_NOMEMORY </b>
<dd>There is insufficient memory to create the requested locale or the default locale; the locale object pointer points
to undefined data.
<dt><b>ULS_INVALID </b>
<dd>An invalid locale specification string or token was passed; the locale object pointer points to undefined data.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniCreateLocaleObject creates a locale object for the locale specified by <b>LocaleSpec</b>. The object created is an opaque
object containing all the data and methods necessary to perform the language-sensitive operations or functions that accept
an argument of type <b>LocaleObject</b>. If the function is successful, all categories of the locale object are created and initialized. </p>
<p>When the <b>LocaleSpec</b> argument is a pointer to a character string (UCS character string or multibyte character string), it
identifies the name of the locale to be initialized. The locale name is used to locate physical resources associated with this
locale. The locale name <b>UNIV</b> is reserved and refers to the definitions that provide default behavior for functions. </p>
<p>When the <b>LocaleSpec</b> argument is a NULL pointer (without regard to the value of the <b>LocaleSpecType</b> argument),
UniCreateLocaleObject creates a locale object for the <b>UNIV</b> locale. </p>
<p>When the <b>LocaleSpec</b> argument points to a locale token value as indicated by the value of the <b>LocaleSpecType</b> argument,
the token identifies the locale to be initialized. </p>
<p>When the <b>LocaleSpec</b> argument is an empty multibyte or UCS character string, UniCreateLocaleObject creates a locale
object based upon the settings of the locale environment variables. </p>
<p>&nbsp;
<div align="center"><table border><caption align="top"><B>Locale Environment Variables by Precedence and Usage</B></caption>
<tr>
<th><p><b>Catgeory</b></th>
<th><p><b>Precedence</b></th>
<th><p><b>Usage</b></th>
</tr><tr>
<td><p>LC_ALL</td>
<td><p>Highest</td>
<td><p>Setting LC_ALL takes precedence over any other locale environment variable.</td>
</tr><tr>
<td><p>LC_COLLATE</td>
<td><p>Equal precedence</td>
<td><p>Specifies collation (sorting) rules.</td>
</tr><tr>
<td><p>LC_CTYPE</td>
<td><p>Equal precedence</td>
<td><p>Specifies character classification and case conversion.</td>
</tr><tr>
<td><p>LC_MESSAGES</td>
<td><p>Equal precedence</td>
<td><p>Specifies the values for affirmative and negative answers, and the language for
displayed messages.</td>
</tr><tr>
<td><p>LC_MONETARY</td>
<td><p>Equal precedence</td>
<td><p>Specifies monetary formats and currency symbol.</td>
</tr><tr>
<td><p>LC_NUMERIC</td>
<td><p>Equal precedence</td>
<td><p>Specifies decimal formats.</td>
</tr><tr>
<td><p>LC_TIME</td>
<td><p>Equal precedence</td>
<td><p>Specifies date and time formats.</td>
</tr><tr>
<td><p>LANG</td>
<td><p>Lowest</td>
<td><p>Setting LANG takes precedence over any undefined locale environment variable.
This may be used in conjunction with LC_COLLATE, LC_CTYPE,
LC_MESSAGES, LC_MONETARY, LC_NUMERIC, and LC_TIME.</td>
</tr></table></div>
<p>If the specified locale is valid and supported, UniCreateLocaleObject allocates memory for the new object and returns the
address of the created locale object in the area pointed to by <b>locale_object</b>. It is the application's responsibility to free this
memory with a call to UniFreeLocaleObject when the object is no longer needed. If the function fails for any reason, the
contents of the area pointed to by <b>locale_object</b> are undefined. </p>
<p>The locale token provides a shorthand notation for specifying a locale. The format of the locale token is as returned by a call
to UniLocaleStrToToken. The format is defined as an unsigned integer of four octets. </p>
<p><strong>Examples of typical usage:</strong> </p>
<p>The locale environment variables are set as follows:<br>
<br>
LANG=de_DE<br>
LC_MONETARY=en_US<br>
<br>
The <b>LocaleSpec</b> argument is an empty multibyte or UCS character string. </p>
<pre>This example creates a locale object with all categories set to de_DE except for
LC_MONETARY which has the value of en_US.</pre>
<p>The locale environment variables are set as follows:<br>
<br>
LANG=fr_FR<br>
<br>
The <b>LocaleSpec</b> argument is an empty multibyte or UCS character string. </p>
<pre>This example creates a locale object with all categories set to fr_FR.</pre>
<p>The locale environment variables are set as follows:<br>
<br>
LC_ALL=it_IT<br>
LANG=fr_FR<br>
<br>
The <b>LocaleSpec</b> argument is an empty multibyte or UCS character string. </p>
<pre>This example creates a locale object with all categories set to it_IT.</pre>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50103" name="ToC_309">UniFreeLocaleObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create a locale object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_3" name="LENSM50100">UniCreateTransformObject</a></h2>
<p>UniCreateTransformObject creates a string transform object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniCreateTransformObject </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*xtype, XformObject&nbsp;*xform_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50461">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50462">&nbsp;</a>
<dd>&nbsp;
<dt>xtype &nbsp;(const UniChar *)&nbsp;
<dd>A UniChar string identifying the transform type. <a name="SPTSP50463">&nbsp;</a>
<dd>&nbsp;
<dt>xform_object &nbsp;(XformObject *)&nbsp;
<dd>An address that will receive a pointer to an Xform Object upon successful completion of UniCreateTransformObject.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniCreateTransformObject returns one of the following:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>No errors; the xform_object argument points to a valid transformation object.
<dt><b>ULS_UNSUPPORTED </b>
<dd>The transformation name type specified by the xtype argument is not supported for locale_object.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniCreateTransformObject obtains a transformation object for a transformation type as defined in the locale indicated by
the locale_object argument. The function returns a transformation object that can be used as an argument in
UniTransformStr. </p>
<p>The following transformation types are defined in all locales:
<dl>
<dt><b>lower </b>
<dd>Transform to lowercase characters. A character that does not have a lowercase form is returned as itself.
<dt><b>upper </b>
<dd>Transform to uppercase characters. A character that does not have an uppercase form is returned as itself.
<dt><b>compose </b>
<dd>Transform to fully composed form for combined characters.
<dt><b>decompose </b>
<dd>Transform to a string of decomposed characters where multiple characters
are used to represent base and diacritics.
<dt><b>hiragana </b>
<dd>Transform so that Japanese phonetic characters are in hiragana
<dt><b>katakana </b>
<dd>Transform so that Japanese phonetic characters are in full size katakana
<dt><b>kana </b>
<dd>Transform so that Japanese phonetic characters are in half size katakana

</dl>
<p>In addition to the above transformation-type names, other transformation-type names in the locale (including user-defined
transformation-type names) may be passed to UniCreateTransformObject through the xtype argument. To obtain a
successful return, the transformation-type name must be defined in locale_object. </p>
<p>When UniCreateTransformObject completes without errors, the xform_object argument value specifies a valid pointer to a
transformation object. The transformation object should be used in all subsequent calls to UniTransformStr. If the function
result is other than ULS_SUCCESS, the contents of the area pointed to by <b>xform_object</b> are undefined. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50105" name="ToC_309">UniFreeTransformObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and use a transform object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
XformObject  xform_object = NULL;
int          rc = ULS_SUCCESS;
int          in_unistr_elem = 0;
int          out_unistr_elem = 10;
UniChar      *pin_unistr = (UniChar *)L&quot;os2&quot;;
UniChar      out_unistr[10];
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an upper case transform object */
         rc = UniCreateTransformObject(locale_object,
                                      (UniChar *)L&quot;upper&quot;, &amp;xform_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateTransformObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Calculate the number of elements to transform */
         in_unistr_elem = UniStrlen (pin_unistr) + 1;
         /* Make call to transform input string to uppercase */
         rc = UniTransformStr(xform_object, pin_unistr,
                             &amp;in_unistr_elem, out_unistr,
                             &amp;out_unistr_elem);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniTransformStr error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_303" name="LENSM50303">UniDeleteUserLocale</a></h2>
<p>UniDeleteUserLocale is used to delete a locale created by a user. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniDeleteUserLocale </b>
<dd><b>(UniChar * locale)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale &nbsp;(UniChar *)&nbsp;
<dd>A pointer to a UniChar string which defines the name of the locale.
</dl>
<p><strong>Returns</strong> <a name="SPTSP60303">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniDeleteUserLocale returns on of the following:
<dl>
<dt><b>ULS_SUCCESS </b><a name="SPTSV61303">&nbsp;</a>
<dd>Successful completion; user locale deleted from disk.
<dt><b>ULS_NOMATCH </b><a name="SPTSV61303">&nbsp;</a>
<dd>The requested locale cannot be found.
<dt><b>ULS_INVALID </b><a name="SPTSV62303">&nbsp;</a>
<dd>The locale being deleted is not a user defined locale.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniCompleteDeleteLocale is used to remove a previously defined user locale. The locale must have been previously created
as a user locale. This is accomplished by using the UniCompleteUserLocale API. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50304" name="ToC_304">UniCompleteUserLocale</a>
<li><a href="#LENSM50302" name="ToC_302">UniMakeUserLocale</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to delete a user locale once it is no longer
needed by the user.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;

/* Array containing user locales */
UniChar      *uniUsrLocales;
UniChar      uniLocaleName[MAX_LOCALE_NAME_LENGTH];
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }

         .
         .
         .
         /*
             Identify the locale to be deleted - making sure the name is in
             Unicode.
         */
         .
         .
         .


         /* Delete a user locale from the disk */
         rc = UniDeleteUserLocale(uniLocaleName);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniDeleteUserLocale error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;
         </pre>
<p>} </p>
<h2><a href="#ToC_4" name="LENSM50101">UniFreeAttrObject</a></h2>
<p>UniFreeAttrObject frees the character attribute object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniFreeAttrObject </b>
<dd><b>(AttrObject&nbsp;attr_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50465">&nbsp;</a>
<dl>
<dt>attr_object &nbsp;(AttrObject)&nbsp;
<dd>An attribute object to be freed. The attribute object must have been created by a call to UniCreateAttrObject.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniFreeAttrObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>All resources associated with the attribute object specified by the attr_object argument have been successfully
deallocated.
<dt><b>ULS_BADOBJ </b>
<dd>The attribute object specified by attr_object is not a valid attribute object.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniFreeAttrObject releases all resources associated with the character attribute object allocated by UniCreateAttrObject. </p>
<p>The attr_object argument specifies a previously allocated attribute object. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and free a character attribute object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
AttrObject   attr_object = NULL;<br>
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an alphabetic attribute object */
         rc = UniCreateAttrObject(locale_object,
                                 (UniChar *)L&quot;alpha&quot;, &amp;attr_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateAttrObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Free the character attribute object */
         rc = UniFreeAttrObject(attr_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeAttrObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_5" name="LENSM50102">UniFreeLocaleInfo</a></h2>
<p>UniFreeLocaleInfo frees a locale information structure created by UniQueryLocaleInfo. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniFreeLocaleInfo </b>
<dd><b>(struct UniLconv&nbsp;*UniLconv_addr)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50467">&nbsp;</a>
<dl>
<dt>UniLconv_addr &nbsp;(struct UniLconv *)&nbsp;
<dd>A locale information structure created by a call to UniQueryLocaleInfo.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniFreeLocaleInfo returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The UniLconv structure and associated memory were successfully freed.
<dt><b>ULS_BADOBJ </b>
<dd>The UniLconv_addr is not a valid structure.
</dl>
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50123" name="ToC_309">UniQueryLocaleInfo</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and free a locale information structure.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject      locale_object = NULL;
struct UniLconv   *puni_lconv = NULL;<br>
int               rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Retrieve locale information */
         rc = UniQueryLocaleInfo(locale_object, &amp;puni_lconv);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleInfo error: return code = %u\n&quot;, rc);
           return 1;
         }
         printf(&quot;Monetary decimal point is %ls\n&quot;, puni_lconv-&gt;mon_decimal_point);
         /* Free the locale information structure */
         rc = UniFreeLocaleInfo(puni_lconv);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeLocaleInfo error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_6" name="LENSM50103">UniFreeLocaleObject</a></h2>
<p>UniFreeLocaleObject frees a locale object that was created by UniCreateLocaleObject. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniFreeLocaleObject </b>
<dd><b>(LocaleObject&nbsp;locale_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50469">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(LocaleObject)&nbsp;
<dd>The Locale Object to be freed. locale_object must have been created by a call to UniCreateLocaleObject.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLocaleObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>A valid locale specification for the supplied locale object is returned.
<dt><b>ULS_BADOBJ </b>
<dd>Invalid locale object specified.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>The UniFreeLocaleObject function destroys the locale object identified by locale_object and frees any memory associated
with it. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50125" name="ToC_309">UniQueryLocaleObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and free a locale object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject      locale_object = NULL;
int               rc = ULS_SUCCESS;
         /* Create a locale object for French in Canada */
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;fr_CA&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Free the locale object that was just created */
         rc = UniFreeLocaleObject(locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_7" name="LENSM50104">UniFreeMem</a></h2>
<p>UniFreeMem frees memory allocated by UniQueryLocaleObject. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniFreeMem </b>
<dd><b>(void&nbsp;*memory)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50471">&nbsp;</a>
<dl>
<dt>memory &nbsp;(void *)&nbsp; -&nbsp; in/out&nbsp;
<dd>A pointer to the memory to be freed.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Returns &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniFreeMem returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b><a name="SPTSV50176">&nbsp;</a>
<dd>Indicates success.
<dt><b>ULS_BADOBJ </b><a name="SPTSV50177">&nbsp;</a>
<dd>Invalid pointer in memory.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniFreeMem frees memory allocated by ULS functions. For example, the memory allocated for the locale_name parameter
of UniQueryLocaleObject should be freed using UniFreeMem. </p>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to free memory allocated by a ULS function.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject      locale_object = NULL;
int               rc = ULS_SUCCESS;
char              *locale_name;
         /* Create a locale object for French in Canada */
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;fr_CA&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Determine the locale name for the LC_MESSAGES category */
         rc = UniQueryLocaleObject(locale_object, LC_MESSAGES,
                                   UNI_MBS_STRING_POINTER,
                                   (void **)&amp;locale_name);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Free the memory allocated by UniQueryLocaleObject */
         rc = UniFreeMem((void **)locale_name);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeMemObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_8" name="LENSM50105">UniFreeTransformObject</a></h2>
<p>UniFreeTransformObject frees a string transformation object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniFreeTransformObject </b>
<dd><b>(XformObject&nbsp;xform_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50473">&nbsp;</a>
<dl>
<dt>xform_object &nbsp;(XformObject)&nbsp;
<dd>The transform object to be freed. The transform object must have been created by a call to
UniCreateTransformObject.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dt>&nbsp;
<dt>UniFreeTransformObject returns one of the following:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Specifies that all resources associated with the transformation object specified by the xform_object argument
have been successfully deallocated.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniFreeTransformObject releases all resources associated with a transformation object previously obtained by
UniCreateTransformObject. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50100" name="ToC_309">UniCreateTransformObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and free a transform object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
XformObject  xform_object = NULL;<br>
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an upper case transform object */
         rc = UniCreateTransformObject(locale_object,
                                      (UniChar *)L&quot;lower&quot;, &amp;xform_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateTransformObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Free the transform object created by UniCreateTransformObject */
         rc = UniFreeTransformObject(xform_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeTransformObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_10" name="LENSM50107">UniLocaleStrToToken</a></h2>
<p>UniLocaleStrToToken converts a locale specification string to a token. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniLocaleStrToToken </b>
<dd><b>(int&nbsp;LocaleStringType, const void&nbsp;*locale_string, LocaleToken&nbsp;*locale_token)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50481">&nbsp;</a>
<dl>
<dt>LocaleStringType &nbsp;(int)&nbsp;
<dd>Informs UniLocaleStrToToken of the type of string being passed in the locale_string variable.
<p>The LocaleStringType argument can take any of the following values, which are constants defined in the header
unidef.h:
<ul><dl>
<dt><b>UNI_MBS_STRING_POINTER </b>
<dd>Requests that a multibyte string pointer is held in locale_string.
<dt><b>UNI_UCS_STRING_POINTER </b>
<dd>Requests that a UCS string pointer is held in locale_string.
</dl>
</ul>
<p><a name="SPTSP50482">&nbsp;</a>
<dt>locale_string &nbsp;(const void *)&nbsp;
<dd>The locale specification string. <a name="SPTSP50483">&nbsp;</a>
<dd>&nbsp;
<dt>locale_token &nbsp;(LocaleToken *)&nbsp;
<dd>An address that will receive a pointer to the newly created token corresponding to locale_string.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniLocaleStrToToken returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>A valid locale token for the supplied locale object is returned.
<dt><b>ULS_OTHER </b>
<dd>The C locale is because LOCALE.DLL cound not be found.
<dt><b>ULS_UNSUPPORTED </b>
<dd>The locale name is valid but the locale cound not be found.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniLocaleStrToToken accepts, as an argument, a locale string qualified by the value of the <b>LocaleStringType</b> argument. It
returns a locale token pointed to by <b>locale_token</b> if such a token exists for that locale string. UniLocaleStrToToken
allocates memory to hold the locale token value. If no locale token exists for the supplied locale string, the value returned in
<b>locale_token</b> is undefined. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50108" name="ToC_309">UniLocaleTokenToStr</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a locale specification string to a token.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar       *locale_string = L&quot;de_DE&quot;;  /*German in Germany locale string */
LocaleToken   locale_token;<br>
int           rc = ULS_SUCCESS;
         rc = UniLocaleStrToToken(UNI_UCS_STRING_POINTER,
                                 (void *)locale_string,
                                 &amp;locale_token);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniLocaleStrToToken error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_11" name="LENSM50108">UniLocaleTokenToStr</a></h2>
<p>UniLocaleTokenToStr converts a locale token to a locale specification string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniLocaleTokenToStr </b>
<dd><b>(const LocaleToken&nbsp;locale_token, int&nbsp;LocaleStringType, void&nbsp;**locale_string)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50485">&nbsp;</a>
<dl>
<dt>locale_token &nbsp;(const LocaleToken)&nbsp;
<dd>A token identifying a locale. <a name="SPTSP50486">&nbsp;</a>
<dd>&nbsp;
<dt>LocaleStringType &nbsp;(int)&nbsp;
<dd>The LocaleStringType argument can take any of the following values, which are constants defined in the header
unidef.h:
<dl>
<dt><b>UNI_MBS_STRING_POINTER </b>
<dd>Requests that a multibyte string pointer be returned.
<dt><b>UNI_UCS_STRING_POINTER </b>
<dd>Requests that a UCS string pointer be returned.
</dl>
<p><a name="SPTSP50487">&nbsp;</a>
<dt>locale_string &nbsp;(void **)&nbsp;
<p>An address of a pointer variable locale_string that will contain the locale specification string corresponding to locale_token. </p>
</dl>
<p><strong>Returns</strong> <a name="SPTSP50488">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>The UniLocaleTokenToStr function returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>A valid locale specification for the supplied locale object is returned.
<dt><b>ULS_INVALID </b>
<dd>The locale token supplied could not be matched to a locale string.
<dt><b>ULS_NOMEMORY </b>
<dd>There is insufficient memory to store the locale string.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>The UniLocaleTokenToStr() function accepts as an argument a locale token in <b>locale_token</b> and returns a pointer to a
locale string in <b>locale_string</b> qualified by the LocaleStringType argument. The UniLocaleTokenToStr() function allocates
memory to hold the locale string value. It is the application's responsibility to free the memory using UniFreeMem() when the
locale string value is no longer needed. If no locale string can be generated for the supplied locale token, the value returned
in <b>locale_string</b> is undefined. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50107" name="ToC_309">UniLocaleStrToToken</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a locale token to a locale specification string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar       *locale_string1 = L&quot;de_DE&quot;;  /*German in Germany locale string */
UniChar       *locale_string2;<br>
LocaleToken   locale_token;<br>
int           rc = ULS_SUCCESS;
         rc = UniLocaleStrToToken(UNI_UCS_STRING_POINTER,
                                 (void *)locale_string1,
                                 &amp;locale_token);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniLocaleStrToToken error: return code = %u\n&quot;, rc);
           return 1;
         }</pre>
<p>/* Convert the token to a locale string */ </p>
<pre>         rc = UniLocaleTokenToStr(locale_token,
                                 UNI_UCS_STRING_POINTER,
                                 (void **)&amp;locale_string2);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniLocaleTokenToStr error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_302" name="LENSM50302">UniMakeUserLocale</a></h2>
<p>UniMakeUserLocale creates a user locale from a base system locale. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniMakeUserLocale </b>
<dd><b>(UniChar&nbsp;*&nbsp;newName, UniChar&nbsp;*&nbsp;baseName)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP60302">&nbsp;</a>
<dl>
<dt>newName (UniChar&nbsp;*&nbsp;)
<dd>The name of the new locale. <a name="SPTSP61302">&nbsp;</a>
<dd>&nbsp;
<dt>baseName (UniChar&nbsp;*&nbsp;)
<dd>The name of the locale to base the new locale after.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniMakeUserLocale returns one of the following values:
<dl>
<dd><b>ULS_SUCCESS </b>
<dd>The user locale has been created.
<dd><b>ULS_NOMATCH </b>
<dd>The base system locale does not exist.
<dd><b>ULS_INVALID </b>
<dd>The name supplied contains an illegal character, is too long or redefines a base system locale.
<dd><b>ULS_NOOP </b>
<dd>The name supplied currently exists as a locale name.
<dd><b>ULS_NOMEMORY </b>
<dd>Cannot allocate memory for the new locale.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>The names for the new locale and the base system locale must be ASCII-7 chars and at most eight characters, in length. An
existing locale name must be given as the base locale name. </p>
<p>If the user locale already exists, a ULS_NOOP return code will be given, therefore, this API can always be called before
making an update to ensure that the user locale exists. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50304" name="ToC_304">UniCompleteUserLocale</a>
<li><a href="#LENSM50303" name="ToC_303">UniDeleteUserLocale</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to make a user locale.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject   locale_object = NULL;<br>
int            rc = ULS_SUCCESS;
UniChar        *plocaleName;
UniChar        *puniSysLocale;
    /* Create current default locale object for this process */
    rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                         (UniChar *)L&quot;&quot;,
                         &amp;locale_object);
    if(rc) {
      printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
      return 1;
    }
    /* Query the name of the default locale object */
    rc = UniQueryLocaleObject(locale_object,
                         LC_ALL,
                         UNI_UCS_STRING_POINTER,
                         (void**)&amp;plocaleName);
    if(rc) {
      printf(&quot;UniQueryLocaleObject error: return code = %u\n&quot;, rc);
      return 1;
    }
    /* Get the locale name from the locale object string */
    puniSysLocale = UniStrtok(plocaleName, (UniChar *)L&quot; &quot;);
    /* Make a new locale */
    rc = UniMakeUserLocale(puniSysLocale, puniSysLocale);
    if (rc) {
      printf(&quot;UniMakeUserLocale error: return code = %u\n&quot;, rc);
      return 1;
    }
    /* free the space used by the locale object string */
    UniFreeMem(plocaleName);
    if(locale_object)
        UniFreeLocaleObject(locale_object);
    return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_70" name="LENSM50180">UniMapCtryToLocale</a></h2>
<p>UniMapCtryToLocale converts an unsigned long country code into a locale name represented as a UniChar string that is
acceptable as input to other Unicode APIs. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniMapCtryToLocale </b>
<dd><b>(unsigned long&nbsp;ulCountryCode, UniChar&nbsp;*ucsLocaleName, size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50688">&nbsp;</a>
<dl>
<dt>ulCountryCode &nbsp;(unsigned long)&nbsp; -&nbsp; input&nbsp;
<dd>An OS/2 country code. <a name="SPTSP50689">&nbsp;</a>
<dd>&nbsp;
<dt>ucsLocaleName &nbsp;(UniChar *)&nbsp; -&nbsp; output&nbsp;
<dd>A buffer for placing the Unicode string. <a name="SPTSP50690">&nbsp;</a>
<dd>&nbsp;
<dt>n &nbsp;(size_t)&nbsp; -&nbsp; input&nbsp;
<dd>Size, in characters, of the ucsLocaleName buffer. This should be at least 8 Unicode characters.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>Error code.
<p>UniMapCtryToLocale returns one of the following values:
<dl>
<dd><b>ULS_SUCCESS </b>
<dd>A valid locale name for the supplied country code is returned.
<dd><b>ULS_BUFFERFULL </b>
<dd>The buffer is not large enough to hold the locale name.
<dd><b>ULS_INVALID </b>
<dd>An invalid country code or buffer was specified.
</dl>
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50179" name="ToC_179">UniMapCpToUcsCp</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to map a country code to a locale name.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar        ucs_locale_name[8];
size_t         num_elems = 8;</pre>
<p>unsigned long country_num = 1;<br>
LocaleObject locale_object = NULL;<br>
int rc = ULS_SUCCESS; </p>
<pre>         /*****************************************************************/
         /* Convert country number to a locale name                       */
         /*****************************************************************/
         rc = UniMapCtryToLocale(country_num, ucs_locale_name, num_elems);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniMapCtryToLocale error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   ucs_locale_name, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_12" name="LENSM50109">UniQueryAlnum</a></h2>
<p>UniQueryAlnum queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryAlnum </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50489">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL.<a name="SPTSP50490">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'a';    /* Unicode lowercase Latin letter a */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryAlnum(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is alphanumeric\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not alphanumeric\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_13" name="LENSM50111">UniQueryAlpha</a></h2>
<p>UniQueryAlpha queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryAlpha </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50491">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50492">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'a';    /* Unicode lowercase Latin letter a */
         /* Query character attribute */
         result = UniQueryAlpha(NULL, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is alphabetic\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not alphabetic\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_309" name="LENSM50309">UniQueryAttr</a></h2>
<p>UniQueryAttr returns the value associated with attribute name supplied by the user. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>ulong UniQueryAttr </b>
<dd><b>(UniChar * attrName)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50491">&nbsp;</a>
<dl>
<dt>attrName &nbsp;(UniChar &nbsp;*)&nbsp;
<dd>The name of a character attribute.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Return Value &nbsp;(ulong)&nbsp; -&nbsp; returns&nbsp;
<dd>If the attribute name is known, the function returns the attribute value. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the numeric value for the standard attributes such as alpha, graph, and number. In addition, this
function provides the numeric value for other attributes such as Hiragana, diacritic, halfwidth etc. The table below contains
the valid attribute names. Valid names are all in lower case. </p>
<p>Attribute names that begin with a lower case letter may be ORed together. </p>
<p align="left"><b>Attribute Name and Description Table </b>
<table border cellpadding="7" cellspacing="3" bordercolor="#000000">
<tr>
<td width="110" valign="top"><strong>Attr Name</strong></td>
<td width="220" valign="top"><strong>Attribute Define</strong></td>
<td width="338" valign="top"><strong>Description of Attribute</strong></td>
</tr><tr>
<td width="110" valign="top">alnum</td>
<td width="220" valign="top">CT_ALNUM</td>
<td width="338" valign="top">Alphabetic and numeric characters</td>
</tr><tr>
<td width="110" valign="top">alpha</td>
<td width="220" valign="top">CT_ALPHA</td>
<td width="338" valign="top">Letters and linguistic marks</td>
</tr><tr>
<td width="110" valign="top">ascii</td>
<td width="220" valign="top">CT_ASCII</td>
<td width="338" valign="top">Standard ASCII character</td>
</tr><tr>
<td width="110" valign="top">blank</td>
<td width="220" valign="top">CT_BLANK</td>
<td width="338" valign="top">Space and Tab</td>
</tr><tr>
<td width="110" valign="top">cntrl</td>
<td width="220" valign="top">CT_CNTRL</td>
<td width="338" valign="top">Control and format characters</td>
</tr><tr>
<td width="110" valign="top">diacritic</td>
<td width="220" valign="top">C3_DIACRITIC</td>
<td width="338" valign="top">Diacritic</td>
</tr><tr>
<td width="110" valign="top">digit</td>
<td width="220" valign="top">CT_DIGIT</td>
<td width="338" valign="top">Digits 0 through 9</td>
</tr><tr>
<td width="110" valign="top">fullwidth</td>
<td width="220" valign="top">C3_FULLWIDTH</td>
<td width="338" valign="top">Full width variant</td>
</tr><tr>
<td width="110" valign="top">graph</td>
<td width="220" valign="top">CT_GRAPH</td>
<td width="338" valign="top">All except controls and space</td>
</tr><tr>
<td width="110" valign="top">halfwidth</td>
<td width="220" valign="top">C3_HALFWIDTH</td>
<td width="338" valign="top">Half width variant</td>
</tr><tr>
<td width="110" valign="top">hiragana</td>
<td width="220" valign="top">C3_HIRAGANA</td>
<td width="338" valign="top">Hiragana character</td>
</tr><tr>
<td width="110" valign="top">ideograph</td>
<td width="220" valign="top">C3_IDEOGRAPH</td>
<td width="338" valign="top">Kanji/Han character</td>
</tr><tr>
<td width="110" valign="top">kashida</td>
<td width="220" valign="top">C3_KASHIDA</td>
<td width="338" valign="top">Arabic tatweel (used to stretch characters)</td>
</tr><tr>
<td width="110" valign="top">katakana</td>
<td width="220" height="18" valign="top">C3_KATAKANA</td>
<td width="338" height="18" valign="top">Katakana character</td>
</tr><tr>
<td width="110" valign="top">lower</td>
<td width="220" valign="top">CT_LOWER</td>
<td width="338" valign="top">Lower case alphabetic character</td>
</tr><tr>
<td width="110" valign="top">nonspacing</td>
<td width="220" valign="top">C3_NONSPACING</td>
<td width="338" valign="top">Non-spacing mark</td>
</tr><tr>
<td width="110" valign="top">nsdiacritic</td>
<td width="220" valign="top">C3_NSDIACRITIC</td>
<td width="338" valign="top">Non-spacing diacritic</td>
</tr><tr>
<td width="110" valign="top">nsvowel</td>
<td width="220" valign="top">C3_NSVOWEL</td>
<td width="338" valign="top">Non-spacing vowel</td>
</tr><tr>
<td width="110" valign="top">number</td>
<td width="220" valign="top">CT_NUMBER</td>
<td width="338" valign="top">Integers between 0 and 9</td>
</tr><tr>
<td width="110" valign="top">print</td>
<td width="220" valign="top">CT_PRINT</td>
<td width="338" valign="top">Everything except control characters</td>
</tr><tr>
<td width="110" valign="top">punct</td>
<td width="220" valign="top">CT_PUNCT</td>
<td width="338" valign="top">Punctuation marks</td>
</tr><tr>
<td width="110" valign="top">space</td>
<td width="220" valign="top">CT_SPACE</td>
<td width="338" valign="top">Whitespace and line ends</td>
</tr><tr>
<td width="110" valign="top">symbol</td>
<td width="220" valign="top">CT_SYMBOL</td>
<td width="338" valign="top">Symbol </td>
</tr><tr>
<td width="110" valign="top">upper</td>
<td width="220" valign="top">CT_UPPER</td>
<td width="338" valign="top">Upper case alphabetic character</td>
</tr><tr>
<td width="110" valign="top">vowelmark</td>
<td width="220" valign="top">C3_VOWELMARK</td>
<td width="338" valign="top">Vowel mark</td>
</tr><tr>
<td width="110" valign="top">xdigit</td>
<td width="220" valign="top">CT_XDIGIT</td>
<td width="338" valign="top">Hexadecimal digits (0-9, a-f or A-F)</td>
</tr><tr>
<td width="110" valign="top">_apl</td>
<td width="220" valign="top">CHS_APL</td>
<td width="338" valign="top">APL character</td>
</tr><tr>
<td width="110" valign="top">_arabic</td>
<td width="220" valign="top">CHS_ARABIC</td>
<td width="338" valign="top">Arabic character</td>
</tr><tr>
<td width="110" valign="top">_arrow</td>
<td width="220" valign="top">CHS_ARROW</td>
<td width="338" valign="top">Arrow character</td>
</tr><tr>
<td width="110" valign="top">_bengali</td>
<td width="220" valign="top">CHS_BENGALI</td>
<td width="338" valign="top">Bengali character</td>
</tr><tr>
<td width="110" valign="top">_bopomofo</td>
<td width="220" valign="top">CHS_BOPOMOFO</td>
<td width="338" valign="top">Bopomofo character</td>
</tr><tr>
<td width="110" valign="top">_box</td>
<td width="220" valign="top">CHS_BOX</td>
<td width="338" valign="top">Box or line drawing character</td>
</tr><tr>
<td width="110" valign="top">_currency</td>
<td width="220" valign="top">CHS_CURRENCY</td>
<td width="338" valign="top">Currency Symbol</td>
</tr><tr>
<td width="110" valign="top">_cyrillic</td>
<td width="220" valign="top">CHS_CYRILLIC</td>
<td width="338" valign="top">Cyrillic character</td>
</tr><tr>
<td width="110" valign="top">_dash</td>
<td width="220" valign="top">CHS_DASH</td>
<td width="338" valign="top">Dash character</td>
</tr><tr>
<td width="110" valign="top">_dingbat</td>
<td width="220" valign="top">CHS_DINGBAT</td>
<td width="338" valign="top">Dingbat</td>
</tr><tr>
<td width="110" valign="top">_fraction</td>
<td width="220" valign="top">CHS_FRACTION</td>
<td width="338" valign="top">Fraction value</td>
</tr><tr>
<td width="110" valign="top">_greek</td>
<td width="220" valign="top">CHS_GREEK</td>
<td width="338" valign="top">Greek character</td>
</tr><tr>
<td width="110" valign="top">_gujarati</td>
<td width="220" valign="top">CHS_GUJARATI</td>
<td width="338" valign="top">Gujarati character</td>
</tr><tr>
<td width="110" valign="top">_gurmukhi</td>
<td width="220" valign="top">CHS_GURMUKHI</td>
<td width="338" valign="top">Gurmukhi character</td>
</tr><tr>
<td width="110" valign="top">_hanguel</td>
<td width="220" valign="top">CHS_HANGUEL</td>
<td width="338" valign="top">Hanguel character</td>
</tr><tr>
<td width="110" valign="top">_hebrew</td>
<td width="220" valign="top">CHS_HEBREW</td>
<td width="338" valign="top">Hebrew character</td>
</tr><tr>
<td width="110" valign="top">_hiragana</td>
<td width="220" valign="top">CHS_HIRAGANA</td>
<td width="338" valign="top">Hiragana character set</td>
</tr><tr>
<td width="110" valign="top">_katakana</td>
<td width="220" height="18" valign="top">CHS_KATAKANA</td>
<td width="338" height="18" valign="top">Katakana character set</td>
</tr><tr>
<td width="110" valign="top">_lao</td>
<td width="220" valign="top">CHS_LAO</td>
<td width="338" valign="top">Laotian character</td>
</tr><tr>
<td width="110" valign="top">_latin</td>
<td width="220" valign="top">CHS_LATIN</td>
<td width="338" valign="top">Latin character</td>
</tr><tr>
<td width="110" valign="top">_linesep</td>
<td width="220" valign="top">CHS_LINESEP</td>
<td width="338" valign="top">Line separator</td>
</tr><tr>
<td width="110" valign="top">_math</td>
<td width="220" valign="top">CHS_MATH</td>
<td width="338" valign="top">Math symbol</td>
</tr><tr>
<td width="110" valign="top">_punctstart</td>
<td width="220" valign="top">CHS_PUNCTSTART</td>
<td width="338" valign="top">Punctuation start</td>
</tr><tr>
<td width="110" valign="top">_punctend</td>
<td width="220" valign="top">CHS_PUNCTEND</td>
<td width="338" valign="top">Punctuation end</td>
</tr><tr>
<td width="110" valign="top">_tamil</td>
<td width="220" valign="top">CHS_TAMIL</td>
<td width="338" valign="top">Tamil character</td>
</tr><tr>
<td width="110" valign="top">_telegu</td>
<td width="220" valign="top">CHS_TELEGU</td>
<td width="338" valign="top">Telegu character</td>
</tr><tr>
<td width="110" valign="top">_thai</td>
<td width="220" valign="top">CHS_THAI</td>
<td width="338" valign="top">Thai character</td>
</tr><tr>
<td width="110" valign="top">_userdef</td>
<td width="220" valign="top">CHS_USERDEF</td>
<td width="338" valign="top">User defined character</td>
</tr><tr>
<td width="110" valign="top">#arabicnum</td>
<td width="220" valign="top">C2_ARABICNUMBER</td>
<td width="338" valign="top">Arabic numbers</td>
</tr><tr>
<td width="110" valign="top">#blocksep</td>
<td width="220" valign="top">C2_BLOCKSEPARATOR</td>
<td width="338" valign="top">Block separator</td>
</tr><tr>
<td width="110" valign="top">#commonsep</td>
<td width="220" valign="top">C2_COMMONSEPARATOR</td>
<td width="338" valign="top">Common separator</td>
</tr><tr>
<td width="110" valign="top">#euronum</td>
<td width="220" valign="top">C2_EUROPENUMBER</td>
<td width="338" valign="top">European number</td>
</tr><tr>
<td width="110" valign="top">#eurosep</td>
<td width="220" valign="top">C2_EUROPESEPARATOR</td>
<td width="338" valign="top">European separator</td>
</tr><tr>
<td width="110" valign="top">#euroterm</td>
<td width="220" valign="top">C2_EUROPETERMINATOR</td>
<td width="338" valign="top">European terminator</td>
</tr><tr>
<td width="110" valign="top">#left</td>
<td width="220" valign="top">C2_LEFTTORIGHT</td>
<td width="338" valign="top">Left to right text orientation</td>
</tr><tr>
<td width="110" valign="top">#mirrored</td>
<td width="220" valign="top">C2_MIRRORED</td>
<td width="338" valign="top">Symmetrical text orientation</td>
</tr><tr>
<td width="110" valign="top">#neutral</td>
<td width="220" valign="top">C2_OTHERNEUTRAL</td>
<td width="338" valign="top">Other neutral</td>
</tr><tr>
<td width="110" valign="top">#right</td>
<td width="220" valign="top">CT_RIGHTTOLEFT</td>
<td width="338" valign="top">Right to left text orientation</td>
</tr><tr>
<td width="110" valign="top">#whitespace</td>
<td width="220" valign="top">C2_WHITESPACE</td>
<td width="338" valign="top">Whitespace</td>
</tr></table>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attribute values using the
character attributes.
#include &lt;stdio.h&gt;
#include &lt;unidef.h&gt;
int main(void) {
    char    name[33];
    UniChar uname[33];
    UniChar * up;
    char    * cp;
    ulong   rc;
    /*
     * Ask the user for an attribute name
     */
    printf(&quot;Enter attribute name:&quot;);
    scanf(&quot;%s&quot;, &amp;name);
    if (strlen(name) &gt; 32)
      return 1;
    /*
     * Convert name to unicode
     */
    cp = name;
    up = uname;
    while (*cp) {
      *up++ = (UniChar)(*cp++);
    }
    *up = 0;
    /*
     * Query the attribute and print the value
     */

    rc = UniQueryAttr(tolower(uname));
    if (rc == 0) {
       printf(&quot;UniQueryAttr error: return code = %u\n&quot;, rc);
       return 1;
    } else
       printf(&quot;%s attribute = %x\n&quot;, name, rc);
       return ULS_SUCCESS;
} </pre>
<p><hr> </p>
<h2><a href="#ToC_14" name="LENSM50113">UniQueryBlank</a></h2>
<p>UniQueryBlank queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryBlank </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50493">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50494">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L' ';    /* Unicode space character */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryBlank(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a blank character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a blank character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_308" name="LENSM50308">UniQueryChar</a></h2>
<p>UniQueryChar determines if the character supplied has the attribute(s) requested. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryChar </b>
<dd><b>(UniChar uc, ULONG attrName)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50491">&nbsp;</a>
<dl>
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The Unicode character whose attribute(s) are being examined.
<dd>&nbsp;
<dt>attrName &nbsp;(ULONG)&nbsp;
<dd>The name of the attribute being examined in the Unicode character.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Return Value &nbsp;(ulong)&nbsp; -&nbsp; returns&nbsp;
<dd>If the named attribute is true for the Unicode character supplied, the function returns a 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function takes the attributes supplied by the caller and tests the character to determine if they are true for that Unicode
character. Attribute names that have a leading _ or # character represent classes of characters. These attributes must be
tested as individual attributes. The remaining attributes can be or'ed together before testing. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query if a character has particular attributes.
#include &lt;stdio.h&gt;
#include &lt;unidef.h&gt;
int main(void) {
         int          result = 0;
         UniChar      uni_char = L'A';    /* Unicode A character */

         /* Query character for upper case and graphic attributes */
         result = UniQueryChar(uni_char, C1_UPPER || C1_GRAPH);
         if (result)
           printf(&quot;UniChar is upper case and a graphic character\n&quot;);
         else
           printf(&quot;UniChar is not upper case and a graphic character\n&quot;_;
         /* Query character for Latin character set attribute */
         result = UniQueryChar(uni_char, CHS_LATIN);
         if (result)
           printf(&quot;UniChar is a Latin character\n&quot;);
         else
           printf(&quot;UniChar is not a Latin character\n&quot;);

         return ULS_SUCCESS;
}</pre>
<h2><a href="#ToC_15" name="LENSM50115">UniQueryCharAttr</a></h2>
<p>UniQueryCharAttr queries the attributes of a character. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryCharAttr </b>
<dd><b>(AttrObject&nbsp;attr_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>attr_object &nbsp;(AttrObject)&nbsp;
<dd>An attribute object created by UniCreateAttrObject. <a name="SPTSP50496">&nbsp;</a>
<dt>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character whose attributes will be queried.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true (the code element has the attribute associated with the attribute object, attr_object),
UniQueryCharAttr returns the value 1.
<p>If the result of the test is false, UniQueryCharAttr returns the value 0. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryCharAttr determines whether the code element uc has the attributes specified by the attribute object argument,
attr_object. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and use a character attribute object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
AttrObject   attr_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'c';    /* Unicode lowercase Latin letter c */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an attribute object */
         rc = UniCreateAttrObject(locale_object,
                                 (UniChar *)L&quot;alpha xdigit&quot;, &amp;attr_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateAttrObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Make call to determine if character matches attributes */
         result = UniQueryCharAttr(attr_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X matches attributes\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X does not match attributes\n&quot;, uni_char);
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_311" name="LENSM50311">UniQueryCharType</a></h2>
<p>UniQueryCharType is used to query the type of the character.</p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UNICTYPE * UniQueryCharType </b>
<dd><b>( UniChar&nbsp;uc )</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character whose type will be queried.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UNICTYPE *)&nbsp; -&nbsp; returns&nbsp;
<dd>A pointer to a structure of type UNICTYPE Iis returned from this call.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryCharType is designed to provide information to support both the XPG/4 character type as well as the Win32
GetCharType type. &nbsp;Where the function is similar, this API is designed to be a superset of the Win32 function so that the
Win32 functions can be supported by masking off bits in the returned data structure. &nbsp;GetCharType is similar to the C
library &quot;is&quot; functions.&nbsp;</p>
<p>The UNICTYPE structure contains character set information, information regarding Bidirectional attributes, information
regarding XPG/4 attributes and information on extended attributes.&nbsp;</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_311">UniQueryCharAttr</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong><hr></p>
<pre>This example shows how to query a character type.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UNICTYPE &nbsp;&nbsp;&nbsp;&nbsp;* uct;
UniChar      uni_char = 0x3456;    /* Some random Unicode character */
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Query the character type */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uct = UniQueryCharType(uni_char);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Examine the returned structure to determine information about
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the character. &nbsp;For example, what is its BiDi orientation and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is the character Arabic or Hebrew? */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (uct-&gt;bidi==C2_RIGHTTOLEFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Character is presented right to left\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Character is presented left to right\n&quot;);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (uct-&gt;charset==CHS_ARABIC)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Character is Arabic\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (uct-&gt;charset==CHS_HEBREW)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Character is Hebrew\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Character is not Arabic or Hebrew\n&quot;);

return ULS_SUCCESS;
}</pre>
<p><hr> </p>
<h2><a href="#ToC_312" name="LENSM50312">UniQueryCharTypeTable</a></h2>
<p>UniQueryCharTypeTable is used to query the type of the character.</p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>ULONG UniQueryCharTypeTable </b>
<dd><b>( ULONG * count, UNICTYPE * * unictype )</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>count &nbsp;(ULONG &nbsp;*)&nbsp;
<dd>count is set to the length of the table being accessed.
<dd>&nbsp;
<dt>unictype &nbsp;(UNICTYPE &nbsp;* &nbsp;*)
<dd>unictype is set to point to a table of UNICTYPE structures.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(ULONG)&nbsp; -&nbsp; returns&nbsp;
<dd>A ULONG equal to zero is always returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryCharTypeTable is passed a pointer to a count and a pointer to a table of UNICTYPE structures. &nbsp;count is set to
the number of entries in the UNICTYPE structure table. &nbsp;unictype is set to the first structure in the table.</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_311">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_312">UniQueryCharType</a>
</ul>
<p><strong>Example</strong><hr></p>
<pre>This example shows how to query a character type table.
#include &lt;unidef.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* StringBidi: Determine bidi types for each character in a string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Return string of bidi bits, and return value with
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* OR of all bits.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;USHORT StringBidi(UniChar * instr, USHORT * charsets) {
&nbsp;&nbsp;&nbsp;&nbsp;ULONG count;
&nbsp;&nbsp;&nbsp;&nbsp;UNICTYPE * typetab;
&nbsp;&nbsp;&nbsp;&nbsp;USHORT index, *pcs, out;
&nbsp;&nbsp;&nbsp;&nbsp;int rc, i, len;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Get addressability to the character type table
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UniQueryCharTypeTable (&amp;count, &amp;typetab);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Create an output string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;len = UniStrlen(instr);
&nbsp;&nbsp;&nbsp;&nbsp;UniQueryStringType(instr, len, charsets, CT_INDEX);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Replace each index with bidi flags
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;pcs = charsets;
&nbsp;&nbsp;&nbsp;&nbsp;out = 0;
&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;len; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = *pcs;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pcs = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typetab[index].bidi == C2_RIGHTTOLEFT)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pcs |= 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typetab[index].charset == CHS_ARABIC)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pcs |= 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typetab[index].charset == CHS_HEBREW)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pcs |= 4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out |= *pcs++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return out;
}</pre>
<p><hr> </p>
<h2><a href="#ToC_16" name="LENSM50116">UniQueryCntrl</a></h2>
<p>UniQueryCntrl queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryCntrl </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50498">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50499">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_308">UniQueryCharType </a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Related Functions</strong> </p>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = 0x000A;    /* Unicode newline character */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryCntrl(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a control character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a control character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_307" name="LENSM50307">UniQueryCountryName</a></h2>
<p>UniQueryCountryName returns the name of the country in the language specified. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryCountryName </b>
<dd><b>(UniChar * country, UniChar * isolang, UniChar * * infoitem)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>country &nbsp;(UniChar *)&nbsp;
<dd>The two character ID of the country to query. <a name="SPTSP50501">&nbsp;</a>
<dd>&nbsp;
<dt>isolang &nbsp;(UniChar &nbsp;*)&nbsp;
<dd>The two character ID of the language used to return the country name.
<dd>&nbsp;
<dt>infoitem &nbsp;(UniChar &nbsp;* &nbsp;*)
<dd>A pointer to the country name.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50119">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryCountryName returns one of the following values:
<dl>
<dt><b>ULS_INVALID </b>
<dd>The country ID supplied is not known.
<dd>&nbsp;
</dl>
<dd>0 is returned upon success and the country name has been returned to the caller.
</dl>
<p><strong>Remarks</strong> </p>
<ul><p>This function only queries system provided locales to determine valid country names. &nbsp;</p>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50306" name="ToC_309">UniQueryLanguageName</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>&nbsp;
This example shows how to query a country name.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
#include &lt;ulsitem.h&gt;
&nbsp;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pinfo;
UniChar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*langName;
UniChar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*countryName;
UniChar     &nbsp;*mriLanguage;
UniChar      uni_char = L'5';    /* Unicode number 5 character */
&nbsp;
   &nbsp;/*****************************************************************/
    /* Assumes LANG environment variable set to a valid locale name, */
    /* such as fr_FR                                                 */
    /*****************************************************************/
    rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
    if (rc != ULS_SUCCESS) {
       printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
       return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Determine the language to get the country name in */
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleItem(locale_object, LOCI_sLanguageID,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mriLanguage);

    if (rc != ULS_SUCCESS) {
       &nbsp;printf(&quot;UniQueryLocaleItem error: return code = %u\n&quot;, rc);
       &nbsp;return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Get the ISO country ID&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleItem(locale_object, LOCI_sCountryID, &amp;pinfo);

    if (rc != ULS_SUCCESS) {
       printf(&quot;UniQueryLocaleItem error: return code = %u\n&quot;, rc);
       return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Now we can determine the country name in the proper language */
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryCountryName(pinfo, mriLanguage, &amp;countryName);

    if (rc != ULS_SUCCESS) {
&nbsp;      printf(&quot;UniQueryCountryName error: return code = %u\n&quot;, rc);
       return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;printf(&quot;Country name is = %ls\n&quot;, countryName);</pre>
<p>return ULS_SUCCESS;<br>
}</p>
<p><hr></p>
<h2><a href="#ToC_17" name="LENSM50118">UniQueryDigit</a></h2>
<p>UniQueryDigit queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryDigit </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50501">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
<dd>&nbsp;
</dl>
<p><strong>Returns</strong> <a name="SPTSM50119">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<ul><p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an
atomic operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'5';    /* Unicode number 5 character */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryDigit(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a digit\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a digit\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_18" name="LENSM50120">UniQueryGraph</a></h2>
<p>UniQueryGraph queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryGraph </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50503">&nbsp;</a>
<dt>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50121">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'S';    /* Unicode Latin uppercase letter S */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryGraph(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a graphic character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a graphic character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_306" name="LENSM50306">UniQueryLanguageName</a></h2>
<p>UniQueryLanguageName returns the name of the language in the language specified. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryLanguageName </b>
<dd><b>(UniChar * language, UniChar * isolang, UniChar * * infoitem)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>language &nbsp;(UniChar *)&nbsp;
<dd>The two character ID &nbsp;of the language to query. <a name="SPTSP50501">&nbsp;</a>
<dd>&nbsp;
<dt>isolang &nbsp;(UniChar &nbsp;*)&nbsp;
<dd>The two character ID of the language used to return the language name.
<dd>&nbsp;
<dt>infoitem &nbsp;(UniChar &nbsp;* &nbsp;*)
<dd>A pointer to the language name.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50119">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLanguageName returns one of the following values:
<dl>
<dt><b>ULS_INVALID </b>
<dd>The language ID supplied is not known.
<dd>&nbsp;
</dl>
<dd>0 is returned upon success and the language name has been returned to the caller.
</dl>
<p><strong>Remarks</strong> </p>
<ul><p>This function only queries system provided locales to determine valid language names. &nbsp;</p>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50307" name="ToC_309">UniQueryCountryName</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>&nbsp;
This example shows how to query a language name.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
#include &lt;ulsitem.h&gt;
&nbsp;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pinfo;
UniChar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*languageName;
UniChar     &nbsp;*mriLanguage;
UniChar      uni_char = L'5';    /* Unicode number 5 character */
&nbsp;
   &nbsp;/*****************************************************************/
    /* Assumes LANG environment variable set to a valid locale name, */
    /* such as fr_FR                                                 */
    /*****************************************************************/
    rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
    if (rc != ULS_SUCCESS) {
       printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
       return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Determine the language to get the language name in */
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleItem(locale_object, LOCI_sLanguageID,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mriLanguage);

    if (rc != ULS_SUCCESS) {
       &nbsp;printf(&quot;UniQueryLocaleItem error: return code = %u\n&quot;, rc);
       &nbsp;return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Get the ISO country ID&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleItem(locale_object, LOCI_sLanguageID, &amp;pinfo);

    if (rc != ULS_SUCCESS) {
       printf(&quot;UniQueryLocaleItem error: return code = %u\n&quot;, rc);
       return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Now we can determine the country name in the proper language */
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryCountryName(pinfo, mriLanguage, &amp;languageName);

    if (rc != ULS_SUCCESS) {
&nbsp;      printf(&quot;UniQueryCountryName error: return code = %u\n&quot;, rc);
       return 1;
    }
&nbsp;
&nbsp;&nbsp;&nbsp;printf(&quot;Language name is = %ls\n&quot;, languageName);</pre>
<p>return ULS_SUCCESS;<br>
}</p>
<h2><a href="#ToC_20" name="LENSM50123">UniQueryLocaleInfo</a></h2>
<p>UniQueryLocaleInfo retrieves information about locale conventions. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryLocaleInfo </b>
<dd><b>(const LocaleObject&nbsp;locale_object, struct UniLconv&nbsp;**UniLconv_addr_ptr)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50507">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject.
<dd><a name="SPTSP50508">&nbsp;</a>
<dt>UniLconv_addr_ptr &nbsp;(struct UniLconv **)&nbsp;
<dd>The address of a pointer to receive a structure filled with locale conventions.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50509">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLocaleInfo returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The UniLconv structure was successfully filled with items associated with the locale object locale_object.
<dt><b>ULS_BADOBJ </b>
<dd>The locale object specified by locale_object is not a valid locale object.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryLocaleInfo retrieves information from the locale indicated by the locale_object argument and places the
information in a UniLconv structure. UniQueryLocaleInfo allocates memory to hold the UniLconv structure. It is the
application's responsibility to free the memory with UniFreeLocaleInfo when the UniLconv structure is no longer needed.
The address of the UniLconv structure is returned in UniLconv_struct. The UniLconv structure is filled in, according to the
locale indicated by the locale object handle argument. </p>
<p>The UniLconv structure contains the following members:
<ul><dl>
<dt><b>UniChar *decimal_point; </b>
<dd>/* non-monetary decimal point */
<dt><b>UniChar *thousands_sep; </b>
<dd>/* non-monetary thousands separator */
<dt><b>UniChar *grouping; </b>
<dd>/* non-monetary size of grouping */
<dt><b>UniChar *int_curr_symbol; </b>
<dd>/* international currency symbol and separator */
<dt><b>UniChar *currency_symbol; </b>
<dd>/* local currency symbol */
<dt><b>UniChar *mon_decimal_point; </b>
<dd>/* monetary decimal point */
<dt><b>UniChar *mon_thousands_sep; </b>
<dd>/* monetary thousands separator */
<dt><b>UniChar *mon_grouping; </b>
<dd>/* monetary size of grouping */
<dt><b>UniChar *positive_sign; </b>
<dd>/* non-negative values sign */
<dt><b>UniChar *negative_sign; </b>
<dd>/* negative values sign */
<dt><b>UniChar int_frac_digits; </b>
<dd>/* number of fractional digits - int currency */
<dt><b>UniChar frac_digits; </b>
<dd>/* number of fractional digits - local currency */
<dt><b>UniChar p_cs_precedes; </b>
<dd>/* (non-neg curr sym) 1-precedes, 0-succeeds */
<dt><b>UniChar p_sep_by_space; </b>
<dd>/* (non-neg curr sym) 1-space, 0-no space */
<dt><b>UniChar n_cs_precedes; </b>
<dd>/* (neg curr sym) 1-precedes, 0-succeeds */
<dt><b>UniChar n_sep_by_space; </b>
<dd>/* (neg curr sym) 1-space, 0-no space */
<dt><b>UniChar p_sign_posn; </b>
<dd>/* positioning of non-negative monetary sign */
<dt><b>UniChar n_sign_posn; </b>
<dd>/* positioning of negative monetary sign */
<dt><b>short os2_mondecpt; </b>
<dd>/* os2 curr sym positioning */
<dt><b>UniChar *debit_sign; </b>
<dd>/* non-negative-valued monetary symbol - &quot;DB&quot;*/
<dt><b>UniChar *credit_sign; </b>
<dd>/* negative-valued monetary symbol - &quot;CR&quot; */
<dt><b>UniChar *left_parenthesis; </b>
<dd>/* negative-valued monetary symbol - &quot;(&quot; */
<dt><b>UniChar *right_parenthesis; </b>
<dd>/* negative-valued monetary symbol - &quot;)&quot; */
</dl>
</ul>
<p>The value of grouping and mon_grouping is interpreted according to the following:
<ul><dl>
<dt><b>0xffff </b>
<dd>No further grouping is to be performed.
<dt><b>0x0000 </b>
<dd>The previous element is to be repeatedly used for the remainder of the digits.
<dt><b>other </b>
<dd>The integer value is the number of digits that comprise the current group.
</dl>
</ul>
<p>The next element is examined to determine the size of the next group of digits before the current group. </p>
<p>The n_sign_posn and p_sign_posn elements are interpreted according to the following:
<ul><dl>
<dt><b>0 </b>
<dd>Quantity and currency_symbol are enclosed in parentheses
<dt><b>1 </b>
<dd>Sign precedes the quantity and currency_symbol
<dt><b>2 </b>
<dd>Sign follows the quantity and currency_symbol
<dt><b>3 </b>
<dd>Sign precedes the currency_symbol
<dt><b>4 </b>
<dd>Sign follows the currency_symbol
<dt><b>5 </b>
<dd>Use debit or credit sign for p_sign_posn or n_sign_posn
</dl>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50102" name="ToC_309">UniFreeLocaleInfo</a>
<dl>
<dd>&nbsp;
</dl>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to retrieve information about locale conventions.
#include &lt;stdio.h&gt;
#include &lt;unidef.h&gt;<br>
int main(void) {
LocaleObject      locale_object = NULL;
struct UniLconv   *puni_lconv = NULL;<br>
int               rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Retrieve locale information */
         rc = UniQueryLocaleInfo(locale_object, &amp;puni_lconv);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleInfo error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* print the value of the os2 currency symbol position */
         printf(&quot;The os2 currency symbol position is %d\n&quot;,
                 puni_lconv-&gt;os2_mondecpt);
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_21" name="LENSM50124">UniQueryLocaleItem</a></h2>
<p>UniQueryLocaleItem retrieves locale information by item. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryLocaleItem </b>
<dd><b>(const LocaleObject&nbsp;locale_object, LocaleItem&nbsp;item, UniChar&nbsp;**info_item_addr_ptr)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50510">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject. <a name="SPTSP50511">&nbsp;</a>
</dl>
<dl>
<dt>item &nbsp;(LocaleItem)&nbsp;
<dd>The item to be queried. <a name="SPTSP50512">&nbsp;</a>
<dd>&nbsp;
<dt>info_item_addr_ptr &nbsp;(UniChar **)&nbsp;
<dd>Address of a pointer where the locale information will be received.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50513">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLocaleItem returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The info_item_addr_ptr string is successfully filled with item associated with the locale object locale_object.
<dt><b>ULS_INVALID </b>
<dd>The locale item is not a valid locale item.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryLocaleItem returns a pointer in info_item_addr_ptr to a null-terminated UniChar string containing information
found in the locale object identified by locale_object about the language or cultural item named by the item argument.
UniQueryLocaleItem allocates the memory to hold the UniChar string and returns a pointer in info_item_addr_ptr. Use
UniFreeMem to free the memory associated with info_item_addr_ptr by UniQueryLocaleItem. </p>
<p>The constant names and values for item are contained in ulsitem.h:
<table border cellpadding="7" cellspacing="3" bordercolor="#000000">
<tr>
<td width=250 valign=top><strong>Item Name</strong></td>
<td width=388 valign=top><strong>Item Description</strong></td>
</tr><tr>
<td width=250 valign=top>LOCI_sDateTime</td>
<td width=388 valign=top>Date and time format string</td>
</tr><tr>
<td width=250 valign=top>LOCI_sShortDate </td>
<td width=388 valign=top>Short date format</td>
</tr><tr>
<td width=250 valign=top>LOCI_sTimeFormat</td>
<td width=388 valign=top>Time format string </td>
</tr><tr>
<td width=250 valign=top>LOCI_s1159</td>
<td width=388 valign=top>AM string </td>
</tr><tr>
<td width=250 valign=top>LOCI_s2359</td>
<td width=388 valign=top>PM sring</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName7</td>
<td width=388 valign=top>Abbreviation of day 7 (Sun)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName1</td>
<td width=388 valign=top>Abbreviation of day 1 (Mon)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName2</td>
<td width=388 valign=top>Abbreviation of day 2 (Tue)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName3</td>
<td width=388 valign=top>Abbreviation of day 3 (Wed)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName4</td>
<td width=388 valign=top>Abbreviation of day 4 (Thu)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName5</td>
<td width=388 valign=top>Abbreviation of day 5 (Fri)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevDayName6</td>
<td width=388 valign=top>Abbreviation of day 6 (Sat)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName7</td>
<td width=388 valign=top>Name of day of week 7 (Sun)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName1</td>
<td width=388 valign=top>Name of day of week 1 (Mon)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName2</td>
<td width=388 valign=top>Name of day of week 2 (Tue)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName3</td>
<td width=388 valign=top>Name of day of week 3 (Wed)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName4</td>
<td width=388 valign=top>Name of day of week 4 (Thu)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName5</td>
<td width=388 valign=top>Name of day of week 5 (Fri)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDayName6</td>
<td width=388 valign=top>Name of day of week 6 (Sat)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName1</td>
<td width=388 valign=top>Abbreviation of month 1</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName2</td>
<td width=388 valign=top>Abbreviation of month 2</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName3</td>
<td width=388 valign=top>Abbreviation of month 3</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName4</td>
<td width=388 valign=top>Abbreviation of month 4</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName5</td>
<td width=388 valign=top>Abbreviation of month 5</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName6</td>
<td width=388 valign=top>Abbreviation of month 6</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName7</td>
<td width=388 valign=top>Abbreviation of month 7 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName8</td>
<td width=388 valign=top>Abbreviation of month 8</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName9</td>
<td width=388 valign=top>Abbreviation of month 9</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName10</td>
<td width=388 valign=top>Abbreviation of month 10 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName11</td>
<td width=388 valign=top>Abbreviation of month 11 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName12</td>
<td width=388 valign=top>Abbreviation of month 12 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName1</td>
<td width=388 valign=top>Name of month 1</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName2</td>
<td width=388 valign=top>Name of month 2</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName3</td>
<td width=388 valign=top>Name of month 3</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName4</td>
<td width=388 valign=top>Name of month 4</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName5</td>
<td width=388 valign=top>Name of month 5</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName6</td>
<td width=388 valign=top>Name of month 6</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName7</td>
<td width=388 valign=top>Name of month 7</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName8</td>
<td width=388 valign=top>Name of month 8</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName9</td>
<td width=388 valign=top>Name of month 9</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName10</td>
<td width=388 valign=top>Name of month 10 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName11</td>
<td width=388 valign=top>Name of month 11 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName12</td>
<td width=388 valign=top>Name of month 12 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sDecimal</td>
<td width=388 valign=top>Decimal point </td>
</tr><tr>
<td width=250 valign=top>LOCI_sThousand</td>
<td width=388 valign=top>Triad separator </td>
</tr><tr>
<td width=250 valign=top>LOCI_sYesString</td>
<td width=388 valign=top>Yes string</td>
</tr><tr>
<td width=250 valign=top>LOCI_sNoString</td>
<td width=388 valign=top>No string</td>
</tr><tr>
<td width=250 valign=top>LOCI_sCurrency</td>
<td width=388 valign=top>Currency symbol </td>
</tr><tr>
<td width=250 valign=top>LOCI_sCodeSet</td>
<td width=388 valign=top>Locale codeset </td>
</tr><tr>
<td width=250 valign=top>LOCI_xLocaleToken</td>
<td width=388 valign=top>IBM Locale Token </td>
</tr><tr>
<td width=250 valign=top>LOCI_xWinLocale</td>
<td width=388 valign=top>Win32 Locale ID</td>
</tr><tr>
<td width=250 valign=top>LOCI_iLocaleResnum</td>
<td width=388 valign=top>Resource number for description</td>
</tr><tr>
<td width=250 valign=top>LOCI_sNativeDigits</td>
<td width=388 valign=top>String of native digits</td>
</tr><tr>
<td width=250 valign=top>LOCI_iMaxItem</td>
<td width=388 valign=top>Maximum item number</td>
</tr><tr>
<td width=250 valign=top>LOCI_sTimeMark</td>
<td width=388 valign=top>Time mark (am/pm) format </td>
</tr><tr>
<td width=250 valign=top>LOCI_sEra</td>
<td width=388 valign=top>Era definition </td>
</tr><tr>
<td width=250 valign=top>LOCI_sAltShortDate</td>
<td width=388 valign=top>Alternate short date format string</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAltDateTime</td>
<td width=388 valign=top>Alternate date and time format </td>
</tr><tr>
<td width=250 valign=top>LOCI_sAltTimeFormat</td>
<td width=388 valign=top>Alternate time format</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAltDigits</td>
<td width=388 valign=top>XPG4 alternate digist</td>
</tr><tr>
<td width=250 valign=top>LOCI_sYesExpr</td>
<td width=388 valign=top>xpg4 yes expression</td>
</tr><tr>
<td width=250 valign=top>LOCI_sNoExpr</td>
<td width=388 valign=top>xpg4 no expression</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDate</td>
<td width=388 valign=top>Short date separator</td>
</tr><tr>
<td width=250 valign=top>LOCI_sTime</td>
<td width=388 valign=top>Time separator</td>
</tr><tr>
<td width=250 valign=top>LOCI_sList</td>
<td width=388 valign=top>List separator</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonDecimalSep</td>
<td width=388 valign=top>Monetary currency separator</td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonThousandSep</td>
<td width=388 valign=top>Monetary triad separator </td>
</tr><tr>
<td width=250 valign=top>LOCI_sGrouping</td>
<td width=388 valign=top>Grouping of digits </td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonGrouping</td>
<td width=388 valign=top>Monetary groupings </td>
</tr><tr>
<td width=250 valign=top>LOCI_iMeasure</td>
<td width=388 valign=top>Measurement (Metric, British)</td>
</tr><tr>
<td width=250 valign=top>LOCI_iPaper</td>
<td width=388 valign=top>Normal paper size</td>
</tr><tr>
<td width=250 valign=top>LOCI_iDigits</td>
<td width=388 valign=top>Digits to right of decimal</td>
</tr><tr>
<td width=250 valign=top>LOCI_iTime</td>
<td width=388 valign=top>Clock format</td>
</tr><tr>
<td width=250 valign=top>LOCI_iDate</td>
<td width=388 valign=top>Format of short date</td>
</tr><tr>
<td width=250 valign=top>LOCI_iCurrency</td>
<td width=388 valign=top>Format of currency  </td>
</tr><tr>
<td width=250 valign=top>LOCI_iCurrDigits</td>
<td width=388 valign=top>Digits to right for currency </td>
</tr><tr>
<td width=250 valign=top>LOCI_iLzero</td>
<td width=388 valign=top>Leading zero used</td>
</tr><tr>
<td width=250 valign=top>LOCI_iNegNumber</td>
<td width=388 valign=top>Format of negative number </td>
</tr><tr>
<td width=250 valign=top>LOCI_iLDate</td>
<td width=388 valign=top>Format of long date</td>
</tr><tr>
<td width=250 valign=top>LOCI_iCalendarType</td>
<td width=388 valign=top>Type of default calandar </td>
</tr><tr>
<td width=250 valign=top>LOCI_iFirstDayOfWeek</td>
<td width=388 valign=top>First day of week (0=Mon)</td>
</tr><tr>
<td width=250 valign=top>LOCI_iFirstWeekOfYear</td>
<td width=388 valign=top>First week of year </td>
</tr><tr>
<td width=250 valign=top>LOCI_iNegCurr</td>
<td width=388 valign=top>Format of negative currency</td>
</tr><tr>
<td width=250 valign=top>LOCI_iTLzero</td>
<td width=388 valign=top>Leading zero on time</td>
</tr><tr>
<td width=250 valign=top>LOCI_iTimePrefix</td>
<td width=388 valign=top>AM/PM preceeds time </td>
</tr><tr>
<td width=250 valign=top>LOCI_iOptionalCalendar</td>
<td width=388 valign=top>Alternate calandar type</td>
</tr><tr>
<td width=250 valign=top>LOCI_sIntlSymbol</td>
<td width=388 valign=top>International currency symbol</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevLangName</td>
<td width=388 valign=top>Windows language abbreviation</td>
</tr><tr>
<td width=250 valign=top>LOCI_sCollate</td>
<td width=388 valign=top>Collation table</td>
</tr><tr>
<td width=250 valign=top>LOCI_iUpperType</td>
<td width=388 valign=top>Upper case algorithm </td>
</tr><tr>
<td width=250 valign=top>LOCI_iUpperMissing</td>
<td width=388 valign=top>Action for missing upper case</td>
</tr><tr>
<td width=250 valign=top>LOCI_sPositiveSign</td>
<td width=388 valign=top>Positive sign</td>
</tr><tr>
<td width=250 valign=top>LOCI_sNegativeSign</td>
<td width=388 valign=top>Negative sign</td>
</tr><tr>
<td width=250 valign=top>LOCI_sLeftNegative</td>
<td width=388 valign=top>Left paren for negative</td>
</tr><tr>
<td width=250 valign=top>LOCI_sRightNegative</td>
<td width=388 valign=top>Right paren for negative </td>
</tr><tr>
<td width=250 valign=top>LOCI_sLongDate</td>
<td width=388 valign=top>Long date formatting string
</tr><tr>
<td width=250 valign=top>LOCI_sAltLongDate</td>
<td width=388 valign=top>Alternate long date format string </td>
</tr><tr>
<td width=250 valign=top>LOCI_sMonthName13</td>
<td width=388 valign=top>Name of month 13 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sAbbrevMonthName13</td>
<td width=388 valign=top>Abbreviation of month 13 </td>
</tr><tr>
<td width=250 valign=top>LOCI_sName</td>
<td width=388 valign=top>OS/2 locale name</td>
</tr><tr>
<td width=250 valign=top>LOCI_sLanguageID</td>
<td width=388 valign=top>Abbreviation for language (ISO)</td>
</tr><tr>
<td width=250 valign=top>LOCI_sCountryID</td>
<td width=388 valign=top>Abbreviation for country (ISO) </td>
</tr><tr>
<td width=250 valign=top>LOCI_sEngLanguage</td>
<td width=388 valign=top>English name of Language </td>
</tr><tr>
<td width=250 valign=top>LOCI_sLanguage</td>
<td width=388 valign=top>Native name of language</td>
</tr><tr>
<td width=250 valign=top>LOCI_sEngCountry</td>
<td width=388 valign=top>English name of country</td>
</tr><tr>
<td width=250 valign=top>LOCI_sCountry</td>
<td width=388 valign=top>Localized country name</td>
</tr><tr>
<td width=250 valign=top>LOCI_sNativeCtryName</td>
<td width=388 valign=top>Name of country in native language</td>
</tr><tr>
<td width=250 valign=top>LOCI_iCountry</td>
<td width=388 valign=top>Country code</td>
</tr><tr>
<td width=250 valign=top>LOCI_sISOCodepage</td>
<td width=388 valign=top>ISO codepage name</td>
</tr><tr>
<td width=250 valign=top>LOCI_iAnsiCodepage</td>
<td width=388 valign=top>Windows codepage </td>
</tr><tr>
<td width=250 valign=top>LOCI_iCodepage</td>
<td width=388 valign=top>OS/2 primary codepage</td>
</tr><tr>
<td width=250 valign=top>LOCI_iAltCodepage</td>
<td width=388 valign=top>OS/2 alternate codepage</td>
</tr><tr>
<td width=250 valign=top>LOCI_iMacCodepage</td>
<td width=388 valign=top>Mac codepage </td>
</tr><tr>
<td width=250 valign=top>LOCI_iEbcdicCodepage</td>
<td width=388 valign=top>Ebcdic codepage</td>
</tr><tr>
<td width=250 valign=top>LOCI_sOtherCodepages</td>
<td width=388 valign=top>Other ASCII codepages</td>
</tr><tr>
<td width=250 valign=top>LOCI_sSetCodepage</td>
<td width=388 valign=top>Codpage to set on activation </td>
</tr><tr>
<td width=250 valign=top>LOCI_sKeyboard</td>
<td width=388 valign=top>Primary keyboard name</td>
</tr><tr>
<td width=250 valign=top>LOCI_sAltKeyboard</td>
<td width=388 valign=top>Alternate keyboard name</td>
</tr><tr>
<td width=250 valign=top>LOCI_sSetKeyboard</td>
<td width=388 valign=top>Keyboard to set on activation</td>
</tr><tr>
<td width=250 valign=top>LOCI_sDebit</td>
<td width=388 valign=top>Debit string</td>
</tr><tr>
<td width=250 valign=top>LOCI_sCredit</td>
<td width=388 valign=top>Credit string</td>
</tr><tr>
<td width=250 valign=top>LOCI_sLatin1Locale</td>
<td width=388 valign=top>Locale for Latin 1 names </td>
</tr><tr>
<td width=250 valign=top>LOCI_wTimeFormat</td>
<td width=388 valign=top>Win32 Time format</td>
</tr><tr>
<td width=250 valign=top>LOCI_wShortDate</td>
<td width=388 valign=top>Win32 Date format</td>
</tr><tr>
<td width=250 valign=top>LOCI_wLongDate</td>
<td width=388 valign=top>Win32 Long date format </td>
</tr><tr>
</table>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50301" name="ToC_309">UniSetUserLocaleItem</a>
<dl>
<dd>&nbsp;
</dl>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to retrieve locale information by item.
#include &lt;stdio.h&gt;
#include &lt;unidef.h&gt;<br>
int main(void) {
LocaleObject      locale_object = NULL;
UniChar           *pinfo_item;
int               rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Retrieve name of the tenth month locale item */
         rc = UniQueryLocaleItem(locale_object,
                                 MON_10,
                                 &amp;pinfo_item);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleItem error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniFreeMem(pinfo_item);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeMem error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_305" name="LENSM50305">UniQueryLocaleList</a></h2>
<p>UniQueryLocaleList returns a buffer filled with a list of the locales defined on the system.</p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<p><b>int UniQueryLocaleList </b></p>
<ul><p><b>(int &nbsp;flag, UniChar &nbsp;* &nbsp;uniBuffer, int &nbsp;numUniChars)</b> </p>
</ul>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50510">&nbsp;</a>
<dl>
<dt>flag &nbsp;(int)&nbsp;
<dd>A flag indicating whether to return a list of system defined locales or user defined locales. <a name="SPTSP50511">&nbsp;</a>
</dl>
<dl>
<dt>uniBuffer &nbsp;(UniChar &nbsp;* )&nbsp;
<dd>A pointer to a buffer that is filled with UniChar's representing the list of system or user defined locales.<a name="SPTSP50512">&nbsp;</a>
<dd>&nbsp;
<dt>numUniChars &nbsp;(int)&nbsp;
<dd>The maximum size of the buffer used to return the list of locales.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50513">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLocaleList returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The buffer is filled with the appropriate list of locales.
<dt><b>ULS_BUFFERFULL </b>
<dd>The locale list size exceeded the supplied buffer size.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>The flag parameter can be used to select either system defined locales or user defined locales. The system and user defined
choices can be or'ed together to retrieve the complete list of locales.</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50300" name="ToC_309">UniQueryLocaleValue</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to retrieve a list of locales available on the
system.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
int     rc = ULS_SUCCESS;
&nbsp;
/* Arrays containing system and user locales */
UniChar *uniSysLocales;
UniChar *uniUsrLocales;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Allocate space for the locale list (2 bytes/UniChar) */
&nbsp;&nbsp;&nbsp;&nbsp;uniSysLocales = (UniChar *) malloc(4096);
&nbsp;&nbsp;&nbsp;&nbsp;uniUsrLocales = (UniChar *) malloc(4096);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if(!uniSysLocales || !uniUsrLocales) {
      printf(&quot;Malloc failed error: return code = %u\n&quot;, rc);
      return 1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/************************************************************/
&nbsp;&nbsp;&nbsp;&nbsp;/* Obtain the list of system and user defined locales */
&nbsp;&nbsp;&nbsp;&nbsp;/************************************************************/
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleList(UNI_SYSTEM_LOCALES, uniSysLocales, 2048);
&nbsp;&nbsp;&nbsp;&nbsp;if(rc) {
      printf(&quot;UniQueryLocaleList error: return code = %u\n&quot;, rc);
      return 1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleList(UNI_USER_LOCALES, uniUsrLocales, 2048);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if(rc) {
      printf(&quot;UniQueryLocaleList error: return code = %u\n&quot;, rc);
      return 1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
    return ULS_SUCCESS;</pre>
<p>}</p>
<p><hr> </p>
<h2><a href="#ToC_22" name="LENSM50125">UniQueryLocaleObject</a></h2>
<p>UniQueryLocaleObject retrieves the locale name. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryLocaleObject </b>
<dd><b>(const&nbsp;LocaleObject&nbsp;locale_object, int&nbsp;category, int&nbsp;LocaleSpecType, void&nbsp;**locale_name)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const&nbsp;LocaleObject)&nbsp;
<dd>Locale object created by a call to UniCreateLocaleObject.
<dd>&nbsp;
<dt>category &nbsp;(int)&nbsp;
<dd>Locale category identifier.
</dl>
<p>The permissible values for <b>category</b> are:
<ul type="disc">
<li><b>LC_ALL</b>
<li><b>LC_COLLATE</b>
<li><b>LC_CTYPE</b>
<li><b>LC_MESSAGES</b>
<li><b>LC_MONETARY</b>
<li><b>LC_NUMERIC</b>
<li><b>LC_TIME</b>
<p><a name="SPTSP50516">&nbsp;</a>
</ul>
<dl>
<dt>LocaleSpecType &nbsp;(int)&nbsp;
<dd>The <b>LocaleSpecType</b> argument can take any of the following values, which are constants defined in the header
<b>unidef.h</b>:
<dl>
<dt><b>UNI_TOKEN_POINTER </b>
<dd>Requests that a pointer to a token pointer be returned.
<dt><b>UNI_MBS_STRING_POINTER </b>
<dd>Requests that a multibyte string pointer be returned.
<dt><b>UNI_UCS_STRING_POINTER </b>
<dd>Requests that a UCS string pointer be returned.
</dl>
<p><a name="SPTSP50517">&nbsp;</a>
<dt>locale_name &nbsp;(void **)&nbsp;
<dd>The address of a pointer variable locale_name that will contain the locale name.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLocaleObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>A valid locale specification for the supplied locale object is returned.
<dt><b>ULS_INVALID </b>
<dd>The locale specified by locale_object is invalid.
<dt><b>ULS_OTHER </b>
<dd>The C locale is because LOCALE.DLL cound not be found.
<dt><b>ULS_UNSUPPORTED </b>
<dd>The locale name is valid but the locale cound not be found.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryLocaleObject returns a pointer to a locale specification in the area pointed to by <b>locale_name</b>.
UniQueryLocaleObject allocates memory to hold the generated value as necessary. Use UniFreeMem to free the memory
associated with locale_name by UniQueryLocaleObject. </p>
<p>The value returned in the area pointed to by <b>locale_name</b> will point to either a string or a token, as indicated by the value of
the <b>LocaleSpecType</b> argument. </p>
<p>When the <b>LocaleSpecType</b> argument is <b>UNI_TOKEN_POINTER</b> and the category argument is valid, a pointer to a
token that represents the locale value associated with the <b>category</b> argument is returned, if such a token exists. </p>
<p>When the <b>LocaleSpecType</b> argument is <b>UNI_MBS_STRING_POINTER</b> or <b>UNI_UCS_STRING_POINTER</b>,
UniQueryLocaleObject returns a pointer to a string that represents the locale value associated with the <b>category</b> argument. </p>
<p>When the <b>LocaleSpecType</b> argument is <b>UNI_MBS_STRING_POINTER</b> or <b>UNI_UCS_STRING_POINTER</b> and
the <b>category</b> argument is <b>LC_ALL</b>, a string that represents the values of all of the locale categories of <b>locale_object</b> is
returned. The returned string may be used as the <b>LocaleSpec</b> argument to UniCreateLocaleObject to create a locale object
that is a functional equivalent of <b>locale_object</b>. </p>
<p>When the <b>LocaleSpecType</b> argument is <b>UNI_MBS_STRING_POINTER</b> or <b>UNI_UCS_STRING_POINTER</b> and
the <b>category</b> argument is <b>LC_COLLATE</b>, <b>LC_CTYPE</b>, <b>LC_MESSAGES</b>, <b>LC_MONETARY</b>, <b>LC_NUMERIC</b>, or
<b>LC_TIME</b>, a string that represents the value of the respective locale category of <b>locale_object</b> is returned. The returned
string may be used as the <b>LocaleSpec</b> argument to UniCreateLocaleObject create a locale object. All locale category
values are set to the value of the queried locale category of <b>locale_object</b>. </p>
<p>If <b>locale_object</b> contains a NULL pointer, UniQueryLocaleObject returns a locale specification pointer identifying the
respective categories of the default locale. If the <b>category</b> argument is <b>LC_ALL</b>, this value can be passed to
UniCreateLocaleObject to create a locale object that is the functional equivalent of the current default locale, as specified by
the environment variables of the current process. </p>
<p>If <b>locale_object</b> is invalid, the contents of <b>locale_name</b> are undefined and no memory is allocated. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50099" name="ToC_309">UniCreateLocaleObject</a>
<li><a href="#LENSM50103">UniFreeLocaleObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to retrieve a locale category name.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject      locale_object = NULL;
UniChar           *plocale_name;
int               rc = ULS_SUCCESS;</pre>
<p>/* Retrieve locale name of default locale */ </p>
<pre>         rc = UniQueryLocaleObject(NULL,
                                   LC_ALL,
                                   UNI_UCS_STRING_POINTER,
                                   (void **)&amp;plocale_name);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create a locale object based upon the default setting */
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)plocale_name, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniFreeMem(plocale_name);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeMem error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_300" name="LENSM50300">UniQueryLocaleValue</a></h2>
<p>UniQueryLocaleValue returns an integral value associated with the requested locale item. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<p><b>int UniQueryLocaleValue </b></p>
<ul><p><b>(const LocaleObject &nbsp;locale_object, &nbsp;LocaleItem &nbsp;item, &nbsp;int &nbsp;* &nbsp;info_item)</b> </p>
</ul>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50510">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const&nbsp;LocaleObject)&nbsp;
<dd>Locale object created by a call to UniCreateLocaleObject. <a name="SPTSP50511">&nbsp;</a>
</dl>
<dl>
<dt>item &nbsp;(LocaleItem)&nbsp;
<dd>The locale item being requested.<a name="SPTSP50512">&nbsp;</a>
<dd>&nbsp;
<dt>info_item &nbsp;(int &nbsp;*)&nbsp;
<dd>A pointer to an integer where the value of the locale item is returned.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50513">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniQueryLocaleValue returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The info_item is set to the appropriate integral item value.
<dt><b>ULS_BADOBJ</b>
<dd>The locale item is invalid or does not exist.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>When a locale item is requested that does not have an integral value, zero is returned to the caller.</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50305" name="ToC_309">UniQueryLocaleList</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to retrieve the value for a locale item.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
#include &lt;ulsitem.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
ULONG        pmCodepage;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'd';    /* Unicode lowercase Latin letter d */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = UniQueryLocaleValue(locale_object, LOCI_iCodepage,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int *)&amp;pmCodepage);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryLocaleValue error: return code = %u\n&quot;, rc);
           return 1;
         }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Presentation manager is using codepage %d\n&quot;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmCodepage);
&nbsp;
    return ULS_SUCCESS;</pre>
<p>}</p>
<p><hr> </p>
<h2><a href="#ToC_23" name="LENSM50126">UniQueryLower</a></h2>
<p>UniQueryLower queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryLower </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50520">&nbsp;</a>
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'd';    /* Unicode lowercase Latin letter d */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryLower(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a lowercase character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a lowercase character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_313" name="LENSM50313">UniQueryNumericValue</a></h2>
<p>UniQueryNumericValue returns the numeric value associated with a Unicode character. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryNumericValue </b>
<dd><b>(UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50521">&nbsp;</a>
<dl>
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50129">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>The function returns a -1 if unsuccessful. &nbsp;Otherwise, the numeric value of the Unicode character is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function returns numeric values for ranges of Unicode numeric characters. &nbsp;The function can be used to identify the
digits both decimal and hexadecimal for Latin numbers, Arabic, Indian dialects, Laotian, Thai, Han and others represented
in the Unicode character set.</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50311" name="ToC_309">UniQueryCharType</a> &nbsp;
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query the numeric value of a character.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
&nbsp;
int          result = 0;
int          rc = ULS_SUCCESS;
UNICTYPE &nbsp;&nbsp;* ct;
UniChar &nbsp;&nbsp;&nbsp;* uptr;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set up a Unicode numeric character to test */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uptr = L'1';
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Determine the characters type */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ct = UniQueryCharType(*uptr);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Test the Unicode character to see if it is a digit */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* It can be either decimal or Hex */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((ct-&gt;itype &amp; CT_XDIGIT) || (ct-&gt;itype &amp; CT_NUMBER)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = UniQueryNumericValue(*uptr);
&nbsp;
         if (num == -1) {
           printf(&quot;UniQueryNumericValue error: return code = %u\n&quot;, rc);
           return 1;
         }
        return ULS_SUCCESS;<br>
}</pre>
<p><hr></p>
<h2><a href="#ToC_24" name="LENSM50128">UniQueryPrint</a></h2>
<p>UniQueryPrint queries character attributes. </p>
<p><strong>Format</strong> &nbsp;.</p>
<p><hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryPrint </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50524">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50131">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'd';    /* Unicode lowercase Latin letter d */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryPrint(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a printable character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a printable character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_25" name="LENSM50130">UniQueryPunct</a></h2>
<p>UniQueryPunct queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryPunct </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50524">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50131">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'?';    /* Unicode Latin question mark */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryPrint(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a punctuation character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a punctuation character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_26" name="LENSM50132">UniQuerySpace</a></h2>
<p>UniQuerySpace queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQuerySpace </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50526">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50133">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L' ';    /* Unicode space character */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQuerySpace(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a space character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a space character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_310" name="LENSM50310">UniQueryStringType</a></h2>
<p>UniQueryStringType &nbsp;is used to query character types for a string.</p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>ULONG UniQueryStringType </b>
<dd><b>(UniChar &nbsp;* &nbsp;ustr, &nbsp;int &nbsp;size, &nbsp;USHORT &nbsp;* &nbsp;outstr, &nbsp;int &nbsp;kind)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ustr &nbsp;(UniChar &nbsp;*)&nbsp;
<dd>A pointer to the Unicode string. <a name="SPTSP50528">&nbsp;</a>
<dd>&nbsp;
<dt>size &nbsp;(int)&nbsp;
<dd>The size of the UniChar character string to query.
<dd>&nbsp;
<dt>outstr &nbsp;(USHORT &nbsp;*)
<dd>A pointer to an array of USHORTs. &nbsp;Each USHORT represents the type of one of the Unicode characters.
<dd>&nbsp;
<dt>kind &nbsp;(int)
<dd>An integer describing the type of string.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50135">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(ulong)&nbsp; -&nbsp;UniQueryStringType returns one of the following:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The function was successful.
<dt><b>ULS_INVALID </b>
<dd>The kind of string supplied is not known.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<pre>Valid values for kind are:</pre>
<ul type="disc">
<li>CT_ITYPE
<li>CT_BIDI
<li>CT_CHARSET
<li>CT_EXTENDED
<li>CT_CODEPAGE
<li>CT_INDEX
<li>CT_CTYPE1 - Win32 compatible XPG/4
<li>CT_CTYPE2 &nbsp;- Win32 compatible BiDi
<li>CT_CTYPE3 - Win32 compatible extended
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50311" name="ToC_309">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_308">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query string types.
#include &lt;unidef.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
/*
* CountJapanese: Count the number of Japanese chars in string
*/
int CountJapanese(UniChar * instr) {
int len;
USHORT * outbuf, * pout;
int count;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Get some memory to return the string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;len = UniStrlen(instr);
&nbsp;&nbsp;&nbsp;&nbsp;outbuf = malloc(len * sizeof(UniChar));
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Query the extended character type of the string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UniQueryStringType(instr, len, outbuf, CT_EXTENDED);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Search the retuned array of types for Japanese chars
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;count = 0;
&nbsp;&nbsp;&nbsp;&nbsp;pout = outbuf;
&nbsp;&nbsp;&nbsp;&nbsp;while (len--) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (*pout &amp; (C3_KATAKANA|C3_HIRAGANA|C3_IDEOGRAPH)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pout++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Free up type array and return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;free(outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;return count;
}</pre>
<p><hr> </p>
<h2><a href="#ToC_27" name="LENSM50134">UniQueryUpper</a></h2>
<p>UniQueryUpper queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryUpper </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50528">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50135">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'D';    /* Unicode uppercase Latin letter D */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryUpper(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is an uppercase character\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not an uppercase character\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_28" name="LENSM50136">UniQueryXdigit</a></h2>
<p>UniQueryXdigit queries character attributes. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniQueryXdigit </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50530">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar character to query.
</dl>
<p><strong>Returns</strong> <a name="SPTSM50137">&nbsp;</a>
<dl>
<dt>Return Value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the result of the test is true, the function returns 1. Otherwise, 0 is returned.
</dl>
<p><strong>Remarks</strong> </p>
<p>This function provides the functionality of UniCreateAttrObject, UniQueryCharAttr, and UniFreeAttrObject as an atomic
operation for the invariant attributes. </p>
<p>The locale may be specified as NULL to indicate default Unicode
character attributes</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query character attributes.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
UniChar      uni_char = L'D';    /* Unicode uppercase Latin letter D */
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query character attribute */
         result = UniQueryXdigit(locale_object, uni_char);
         if (result)
           printf(&quot;UniChar character %04X is a hex digit\n&quot;, uni_char);
         else
           printf(&quot;UniChar character %04X is not a hex digit\n&quot;, uni_char);</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_29" name="LENSM50138">UniScanForAttr</a></h2>
<p>UniScanForAttr scans a Unicode string for an attribute match. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniScanForAttr </b>
<dd><b>(AttrObject&nbsp;attr_object, const UniChar&nbsp;*ucs, size_t&nbsp;num_elems, ulsBool&nbsp;inverse_op, size_t&nbsp;*offset)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>attr_object &nbsp;(AttrObject)&nbsp;
<dd>An attribute object created by UniCreateAttrObject. <a name="SPTSP50532">&nbsp;</a>
<dt>ucs &nbsp;(const UniChar *)&nbsp;
<dd>The array of UniChar code elements to be scanned for the set of attributes in attr_object. <a name="SPTSP50533">&nbsp;</a>
<dt>num_elems &nbsp;(size_t)&nbsp;
<dd>The number of UniChar code elements to be searched. <a name="SPTSP50534">&nbsp;</a>
<dt>inverse_op &nbsp;(ulsBool)&nbsp;
<dd>Determines scanning rules. Set to false to search for the first match. Set to true to search for the first nonmatching
element. <a name="SPTSP50535">&nbsp;</a>
<dt>offset &nbsp;(size_t *)&nbsp;
<dd>An integer identifying the location of the first element meeting the criteria.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniScanForAttr returns one of the following:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The function was successful.
<dt><b>ULS_NOMATCH </b>
<dd>No code element meets the specified criteria.
<dt><b>ULS_BADOBJ </b>
<dd>The attribute object specified by attr_object is not a valid attribute object.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniScanForAttr scans the array of code elements identified by ucs, from the position specified by ucs, searching for the first
code element that matches or does not match the set of attributes specified by attr_object. </p>
<p>The inverse_op argument determines the rules for scanning and is an integer type containing one of the following values: </p>
<ul><p><strong>0 - FALSE</strong> </p>
<p><strong>1 - TRUE</strong> </p>
</ul>
<p>If inverse_op is set to FALSE, the function searches for the first code element that matches all of the attributes of the
specified attr_object; if inverse_op is set to TRUE, the function searches for the first code element that matches none of the
attributes of attr_object. </p>
<p>The search begins from the code element identified by ucs, through the next num_elems code elements. A non-negative
integer identifying the location of the first code element meeting all of the criteria specified by attr_object is returned in the
area pointed to by offset. This indicates the number of code elements offset from the code element identified by ucs, to the
code element at which the attribute match is satisfied. If no code element meets the specified criteria, the contents of offset
are undefined. </p>
<p><strong>Related Functions</strong>
</dl>
<ul type="disc">
<li><a href="#LENSM50309" name="ToC_309">UniQueryAttr</a>
<li><a href="#LENSM50308" name="ToC_308">UniQueryChar</a>
<li><a href="#LENSM50115" name="ToC_115">UniQueryCharAttr</a>
<li><a href="#LENSM50311" name="ToC_311">UniQueryCharType</a>
<li><a href="#LENSM50312" name="ToC_312">UniQueryCharTypeTable</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to scan a Unicode string for an attribute match.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
AttrObject   attr_object = NULL;
int          result = 0;
int          rc = ULS_SUCCESS;
size_t       offset = 0;
UniChar      *uni_char = L&quot;os2&quot;;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an attribute object */
         rc = UniCreateAttrObject(locale_object,
                                 (UniChar *)L&quot;digit&quot;, &amp;attr_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateAttrObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Make call to determine if string matches attributes */
         rc = UniScanForAttr(attr_object, uni_char, UniStrlen(uni_char),
                             FALSE, &amp;offset);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniScanForAttr error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_301" name="LENSM50301">UniSetUserLocaleItem</a></h2>
<p>UniSetUserLocaleItem is used to set a locale override for a locale item.</p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int &nbsp;UniSetUserLocaleItem </b>
<dd><b>(UniChar&nbsp;&nbsp;* &nbsp;locale, int &nbsp;item, int &nbsp;type, &nbsp;void &nbsp;* &nbsp;value)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale &nbsp;(UniChar *)&nbsp;
<dd>Locale to have item changed. <a name="SPTSP50538">&nbsp;</a>
<dd>&nbsp;
<dt>item &nbsp;(int)&nbsp;
<dd>Item to be set.
<dd>&nbsp;
<dt>type &nbsp;(int)
<dd>Type of item.
<dd>&nbsp;
<dt>value &nbsp;(void &nbsp;*)
<dd>Pointer to item to be changed.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniSetUserLocaleItem returns one of the following:
<dl>
<dt><b>ULS_SUCCESS &nbsp;</b>
<dd>The function was successful.
<dt><b>ULS_INVALID </b>
<dd>No code element meets the specified criteria.
<dt><b>ULS_NOMATCH </b>
<dd>The specified locale was not found.
</dl>
<dl>
<dt><b>ULS_NOMEMORY &nbsp;</b>
<dd>A memory allocation error was detected.
<dt><b>ULS_BADOBJECT </b>
<dd>The specified locale is not a user defined locale.
<dt><b>ULS_BUFFERFULL </b>
<dd>The item is too long for the buffer.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniSetUserLocaleItem modifies an item in a user locale.  This affects all
users of that locale.  After doing this function, a call to
<a href="#LENSM50304">UniCompleteUserLocale</a>
is necessary to make the changes permanent.
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50124" name="ToC_309">UniQueryLocaleItem</a>
<li><a href="#LENSM50304" name="ToC_304">UniCompleteUserLocale</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to set a user locale item.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {<br>
UniChar &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unilocaleName[John's_Locale];
LocaleObject locale_object = NULL;<br>
&nbsp;
int          result = 0;
int          rc = ULS_SUCCESS;
size_t       offset = 0;
&nbsp;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Set the time separator for John's locale to a semicolon */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = UniSetUserLocaleItem(unilocaleName, TIMESEP,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ULTYPE_UNICODE, (UniChar *)L&quot;:&quot;);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (rc != ULS_SUCCESS) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;UniSetUserLocaleItem error: return code = %u\n&quot;, rc);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ULS_SUCCESS;&nbsp;
}
<strong><hr> </strong></pre>
<h2><a href="#ToC_30" name="LENSM50139">UniStrcat</a></h2>
<p>UniStrcat concatenates code element strings. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar *UniStrcat </b>
<dd><b>(UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs1 &nbsp;(UniChar *)&nbsp;
<dd>String to be appended to. <a name="SPTSP50538">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String to concatenate.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>Concatenated string.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrcat appends a copy of the code element string pointed to by ucs2 (including the terminating null code element) to the
end of the code element string pointed to by ucs1. The initial wide code element of ucs2 overwrites the null code element at
the end of ucs1. If copying takes place between objects that overlap, the results are unpredictable. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50150" name="ToC_309">UniStrncat</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to concatenate Unicode strings.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[40] = L&quot;computer&quot;;<br>
UniChar    *puni;
         puni = UniStrcat(ucs1, (UniChar *)L&quot; program&quot;);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_31" name="LENSM50140">UniStrchr</a></h2>
<p>UniStrchr searches for the first occurrence of a code element. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar *UniStrchr </b>
<dd><b>(const UniChar&nbsp;*ucs, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs &nbsp;(const UniChar *)&nbsp;
<dd>A null-terminated UniChar string to be searched. <a name="SPTSP50541">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The UniChar search character.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50542">&nbsp;</a>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrchr returns either a pointer to the located code element or a null pointer, if the code element does not occur in
the string.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrchr locates the first occurrence of uc in the array of code elements pointed to by ucs. The terminating null code
element is considered to be part of the string. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50156" name="ToC_309">UniStrrchr</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to search a Unicode string for the first occurence
of a code element.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer program&quot;;
UniChar    *puni;<br>
UniChar    uni_char = L'p';
         puni = UniStrchr(ucs1, uni_char);
         if(puni) {
            printf(&quot;The character was found in the string\n&quot;);
            return (ULS_SUCCESS);
         }</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_32" name="LENSM50141">UniStrcmp</a></h2>
<p>UniStrcmp compares code element strings. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrcmp </b>
<dd><b>(const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50543">&nbsp;</a>
<dl>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>String to be compared. <a name="SPTSP50544">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String to be compared.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50545">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrcmp returns an integer greater than, equal to, or less than zero, according to whether the code element string
pointed to by ucs1 is greater than, equal to, or less than the code element string pointed to by ucs2.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrcmp compares the code element string pointed to by ucs1 to the code element string pointed to by ucs2.</p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50142" name="ToC_309">UniStrcmpi</a>
<li><a href="#LENSM50151">UniStrncmp</a>
<li><a href="#LENSM50152">Unistrncmpi</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to compare Unicode strings.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[] = L&quot;program&quot;;<br>
int        result = 0;
         result = UniStrcmp(ucs1, ucs2);
         if ( result == 0 )
             printf(&quot;The strings are identical\n&quot;);
         else
             printf(&quot;The strings are not identical\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_33" name="LENSM50142">UniStrcmpi</a></h2>
<p>UniStrcmpi compares strings without sensitivity to case. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrcmpi </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A valid locale object created by a call to UniCreateLocaleObject or NULL <a name="SPTSP50547">&nbsp;</a>
<dd>&nbsp;
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>A null terminated UniChar string to be compared. <a name="SPTSP50548">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>A null terminated UniChar string to be compared.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50549">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dl>
<dt><b>less than 0 </b>
<dd>ucs1 less than ucs2
<dt><b>0 </b>
<dd>ucs1 equivalent to ucs2
<dt><b>Greater than 0 </b>
<dd>ucs1 greater than ucs
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrcmpi compares ucs1 and ucs2 without sensitivity to case. All characters are converted to lowercase before the
comparison. The locale object is used to convert the characters to lowercase.
The locale may be specified as NULL to indicate default Unicode casing.</p>
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50141" name="ToC_309">UniStrcmp</a>
<li><a href="#LENSM50151">UniStrncmp</a>
<li><a href="#LENSM50152">UniStrncmpi</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to compare Unicode strings without sensitivity to case.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
UniChar      ucs1[] = L&quot;computer&quot;;
UniChar      ucs2[] = L&quot;COMPUTER&quot;;
int          result = 0;
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = UniStrcmpi(locale_object, ucs1, ucs2);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( result == 0 )
             printf(&quot;The strings are identical\n&quot;);
         else
             printf(&quot;The strings are not identical\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_34" name="LENSM50143">UniStrcoll</a></h2>
<p>UniStrcoll compares language collation strings. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrcoll </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50551">&nbsp;</a>
<dd>&nbsp;
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>A string to be compared. <a name="SPTSP50552">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>A string to be compared.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniStrcoll returns an integer greater than, equal to, or less than zero. The integer returned depends on whether:
<ul type="disc">
<li>The string pointed to by ucs1 is greater than, equal to, or less than the character string pointed to by ucs2
<li>Both character strings are interpreted as appropriate to the LC_COLLATE category of the locale indicated by
the locale-object-handle argument, locale_object.
The locale may be specified as NULL to indicate default Unicode collation.</p>
</ul>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrcoll compares the string pointed to by ucs1 to the string pointed to by ucs2, both interpreted as appropriate to the
LC_COLLATE category of the locale indicated by the locale object handle argument, locale_object. </p>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to compare Unicode strings using the collating
sequence specified by the locale object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
UniChar      ucs1[] = L&quot;axe&quot;;
UniChar      ucs2[] = L&quot;ant&quot;;
int          result = 0;
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }</pre>
<p>result = UniStrcoll(locale_object, ucs1, ucs2); </p>
<pre>         if ( result == 0 )
             printf(&quot;The strings are identical\n&quot;);
         else if ( result &lt; 0 )
             printf(&quot;String1 is less than String2\n&quot;);
         else
             printf(&quot;String1 is greater than String2\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_35" name="LENSM50144">UniStrcpy</a></h2>
<p>UniStrcpy copies code element string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrcpy </b>
<dd><b>(UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50554">&nbsp;</a>
<dl>
<dt>ucs1 &nbsp;(UniChar *)&nbsp;
<dd>Target string.
<dd><a name="SPTSP50555">&nbsp;</a>
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>Source string.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50556">&nbsp;</a>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrcpy returns ucs1.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrcpy copies the code element string pointed to by ucs2 (including the terminating null code element) into the code
element array pointed to by ucs1. If copying takes place between objects that overlap, the results are unpredictable.
<strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50153" name="ToC_309">UniStrncpy</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to copy Unicode strings.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[10];<br>
UniChar    *puni;
         puni = UniStrcpy(ucs2, ucs1);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_36" name="LENSM50145">UniStrcspn</a></h2>
<p>UniStrcspn searches for code element string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>size_t UniStrcspn </b>
<dd><b>(const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50557">&nbsp;</a>
<dl>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>String to be searched. &nbsp;
<dd><a name="SPTSP50558">&nbsp;</a>
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String to search for.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(size_t)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrcspn returns the length of the segment.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrcspn computes the length of the maximum initial segment of the code element string, pointed to by ucs1, which
consists entirely of code elements not from the string pointed to by ucs2. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50157" name="ToC_309">UniStrspn</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to search Unicode strings.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;This is the source string&quot;;
UniChar    ucs2[] = L&quot;source&quot;;<br>
size_t     result;
         result = UniStrcspn(ucs1, ucs2);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_37" name="LENSM50146">UniStrfmon</a></h2>
<p>UniStrfmon converts monetary value to string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrfmon </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;*ucs, size_t&nbsp;maxsize, const UniChar&nbsp;*format, &nbsp;&nbsp;...)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50561">&nbsp;</a>
<dd>&nbsp;
<dt>ucs &nbsp;(UniChar *)&nbsp;
<dd>Target string. <a name="SPTSP50562">&nbsp;</a>
<dd>&nbsp;
<dt>maxsize &nbsp;(size_t)&nbsp;
<dd>Maximum number of code elements to be placed in the target string. <a name="SPTSP50563">&nbsp;</a>
<dd>&nbsp;
<dt>format &nbsp;(const UniChar *)&nbsp;
<dd>Format to be used when formulating the target string. <a name="SPTSP50564">&nbsp;</a>
<dd>&nbsp;
<dt>... &nbsp;(&nbsp;)&nbsp;
<dd>Zero or more arguments fetched according to the format string.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50565">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>If the total number of code elements, including the null terminating code element, is not more than maxsize,
UniStrfmon returns the number of code elements placed into the array pointed to by ucs, not including the null
terminating code element.
</dl>
<p><strong>Remarks</strong> </p>
<p>The locale may be specified as NULL to indicate C locale.</p>
<p>UniStrfmon places characters into the array pointed to by ucs as controlled by the string pointed to by format. No more
than maxsize code elements are placed into the array. The character string format contains two types of objects: plain
characters, which are copied to the output stream, and directives, each of which results in the fetching of zero or more
converted and formatted arguments. The results are unpredictable if there are insufficient arguments for the format. If the
format is exhausted while arguments remain, the excess arguments are ignored. A directive consists of a % character,
optional conversion specifications, and a terminating character that determines the directive's behavior. </p>
<p>UniStrfmon converts numeric values to monetary strings, according to the specifications in the format parameter. This
parameter also contains numeric values to be converted. Characters are placed into this ucs array, as controlled by the
format parameter. The LC_MONETARY category governs the format of the conversion. </p>
<p>UniStrfmon can be called multiple times by including additional format structures, as specified by the format parameter. </p>
<p>The format parameter specifies a character string that can contain plain characters and conversion specifications. Plain
characters are copied to the output stream. Conversion specifications result in the fetching of zero or more arguments, which
are converted and formatted. </p>
<p>If there are insufficient arguments for the format parameter, the results are undefined. If arguments remain after the format
parameter is exhausted, the excess arguments are ignored. </p>
<p>A conversion specification sequence consists of a % (percent) sign, optional flags, optional field width, optional left
precision, optional right precision, and a required conversion character that determine the conversion to be performed. </p>
<p>One or more of the following flags can be specified to control the conversion:
<dl>
<dt><b>=f </b>
<dd>An = (equals sign) followed by a single character <i>f</i> that specifies the numeric fill character. The default numeric fill
character is the space character. This flag does not affect field width filling, which always uses the space character.
This flag is ignored unless a left precision is specified. The fill character must be representable in a single byte in order
to work with precision and width counts.
<dt><b>^ </b>
<dd>Do not format the currency amount with grouping characters. The default is to insert grouping characters if they are
defined for the current locale.
<dt><b>+or( </b>
<dd>Determines the representation of positive and negative currency amounts. Only one of these flags may be specified.
The locale's equivalent of + and - are used if + is specified. The locale's equivalent of enclosing negative amounts
within parentheses is used if ( is specified. If neither flag is included, the + style is used.
<dt><b>! </b>
<dd>Suppresses the currency symbol from the output conversion.
<dt><b>- </b>
<dd>Specifies the alignment. If this flag is present, all fields are left-justified (padded to the right) rather than right-justified.
</dl>
<p><b>FIELD WIDTH</b>
<dl>
<dt><b>w </b>
<dd>The decimal-digit string, w, specifies the minimum field width in which the result of the conversion is right-justified (or
left-justified if the - flag is specified). The default is zero.
</dl>
<p><b>LEFT PRECISION</b>
<dl>
<dt><b>#n </b>
<dd>A # (pound sign) followed by a decimal-digit string, n, specifies the maximum number of digits to be formatted to the
left of the radix character. This option can be specified to keep formatted output from multiple calls to UniStrfmon
aligned in the same columns. It can also be used to fill unused positions with a special character (for example,
$***123.45). This option causes an amount to be formatted as if it has the number of digits specified by the n
variable. If more than n digit positions are required, this option is ignored. Digit positions in excess of those required
are filled with the numeric fill character set with the =f flag.
<p>If defined for the current locale and not suppressed with the ^ flag, grouping separators are inserted before the fill
characters (if any) are added. Grouping separators are not applied to fill characters even if the fill character is a digit. </p>
</dl>
<p><b>RIGHT PRECISION</b>
<dl>
<dt><b>.p </b>
<dd>A .(period) followed by a decimal-digit string, p, specifies the number of digits after the radix character. If the value
of the p variable is 0, no radix character is used. If a right precision is not specified, a default specified by the current
locale is used. The amount being formatted is rounded to the specified number of digits prior to formatting.
</dl>
<p><b>CONVERSION CHARACTERS </b>
<ul><dl>
<dt><b>i </b>
<dd>The double argument is formatted according to the current locale's international currency format; for example,
in the U.S.: USD 1,234.56.
<dt><b>n </b>
<dd>The double argument is formatted according to the current locale's national currency format; for example, in
the U.S.: $1,234.56.
<dt><b>% </b>
<dd>Convert to a %; no argument is converted. The entire conversion specification must be %%.
</dl>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50147" name="ToC_309">UniStrftime</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a monetary value to a Unicode string using
the specified locale object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
UniChar      ucs[20];
int          max_size = 20;
int          elements;
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* elements contains number of code elements placed into ucs */
         elements = UniStrfmon(locale_object, ucs,
                               max_size, (UniChar *)L&quot;%n&quot;, 123.45);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_38" name="LENSM50147">UniStrftime</a></h2>
<p>UniStrftime formats date and time. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;
#include &lt;time.h&gt;</pre>
<dl>
<dt><b>size_t UniStrftime </b>
<dd><b>(const localeObject&nbsp;locale_object, UniChar&nbsp;*ucs, size_t&nbsp;maxsize, const UniChar&nbsp;*format, const struct
tm&nbsp;*timeptr)</b>
<dd>&nbsp;
</dl>
<p><hr></p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const localeObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject <a name="SPTSP50567">&nbsp;</a>
<dd>&nbsp;
<dt>ucs &nbsp;(UniChar *)&nbsp;
<dd>Target string. <a name="SPTSP50568">&nbsp;</a>
</dl>
<dl>
<dt>maxsize &nbsp;(size_t)&nbsp;
<dd>Maximum number of characters to be placed in ucs. <a name="SPTSP50569">&nbsp;</a>
<dd>&nbsp;
<dt>format &nbsp;(const UniChar *)&nbsp;
<dd>Format of the target string. <a name="SPTSP50570">&nbsp;</a>
<dd>&nbsp;
<dt>timeptr &nbsp;(const struct tm *)&nbsp;
<dd>Structure containing time and date information.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50571">&nbsp;</a>
<dl>
<dt>return value &nbsp;(size_t)&nbsp; -&nbsp; returns&nbsp;
<dd>If the total number of resulting code elements, including the null code element, is not more than maxsize, the number
of code elements placed into the memory location addressed by ucs (not including the null code element) is returned.
Otherwise, zero is returned and the contents of the memory location are indeterminate.
</dl>
<p><strong>Remarks</strong> </p>
<p>Convert the internal time and date specification into a character string and place the results in the area pointed to by ucs
under the direction of format. The null-terminated result of, at most, maxsize code elements, is placed in the memory
location addressed by ucs. The format string may contain conversion specification characters and characters that are placed
unchanged into the array. The characters that are converted are determined by the LC_TIME category of the locale
indicated by the locale object handle argument locale_object and by the values in the time structure pointed to by timeptr.
The results are unpredictable when objects being copied overlap. </p>
<p>The <b>format</b> parameter is a character string containing two types of objects: plain characters that are simply placed in the
output string and conversion specifications that convert information from the <b>timeptr</b> parameter into readable form in the
output string. </p>
<ul><p>A % (percent sign) introduces a conversion specification. </p>
<p>The type of conversion is specified by one or two conversion characters. The characters and their meanings are:
<dl>
<dt><b>%a</b>
<dd>Represents the locale's abbreviated weekday name (for example, Sun).
<dt><b>%A</b>
<dd>Represents the locale's full weekday name (for example, Sunday).
<dt><b>%b</b>
<dd>Represents the locale's abbreviated month name (for example, Jan).
<dt><b>%B</b>
<dd>Represents the locale's full month name (for example, January).
<dt><b>%c</b>
<dd>Represents the locale's date and time format.
<dt><b>%C</b>
<dd>Represents the century as a decimal number (00-99).
<dt><b>%d</b>
<dd>Represents the day of the month as a decimal number (01 to 31).
<dt><b>%D</b>
<dd>Represents the date in %m/%d/%y format (for example, 01/31/94).
<dt><b>%e</b>
<dd>Represents the day of the month as a decimal number ( 1 to 31). A single digit is preceded by a space
character.
<dt><b>%h</b>
<dd>Same as %b.
<dt><b>%H</b>
<dd>Represents the 24-hour-clock hour as a decimal number (00 to 23).
<dt><b>%I</b>
<dd>Represents the 12-hour-clock hour as a decimal number (01 to 12).
<dt><b>%j</b>
<dd>Represents the day of the year as a decimal number (001 to 366).
<dt><b>%m</b>
<dd>Represents the month of the year as a decimal number (01 to 12).
<dt><b>%M</b>
<dd>Represents the minute of the hour as a decimal number (00 to 59).
<dt><b>%n</b>
<dd>Specifies a new-line character.
<dt><b>%p</b>
<dd>Represents the locale's AM or PM string.
<dt><b>%r</b>
<dd>Represents the time with AM/PM notation (%I:%M:%S%p).
<dt><b>%R</b>
<dd>Represents 24-hour-clock time in the format %H:%M.
<dt><b>%S</b>
<dd>Represents the second of the minute as a decimal number (00 to 61).
<dt><b>%t</b>
<dd>Specifies a tab character.
<dt><b>%T</b>
<dd>Represents the time in the format %H:%M:%S.
<dt><b>%u</b>
<dd>Represents the day of the week as a decimal number (1 to 7). 1 represents Monday.
<dt><b>%U</b>
<dd>Represents the week of the year as a decimal number (00 to 53). Sunday is considered the first day of the
week.
<dt><b>%V</b>
<dd>Represents the week of the year as a decimal number (01 to 53). Monday is considered the first day of the
week. If the week containing 1 January has four or more days in the new year, then it is considered week 1;
otherwise, it is week 53 of the previous year, and the next week is week 1.
<dt><b>%w</b>
<dd>Represents the day of the week as a decimal number (0 to 6). 0 represents Sunday.
<dt><b>%W</b>
<dd>Represents the week of the year as a decimal number (00 to 53). Monday is considered the first day of the
week. All days in a new year preceding the first Sunday are considered to be week 0.
<dt><b>%x</b>
<dd>Represents the locale's date format.
<dt><b>%X</b>
<dd>Represents the locale's time format.
<dt><b>%y</b>
<dd>Represents the year of the century (00 to 99).
<dt><b>%Y</b>
<dd>Represents the year with century as a decimal number for example (1994).
<dt><b>%Z</b>
<dd>Represents the time-zone name or abbreviation if one can be determined (for example EST). Replaced by no
bytes if time zone information does not exist.
<dt><b>%%</b>
<dd>Specifies a % (percent) sign.
</dl>
</ul>
<p>Some conversion specifiers can be modified by the E or O modifier characters to indicate that an alternative format or
specification should be used rather than the one normally used by the unmodified conversion specifier. If the alternative
format or specification does not exist for the current locale, the behavior will be as if the unmodified conversion specification
were used.
<ul><dl>
<dt><b>%Ec </b>
<dd>Locale's alternative appropriate date and time representation.
<dt><b>%EC </b>
<dd>is the name of the base year (period) in the locale's alternative representation.
<dt><b>%Ex </b>
<dd>is the locale's alternative date representation.
<dt><b>%EX </b>
<dd>is the locale's alternative time representation.
<dt><b>%Ey </b>
<dd>is the offset from %EC (year only) in the locale's alternative representation.
<dt><b>%EY </b>
<dd>is the full alternative year representation.
<dt><b>%Od </b>
<dd>is the day of the month using the locale's alternative numeric symbols; filled as needed with leading zeros if
there is any alternative symbol for zero, otherwise with leading spaces.
<dt><b>%Oe </b>
<dd>is replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading
spaces.
<dt><b>%OH </b>
<dd>is the hour (24-hour clock) using the locale's alternative numeric symbols.
<dt><b>%OI </b>
<dd>is the hour (12-hour clock) using the locale's alternative numeric symbols.
<dt><b>%Om </b>
<dd>is the month using the locale's alternative numeric symbols.
<dt><b>%OM </b>
<dd>is the minutes using the locale's alternative numeric symbols.
<dt><b>%OS </b>
<dd>is the seconds using the locale's alternative numeric symbols.
<dt><b>%Ou </b>
<dd>is the weekday of the year (Monday = 1) using the locale's alternative numeric symbols.
<dt><b>%OU </b>
<dd>is the week number of the year (Sunday as the first day of the week) using the locale's alternative numeric
symbols.
<dt><b>%OV </b>
<dd>is replaced by the week number of the year (Sunday as the first day of the week) using the locale's alternative
numeric symbols.
<dt><b>%Ow </b>
<dd>is the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
<dt><b>%OW </b>
<dd>is the week number of the year (Monday as the first day of the week) using the locale's alternative numeric
symbols.
<dt><b>%Oy </b>
<dd>is the year (offset from %C) in the locale's alternative representation and using the locale's alternative numeric
symbols.
</dl>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50146" name="ToC_309">UniStrfmon</a>
<li><a href="#LENSM50155">UniStrptime</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a date and time to a Unicode string using
the specified locale object.
#include &lt;stdio.h&gt;<br>
#include &lt;time.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
struct tm    *ptime;
time_t       time_date;
UniChar      ucs[30];
int          max_size = 30;
int          elements;
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         time_date = time(NULL);
         ptime = localtime(&amp;time_date);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* elements contains number of code elements placed into ucs */
         elements = UniStrftime(locale_object, ucs,
                               max_size, (UniChar *)L&quot;%a %b %d\n %I:%M %p&quot;,
                               ptime);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_39" name="LENSM50148">UniStrlen</a></h2>
<p>UniStrlen determines code element count. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>size_t UniStrlen </b>
<dd><b>(const UniChar&nbsp;*ucs)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs &nbsp;(const UniChar *)&nbsp;
<dd>A null-terminated string composed of UniChar code elements.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(size_t)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrlen returns the number of code elements that precede the terminating null code element.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrlen computes the length of the code element string pointed to by ucs. </p>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to determine the code element count of a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
int   elements;
         /* elements contains number of code elements in the Unicode string */
         elements = UniStrlen((UniChar *)L&quot;program&quot;);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_40" name="LENSM50149">UniStrlwr</a></h2>
<p>UniStrlwr converts a Unicode string to lowercase according to the language neutral case mapping tables. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar *UniStrlwr </b>
<dd><b>(UniChar&nbsp;*ucsUniStringIn)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50574">&nbsp;</a>
<dl>
<dt>ucsUniStringIn &nbsp;(UniChar *)&nbsp; -&nbsp; input&nbsp;
<dd>Unicode string to be mapped to lowercase.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>ucsUniStringOut &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>Converted lowercase string.
</dl>
<p><strong>Remarks</strong> </p>
<p>The input string must be null-terminated. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50163" name="ToC_163">UniStrupr</a>
<li><a href="#LENSM50166" name="ToC_166">UniTolower</a>
<li><a href="#LENSM50167" name="ToC_167">UniToupper</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to lowercase.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar   *plwr_unistr;
         /* plwr_unistr points to the converted lowercase Unicode string */
         plwr_unistr = UniStrlwr((UniChar *)L&quot;IBM&quot;);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_41" name="LENSM50150">UniStrncat</a></h2>
<p>UniStrncat concatenates a specific number of code elements. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrncat </b>
<dd><b>(UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2, size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50576">&nbsp;</a>
<dl>
<dt>ucs1 &nbsp;(UniChar *)&nbsp;
<dd>String to be appended to. <a name="SPTSP50577">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String to concatenate. <a name="SPTSP50578">&nbsp;</a>
<dd>&nbsp;
<dt>n &nbsp;(size_t)&nbsp;
<dd>Number of elements in ucs2 to concatenate.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>Concatenated string.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrncat appends not more than n code elements (a null code element and code elements that follow it are not appended)
from the code element array pointed to by ucs2 to the end of the code element string pointed to by ucs1. The initial code
element of ucs2 overwrites the null code element at the end of ucs1. A terminating null code element is always appended to
the result. If copying takes place between objects that overlap, the results are unpredictable. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50139" name="ToC_309">UniStrcat</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to concatenate a specific number of code
elements onto a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[40] = L&quot;computer&quot;;<br>
size_t     num_elems = 3;
         UniStrncat(ucs1, (UniChar *)L&quot; program&quot;, num_elems);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_42" name="LENSM50151">UniStrncmp</a></h2>
<p>UniStrncmp compares a specific number of code elements. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrncmp </b>
<dd><b>(const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2, size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>String to compare. <a name="SPTSP50581">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String to compare. <a name="SPTSP50582">&nbsp;</a>
<dd>&nbsp;
<dt>n &nbsp;(size_t)&nbsp;
<dd>Number of code elements to compare.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50583">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrncmp returns an integer greater than, equal to, or less than zero. The integer returned depends on whether the
possibly null-terminated code element array pointed to by ucs1 is greater than, equal to, or less than the possibly
null-terminated code element array pointed to by ucs2.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrncmp compares not more than <i>n</i> code elements (code elements that follow a NULL code element are not compared)
from the code element array pointed to by ucs1 to the code element array pointed to by ucs2. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50141" name="ToC_309">UniStrcmp</a>
<li><a href="#LENSM50142" name="ToC_309">UniStrcmpi</a>
<li><a href="#LENSM50152" name="ToC_309">UniStrncmpi</a>
</ul>
<p>&nbsp;</p>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to compare a specific number of code
elements.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[] = L&quot;computer program&quot;;
size_t     num_elems = 3;
int        result = 0;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = UniStrncmp(ucs1, ucs2, num_elems);
         if ( result == 0 )
             printf(&quot;The strings are identical\n&quot;);
         else
             printf(&quot;The strings are not identical\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_43" name="LENSM50152">UniStrncmpi</a></h2>
<p>UniStrncmpi compares one or more code elements of strings without sensitivity to case. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrncmpi </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2, const size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A valid locale object created by a call to UniCreateLocaleObject or NULL. <a name="SPTSP50585">&nbsp;</a>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>A null-terminated UniChar string to be compared. <a name="SPTSP50586">&nbsp;</a>
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>A null terminated UniChar string to be compared. <a name="SPTSP50587">&nbsp;</a>
<dt>n &nbsp;(const size_t)&nbsp;
<dd>The maximum number of code elements to compare.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dl>
<dt><b>less than 0 </b>
<dd>ucs1 less than ucs2
<dt><b>0 </b>
<dd>ucs1 equivalent to ucs2
<dt><b>Greater than 0 </b>
<dd>ucs1 greater than ucs
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrncmpi compares ucs1 and ucs2 without sensitivity to case. All <i>n</i> code elements are converted to lowercase before the
comparison. The locale object is used to convert the characters to lowercase. A maximum of <i>n</i> code elements are
compared.
The locale may be specified as NULL to indicate Unicode casing.</p>
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50141" name="ToC_309">UniStrcmp</a>
<li><a href="#LENSM50142">UniStrcmpi</a>
<li><a href="#LENSM50152">UniStrncmp</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to compare a specific number of code
elements without sensitivity to case.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject  locale_object;
UniChar       ucs1[] = L&quot;COMPUTER&quot;;
UniChar       ucs2[] = L&quot;computer program&quot;;
size_t        num_elems = 3;
int           result = 0;
int           rc;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         result = UniStrncmpi(locale_object, ucs1, ucs2, num_elems);
         if ( result == 0 )
             printf(&quot;The strings are identical\n&quot;);
         else
             printf(&quot;The strings are not identical\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_44" name="LENSM50153">UniStrncpy</a></h2>
<p>UniStrncpy copies a specific number of code elements. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrncpy </b>
<dd><b>(UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2, size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs1 &nbsp;(UniChar *)&nbsp;
<dd>Target string. <a name="SPTSP50590">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>Source string. <a name="SPTSP50591">&nbsp;</a>
<dd>&nbsp;
<dt>n &nbsp;(size_t)&nbsp;
<dd>Number of elements in ucs2 to copy.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrncpy returns ucs1.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrncpy copies not more than n code elements (code elements that follow a null code element are not copied) from the
code element array pointed to by ucs2 to the code element array pointed to by ucs1. If copying takes place between
objects that overlap, the results are unpredictable. If the code element array pointed to by ucs2 is a code element string that
is shorter than <i>n</i> code elements, null code elements are appended to the copy in the code element array pointed to by ucs1,
until <i>n</i> code elements, in all, have been written. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50144" name="ToC_309">UniStrcpy</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to copy a specific number of code
elements in a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[10];<br>
UniChar    *puni;<br>
size_t     num_elems = 4;
         puni = UniStrncpy(ucs2, ucs1, num_elems);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_45" name="LENSM50154">UniStrpbrk</a></h2>
<p>UniStrpbrk locates code elements in a code element string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrpbrk </b>
<dd><b>(const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>String to be searched. <a name="SPTSP50594">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String to search for.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50595">&nbsp;</a>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrpbrk returns a pointer to the code element or a null pointer, if the code element from the code element string
from ucs2, does not occur in ucs1.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrpbrk locates the first occurrence, in the string pointed to by ucs1, of any code element from the code element string
pointed to by ucs2. <strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50158" name="ToC_309">UniStrstr</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to locate code elements in a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[] = L&quot;put&quot;;<br>
UniChar    *puni;
         puni = UniStrpbrk(ucs1, ucs2);
         if (puni)
             printf(&quot;The sub string was found\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_46" name="LENSM50155">UniStrptime</a></h2>
<p>UniStrptime converts date and time. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;
#include &lt;time.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrptime </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*buf, const UniChar&nbsp;*fmt, struct tm&nbsp;*tm)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject. <a name="SPTSP50597">&nbsp;</a>
<dd>&nbsp;
<dt>buf &nbsp;(const UniChar *)&nbsp;
<dd>String to be converted. <a name="SPTSP50598">&nbsp;</a>
<dd>&nbsp;
<dt>fmt &nbsp;(const UniChar *)&nbsp;
<dd>Format of the source string. <a name="SPTSP50599">&nbsp;</a>
<dd>&nbsp;
<dt>tm &nbsp;(struct tm *)&nbsp;
<dd>Time/data structure to receive the time/data information held in the string buf.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50600">&nbsp;</a>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>Returns a pointer to the character following the last character; otherwise, a NULL pointer is returned and the
contents of the tm structure are undefined.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrptime converts the character string pointed to by buf to a time value, which is stored in the structure pointed to by tm,
using the format specified by fmt. A pointer to the character following the last character in the string pointed to by buf is
returned. The character string pointed to by fmt consists of field descriptors and text characters, similar to the scanf. Each
field descriptor consists of a % character followed by another character that specifies the replacement for the field
descriptor. The type of conversion is specified by one or two conversion characters. The characters and their meanings are
specified in the <b>Format Strings</b> and <b>Modified Directives</b> sections. </p>
<ul><p><b>FORMAT STRINGS</b>
<dl>
<dt><b>%a</b>
<dd>Day of the week, abbreviated or full name may be specified (for example Sun).
<dt><b>%A</b>
<dd>Same as %a.
<dt><b>%b</b>
<dd>Represents the locale's month name, abbreviated or fullname may be specified.
<dt><b>%B</b>
<dd>Same as %b.
<dt><b>%c</b>
<dd>Represents the locale's date and time format.
<dt><b>%C</b>
<dd>Represents the century number (0 to 99).
<dt><b>%d</b>
<dd>Represents the day of the month as a decimal number (01 to 31).
<dt><b>%D</b>
<dd>Represents the date in %m/%d/%y format (for example, 01/31/91).
<dt><b>%e</b>
<dd>Same as %d.
<dt><b>%h</b>
<dd>Same as %b.
<dt><b>%H</b>
<dd>Represents the 24-hour-clock hour as a decimal number (00 to 23).
<dt><b>%I</b>
<dd>Represents the 12-hour-clock hour as a decimal number (01 to 12).
<dt><b>%j</b>
<dd>Represents the day of the year as a decimal number (001 to 366).
<dt><b>%m</b>
<dd>Represents the month of the year as a decimal number (01 to 12).
<dt><b>%M</b>
<dd>Represents the minute of the hour as a decimal number (00 to 59).
<dt><b>%n</b>
<dd>Represents any white space.
<dt><b>%p</b>
<dd>Represents the locale's AM or PM string.
<dt><b>%r</b>
<dd>Represents the time as %I:%M:%S%p.
<dt><b>%R</b>
<dd>Represents the time as %H:%M.
<dt><b>%S</b>
<dd>Represents the second of the minute as a decimal number (00 to 61).
<dt><b>%t</b>
<dd>Represents any white space.
<dt><b>%T</b>
<dd>Represents time in the format %H:%M:%S.
<dt><b>%U</b>
<dd>Represents the week of the year as a decimal number (00 to 53). Sunday is considered the first day of the
week.
<dt><b>%w</b>
<dd>Represents the day of the week as a decimal number (0 to 6). Sunday is considered as 0.
<dt><b>%W</b>
<dd>Represents the week of the year as a decimal number (00 to 53). Monday is considered the first day of the
week.
<dt><b>%x</b>
<dd>Represents the locale's date format.
<dt><b>%X</b>
<dd>Represents the locale's time format.
<dt><b>%y</b>
<dd>Represents the year of the century (00 to 99).
<dt><b>%Y</b>
<dd>Represents the year with century as a decimal number (for example 1994).
<dt><b>%%</b>
<dd>Specifies a % (percent) sign.
</dl>
</ul>
<p><b>MODIFIED DIRECTIVES</b> </p>
<p>Some directives can be modified by the E and O modifier characters to indicate that an alternative format or specification
should be used rather than the one normally used by the unmodified directive. If the alternative format or specification does
not exist in the current locale, the behavior will be as if the unmodified directive were used.
<ul><dl>
<dt><b>%Ec </b>
<dd>is the locale's alternative appropriate date and time representation.
<dt><b>%EC </b>
<dd>is the name of the base year (period) in the locale's alternative representation.
<dt><b>%Ex </b>
<dd>is the locale's alternative date representation.
<dt><b>%EX </b>
<dd>is the locale's alternative time representation.
<dt><b>%Ey </b>
<dd>is the offset from %EC (year only) in the locale's alternative representation.
<dt><b>%EY </b>
<dd>is the full alternative year representation.
<dt><b>%Od </b>
<dd>is the day of the month using the locale's alternative numeric symbols; leading zeros are permitted but not
required.
<dt><b>%Oe </b>
<dd>is the same as %Od.
<dt><b>%OH </b>
<dd>is the hour (24-hour clock) using the locale's alternative numeric symbols.
<dt><b>%OI </b>
<dd>is the hour (12-hour clock) using the locale's alternative numeric symbols.
<dt><b>%Om </b>
<dd>is the month using the locale's alternative numeric symbols.
<dt><b>%OM </b>
<dd>is the minutes using the locale's alternative numeric symbols.
<dt><b>%OS </b>
<dd>is the seconds using the locale's alternative numeric symbols.
<dt><b>%OU </b>
<dd>is the week number of the year (Sunday as the first day of the week) using the locale's alternative numeric
symbols.
<dt><b>%Ow </b>
<dd>is the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
<dt><b>%OW </b>
<dd>is the week number of the year (Monday as the first day of the week) using the locale's alternative numeric
symbols.
<dt><b>%Oy </b>
<dd>is the year (offset from %C) in the locale's alternative representation and using the locale's alternative numeric
symbols.
</dl>
<p>A format specification consisting of white-space characters is performed by reading input until the first
nonwhite-space character (which is not read) or no more characters can be read. </p>
<p>A format specification consisting of an ordinary character is performed by reading the next character from the string
parameter. If this character differs from the character comprising the directive, the directive fails and the differing
character and any characters following it remain unread. Case is ignored when matching string items, such as month
or weekday names.</p>
</ul>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50147" name="ToC_309">UniStrftime</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a time date string to a time structure.
#include &lt;stdio.h&gt;<br>
#include &lt;time.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject  locale_object;
UniChar       uni_fmt[] = L&quot;%A %b %d %r %Y&quot;;
UniChar       uni_time_str[] = L&quot;Wednesday Oct 23 03:07:00 PM 1995&quot;;
UniChar       *puni;
struct tm     convrt_time;
int           rc;
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;en_US&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         puni = UniStrptime(locale_object, uni_time_str, uni_fmt,
                           &amp;convrt_time);
         if ( puni == NULL ) {
             printf(&quot;UniStrptime error\n&quot;);
             return (1);
         }
         else
             return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_47" name="LENSM50156">UniStrrchr</a></h2>
<p>UniStrrchr locates last occurrence of code element. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrrchr </b>
<dd><b>(const UniChar&nbsp;*ucs, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50601">&nbsp;</a>
<dl>
<dt>ucs &nbsp;(const UniChar *)&nbsp;
<dd>String to be searched. <a name="SPTSP50602">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>UniChar code element to search for.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50603">&nbsp;</a>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrrchr returns either a pointer to the found code element or a null pointer, if uc does not occur in the code
element string.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrrchr locates the last occurrence of uc in the code element string pointed to by ucs. The terminating null code element
is considered to be part of the string. </p>
<p><strong>Related Functions </strong>
<ul type="disc">
<li><a href="#LENSM50140" name="ToC_309">UniStrchr</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to locate the last occurrence of a code element
in a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs[] = L&quot;computer&quot;;<br>
UniChar    uc = L't';<br>
UniChar    *puni;
         puni = UniStrrchr(ucs, uc);
         if (puni)
             printf(&quot;The character is contained in the string\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_48" name="LENSM50157">UniStrspn</a></h2>
<p>UniStrspn determines the number of code elements in a segment. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>size_t UniStrspn </b>
<dd><b>(const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>String to be searched. <a name="SPTSP50605">&nbsp;</a>
<dd>&nbsp;
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String of code elements to search for.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50606">&nbsp;</a>
<dl>
<dt>return value &nbsp;(size_t)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrspn returns the length of the segment.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrspn computes the length of the maximum initial segment of the code element string pointed to by ucs1, which consists
entirely of code elements from the code element string pointed to by ucs2. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50145" name="ToC_309">UniStrcspn</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to determine the number of elements in a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[] = L&quot;omc&quot;;<br>
size_t     num_elems = 0;
         num_elems = UniStrspn(ucs1, ucs2);
         if (num_elems)
             printf(&quot;The first %d characters were found\n&quot;, num_elems);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_49" name="LENSM50158">UniStrstr</a></h2>
<p>UniStrstr locates a code element sequence. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar * UniStrstr </b>
<dd><b>(const UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucs1 &nbsp;(const UniChar *)&nbsp;
<dd>String to be searched. <a name="SPTSP50608">&nbsp;</a>
<dt>ucs2 &nbsp;(const UniChar *)&nbsp;
<dd>String of code elements to search for.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrstr returns either a pointer to the located code element string or a null pointer, if the string is not found.
<p>If ucs2 points to a code element string with zero length, the function returns ucs1. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrstr locates the first occurrence, in the code element string pointed to by ucs1 of the sequence of code elements
(excluding the ending null code element), in the code element string pointed to by ucs2. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50154" name="ToC_309">UniStrpbrk</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to locate a code element sequence in a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs1[] = L&quot;computer&quot;;<br>
UniChar    ucs2[] = L&quot;put&quot;;<br>
UniChar    *puni;
         puni = UniStrstr(ucs1, ucs2);
         if (puni)
             printf(&quot;The code element sequence was found\n&quot;);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_50" name="LENSM50159">UniStrtod</a></h2>
<p>UniStrtod converts character string to double-precision floating point. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrtod </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*nptr, UniChar&nbsp;**endptr, double&nbsp;*result)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateObject. <a name="SPTSP50611">&nbsp;</a>
<dd>&nbsp;
<dt>nptr &nbsp;(const UniChar *)&nbsp;
<dd>String to be converted. <a name="SPTSP50612">&nbsp;</a>
<dd>&nbsp;
<dt>endptr &nbsp;(UniChar **)&nbsp;
<dd>A pointer to the first UniChar that is not recognized as being part of a number. <a name="SPTSP50613">&nbsp;</a>
<dd>&nbsp;
<dt>result &nbsp;(double *)&nbsp;
<dd>Resulting double-precision floating-point number.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50614">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniStrtod returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The function was successful.
<dt><b>ULS_BADOBJ </b>
<dd>Invalid locale object specified.
<dt><b>ULS_INVALID </b>
<dd>The endptr or result argument contains an invalid pointer value. The reliable detection of this error is
implementation dependent.
<dt><b>ULS_RANGE </b>
<dd>The conversion resulted in an out-of-range condition.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrtod converts the initial portion of the string pointed to by nptr to double-precision floating-point representation. First,
it decomposes the input string into three parts:
<ol>
<li>An initial, possibly empty, sequence of white-space characters (as indicated by the space attribute).
<li>A subject sequence resembling a floating-point constant.
<li>A final string of one or more unrecognized characters, including the terminating null character of the input string.
</ol>
<p>Then, it attempts to convert the subject sequence to a floating-point number, and returns the result in the area pointed to by
result. A pointer to the final string is stored in the object pointed to by endptr, provided that endptr is not a null pointer. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50160" name="ToC_309">UniStrtol</a>
<li><a href="#LENSM50161">UniStrtok</a>
<li><a href="#LENSM50162">UniStrtoul</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to a double precision
floating point number.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject  locale_object;
UniChar       uni_string[] = L&quot;3.1415926This stopped it&quot;;
UniChar       *uni_stop_string;
double        double_num;
int           rc;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniStrtod(locale_object, uni_string, &amp;uni_stop_string,
                        &amp;double_num);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniStrtod error: return code = %u\n&quot;, rc);
           return 1;
         }
         else {
           printf(&quot;The double precision number is %f\n&quot;, double_num);
           return (ULS_SUCCESS);
         }</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_51" name="LENSM50160">UniStrtol</a></h2>
<p>UniStrtol converts a character string to a long integer. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrtol </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*nptr, UniChar&nbsp;**endptr, int&nbsp;base, long int&nbsp;*result)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50615">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50616">&nbsp;</a>
<dd>&nbsp;
<dt>nptr &nbsp;(const UniChar *)&nbsp;
<dd>String to be converted. <a name="SPTSP50617">&nbsp;</a>
<dd>&nbsp;
<dt>endptr &nbsp;(UniChar **)&nbsp;
<dd>A pointer to the first UniChar that is not recognized as being part of a number. <a name="SPTSP50618">&nbsp;</a>
<dd>&nbsp;
<dt>base &nbsp;(int)&nbsp;
<dd>The radix used to perform conversion. <a name="SPTSP50619">&nbsp;</a>
<dd>&nbsp;
<dt>result &nbsp;(long int *)&nbsp;
<dd>The resulting integer.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50620">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniStrtol returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The function was successful.
<dt><b>ULS_BADOBJ </b>
<dd>Invalid locale object specified.
<dt><b>ULS_INVALID </b>
<dd>The endptr or result argument contains an invalid pointer value. The reliable detection of this error is
implementation-dependent.
<dt><b>ULS_RANGE </b>
<dd>The conversion resulted in an out-of-range condition.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>The locale may be specified as NULL to indicate C locale.</p>
<p>UniStrtol converts the initial portion of the string pointed to by nptr to long int representation. First, it decomposes the input
string into three parts:
<ol>
<li>An initial, possibly empty, sequence of white-space characters (as indicated by the space attribute).
<li>A subject sequence, resembling an integer, that is represented in the radix and determined by the value of base.
<li>A final string of one or more unrecognized characters, including the ending null character of the input string.
</ol>
<p>Then, it attempts to convert the subject sequence to an unsigned integer, and returns the result in the area pointed to by
result. A pointer to the final string is stored in the object pointed to by endptr, provided that endptr is not a null pointer. </p>
<p>If the value of base is between 2 and 36, the letters a (or A) to z (or Z), inclusive, are ascribed the values 10 to 35. Only
letters whose ascribed value is less than base are permitted. </p>
<p>If base is set to 0, the expected form of the subject sequence is a decimal, octal, or hexadecimal constant. Decimal
constants begin with a nonzero digit. Octal constants begin with 0. Hexadecimal constants begin with 0x or 0X. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50159" name="ToC_309">UniStrtod</a>
<li><a href="#LENSM50161">UniStrtok</a>
<li><a href="#LENSM50162">UniStrtoul</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to a long integer.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject  locale_object;
UniChar       uni_string[] = L&quot;110134932&quot;;
UniChar       *uni_stop_string;
long int      long_num;
int           rc;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniStrtol(locale_object, uni_string, &amp;uni_stop_string,
                        10, &amp;long_num);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniStrtol error: return code = %u\n&quot;, rc);
           return 1;
         }
         else {
           printf(&quot;The long integer is %ld\n&quot;, long_num);
           return (ULS_SUCCESS);
         }</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_52" name="LENSM50161">UniStrtok</a></h2>
<p>UniStrtok converts a Unicode string to tokens. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar *UniStrtok </b>
<dd><b>(UniChar&nbsp;*ucsString1, const UniChar&nbsp;*ucsString2)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucsString1 &nbsp;(UniChar *)&nbsp; -&nbsp; input&nbsp;
<dd>Unicode string containing zero or more tokens.
<p>ucsString1 is a string of zero or more tokens. The tokens in ucsString1 can be separated by one or more of the
delimiters in ucsString2. UniStrtok does not support the passing of NULL for ucsString1 parameter as is supported in
the ANSI C strtok function.</p>
<p><a name="SPTSP50622">&nbsp;</a>
<dt>ucsString2 &nbsp;(const UniChar *)&nbsp; -&nbsp; input&nbsp;
<dd>Set of UniChar characters that can be used as delimiters.
<p>ucsString2 is the set of characters serving as delimiters of the tokens in ucsString1. </p>
</dl>
<p><strong>Returns</strong> <a name="SPTSP50623">&nbsp;</a>
<dl>
<dt>ucsToken &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>Pointer to the first token.
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrtok will return the first token in the string specified in ucsString1. UniStrtok replaces the delimiter character with
0x0000 and returns a pointer to the token. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50159" name="ToC_40">UniStrtod</a>
<li><a href="#LENSM501160" name="ToC_163">UniStrtol</a>
<li><a href="#LENSM50162">UniStrtoul</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to tokens.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    *uni_string = L&quot;a string, of, ,tokens&quot;;
UniChar    *puni_token;
int        uni_len1;
int        uni_len2;
int        token_count = 0;
         uni_len1 = UniStrlen(uni_string);
         puni_token = UniStrtok(uni_string, (UniChar *)L&quot;,&quot;);
         ++token_count;
         /* Continue to loop through the string looking for tokens */
         do
         {
            uni_len2 = UniStrlen(puni_token) + 1;
            puni_token += uni_len2;
            if(puni_token &lt; uni_string + uni_len1)
            {
               puni_token = UniStrtok(puni_token, (UniChar *)L&quot;,&quot;);
               ++token_count;
            }
            else
               break;
         } while (1);
         printf(&quot;%d tokens were found\n&quot;, token_count);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_53" name="LENSM50162">UniStrtoul</a></h2>
<p>UniStrtoul converts a character string to an unsigned long integer. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniStrtoul </b>
<dd><b>(const LocaleObject&nbsp;locale_object, const UniChar&nbsp;*nptr, UniChar&nbsp;**endptr, int&nbsp;base, unsigned long
int&nbsp;*result)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50625">&nbsp;</a>
<dd>&nbsp;
<dt>nptr &nbsp;(const UniChar *)&nbsp;
<dd>String to be converted. <a name="SPTSP50626">&nbsp;</a>
<dd>&nbsp;
<dt>endptr &nbsp;(UniChar **)&nbsp;
<dd>A pointer to the first UniChar that is not recognized as being part of a number. <a name="SPTSP50627">&nbsp;</a>
<dd>&nbsp;
<dt>base &nbsp;(int)&nbsp;
<dd>The radix used to perform conversion. <a name="SPTSP50628">&nbsp;</a>
<dd>&nbsp;
<dt>result &nbsp;(unsigned long int *)&nbsp;
<dd>The resulting unsigned long integer.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50629">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniStrtoul returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
</dl>
<dl>
<dd>The function was successful.
<dt><b>ULS_BADOBJ </b>
<dd>Invalid locale object specified.
<dt><b>ULS_INVALID </b>
<dd>The endptr or result argument contains an invalid pointer value. The reliable detection of this error is
implementation dependent.
<dt><b>ULS_RANGE </b>
<dd>The conversion resulted in an out-of-range condition.
</dl>
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50159" name="ToC_309">UniStrtod</a>
<li><a href="#LENSM50160">UniStrtol</a>
<li><a href="#LENSM50161">UniStrtok</a>
</ul>
<p><strong>Remarks</strong> </p>
<p>The locale may be specified as NULL to indicate C locale.</p>
<p>UniStrtoul converts the initial portion of the string pointed to by nptr to unsigned long int representation. First, it decomposes
the input string into three parts:
<ul><ol>
<li>An initial, possibly empty, sequence of white-space characters (as indicated by the space attribute).
<li>A subject sequence resembling an unsigned integer represented in some radix determined by the value of base.
<li>A final string of one or more unrecognized characters, including the terminating null character of the input string.
</ol>
<p>Then, it attempts to convert the subject sequence to an unsigned integer, and returns the result in the area pointed to
by result. A pointer to the final string is stored in the object pointed to by endptr, provided that endptr is not a null
pointer. </p>
<p>If the value of base is between 2 and 36, the letters a (or A) to z (or Z) inclusive are ascribed the values 10 to 35.
Only letters whose ascribed value is less than base are permitted. </p>
<p>If base is set to 0, the expected form of the subject sequence is a decimal, octal or hexadecimal constant. Decimal
constants begin with a nonzero digit. Octal constants begin with 0. Hexadecimal constants begin with 0x or 0X. </p>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to an unsigned long integer.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject       locale_object;
UniChar            uni_string[] = L&quot;110134932&quot;;
UniChar            *uni_stop_string;
unsigned long int  long_num;
int                rc;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniStrtoul(locale_object, uni_string, &amp;uni_stop_string,
                        10, &amp;long_num);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniStrtoul error: return code = %u\n&quot;, rc);
           return 1;
         }
         else {
           printf(&quot;The unsigned long integer is %lu\n&quot;, long_num);
           return (ULS_SUCCESS);
         }</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_54" name="LENSM50163">UniStrupr</a></h2>
<p>UniStrupr converts a Unicode string to uppercase according to the language neutral case mapping tables. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar *UniStrupr </b>
<dd><b>(UniChar&nbsp;*ucsUniStringIn)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucsUniStringIn &nbsp;(UniChar *)&nbsp; -&nbsp; input&nbsp;
<dd>Unicode string to be mapped to uppercase.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50631">&nbsp;</a>
<dl>
<dt>ucsUniStringOut &nbsp;(UniChar *)&nbsp; -&nbsp; returns&nbsp;
<dd>Converted uppercase string.
</dl>
<p><strong>Remarks</strong> </p>
<p>The input string must be null-terminated. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50149">UniStrlwr</a>
<li><a href="#LENSM50166" name="ToC_166">UniTolower </a>
<li><a href="#LENSM50167" name="ToC_167">UniToupper</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to uppercase Unicode strings according to the
language neutral case mapping tables.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    ucs[] = L&quot;computer&quot;;<br>
UniChar    *puni;
         puni = UniStrupr(ucs);
         return (ULS_SUCCESS);</pre>
<ul><ul><pre>}</pre>
</ul>
</ul>
<p><hr> </p>
<h2><a href="#ToC_55" name="LENSM50164">UniStrxfrm</a></h2>
<p>UniStrxfrm transforms a character string into collating weights. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>size_t UniStrxfrm </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;*ucs1, const UniChar&nbsp;*ucs2, size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50632">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50633">&nbsp;</a>
<dd>&nbsp;
<dt>ucs1 &nbsp;(UniChar *)&nbsp; -&nbsp; output&nbsp;
<dd>Target transformed string.
<dd><a name="SPTSP50634">&nbsp;</a>
<dt>ucs2 &nbsp;(const UniChar *)&nbsp; -&nbsp; input&nbsp;
<dd>Source string to be transformed. <a name="SPTSP50635">&nbsp;</a>
<dd>&nbsp;
<dt>n &nbsp;(size_t)&nbsp; -&nbsp; input&nbsp;
<dd>Maximum number of code elements to be placed in ucs1.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(size_t)&nbsp; -&nbsp; returns&nbsp;
<p>UniStrxfrm returns the length of the transformed string (not including the terminating null code element). If the value returned
is n or more, the contents of the array pointed to by ucs1 are indeterminate. If ucs1 is a null pointer, UniStrxfrm returns the
number of elements required to contain the transformed character string. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrxfrm transforms the string pointed to by ucs2 to values that represent character collating weights and places the
resulting string into the array pointed to by ucs1. The transformation is such that, if UniStrcmp is applied to two transformed
strings, it returns a value greater than, equal to, or less than 0, corresponding to the result of UniStrcoll applied to the same
two original strings. No more than n elements are placed into the resulting array pointed to by ucs1, including the terminating
null code element. If n is zero, ucs1 is permitted to be a null pointer. If copying takes place between objects that overlap,
the results are unpredictable. </p>
<p>UniStrxfrm is controlled by the LC_COLLATE category of the locale as indicated by the locale object handle argument,
locale_object.
The locale may be specified as NULL to indicate Unicode collation.</p>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to collect character collating weights from Unicode
strings using the specified locale object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;
UniChar      *pucs1;
UniChar      *pucs2 = L&quot;computer&quot;;
int          num_elems = 8;
int          num_elems_trx = 0;
int          result = 0;
int          rc = ULS_SUCCESS;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /********************************************************************/
         /* Calculate the space needed for the collating weights             */
         /********************************************************************/
         num_elems = UniStrxfrm (locale_object, NULL, pucs2, 0);</pre>
<p>pucs1 = (UniChar *) malloc((num_elems + 1) * sizeof(UniChar)); </p>
<pre>         if(!pucs1)
            return 1;
         /********************************************************************/
         /* Obtain the collating weights for the Unicode string.             */
         /* num_elems_trx should be less than num_elems                      */
         /********************************************************************/
         num_elems_trx = UniStrxfrm (locale_object, pucs1,
                                     pucs2, num_elems + 1);
         if(num_elems_trx &gt;= (num_elems + 1)) {
           printf(&quot;UniStrxfrm error:\n&quot;);
           return 1;
         }
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_57" name="LENSM50166">UniTolower</a></h2>
<p>UniTolower converts a Unicode character to lowercase according to the language neutral case mapping tables. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar UniTolower </b>
<dd><b>(UniChar&nbsp;ucUniCharIn)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucUniCharIn &nbsp;(UniChar)&nbsp; -&nbsp; input&nbsp;
<dd>Unicode character to be mapped to lowercase.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50645">&nbsp;</a>
<dl>
<dt>ucUniCharOut &nbsp;(UniChar)&nbsp; -&nbsp; returns&nbsp;
<dd>Converted lowercase character.
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50149" name="ToC_40">UniStrlwr </a>
<li><a href="#LENSM50163" name="ToC_163">UniStrupr</a>
<li><a href="#LENSM50167" name="ToC_167">UniToupper</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode character to lowercase according to the
language neutral case mapping tables.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    uni_upr = L'C';<br>
UniChar    uni_lwr;
         uni_lwr = UniTolower(uni_upr);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_58" name="LENSM50167">UniToupper</a></h2>
<p>UniToupper converts a Unicode character to uppercase according to the language neutral case mapping tables. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar UniToupper </b>
<dd><b>(UniChar&nbsp;ucUniCharIn)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ucUniCharIn &nbsp;(UniChar)&nbsp; -&nbsp; input&nbsp;
<dd>Unicode character to be mapped to uppercase.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>ucUniCharOut &nbsp;(UniChar)&nbsp; -&nbsp; returns&nbsp;
<dd>Converted uppercase character.
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50149" name="ToC_40">UniStrlwr</a>
<li><a href="#LENSM50163" name="ToC_163">UniStrupr</a>
<li><a href="#LENSM50166" name="ToC_166">UniTolower</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode character to uppercase according to the
language neutral case mapping tables.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
UniChar    uni_lwr = L'c';<br>
UniChar    uni_upr;
         uni_upr = UniToupper(uni_lwr);
         return (ULS_SUCCESS);
}</pre>
<p><hr> </p>
<h2><a href="#ToC_59" name="LENSM50168">UniTransformStr</a></h2>
<p>UniTransformStr transforms strings according to a XformObject created by UniCreateTransformObject. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>int UniTransformStr </b>
<dd><b>(XformObject&nbsp;xform_object, const UniChar&nbsp;*InpBuf, int&nbsp;*InpSize, UniChar&nbsp;*OutBuf, int&nbsp;*OutSize)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>xform_object &nbsp;(XformObject)&nbsp;
<dd>An <i>xform_object</i> created by UniCreateTransformObject. <a name="SPTSP50649">&nbsp;</a>
<dd>&nbsp;
<dt>InpBuf &nbsp;(const UniChar *)&nbsp;
<dd>String to be transformed. <a name="SPTSP50650">&nbsp;</a>
<dd>&nbsp;
<dt>InpSize &nbsp;(int *)&nbsp;
<dd>Number of code elements in InpBuf. <a name="SPTSP50651">&nbsp;</a>
<dd>&nbsp;
<dt>OutBuf &nbsp;(UniChar *)&nbsp;
<dd>Target string. <a name="SPTSP50652">&nbsp;</a>
<dd>&nbsp;
<dt>OutSize &nbsp;(int *)&nbsp;
<dd>Number of code elements that OutBuf can hold.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50653">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<p>UniTransformStr returns one of the following:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Transformation completed without errors.
<dt><b>ULS_UNSUPPORTED </b>
<dd>The transform object was not found.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniTransformStr transforms a UniChar character string as specified by the transformation object handle xform_object for
the LC_CTYPE category. This category applies to the locale object that was used to create the transformation handle
xform_object (by UniCreateTransformObject). The text from the input buffer is transformed and the result is placed in the
output buffer. Any characters not included in the transformation type referenced by xform_object are moved, to the output
buffer, unchanged. </p>
<p>The InpSize argument, on input, specifies the number of code elements to be transformed. A value of -1 indicates that the
input is delimited by a UniChar NULL character (0x0000). On return, the value is modified to the actual number of code
elements processed in the source string. </p>
<p>The OutSize argument, on input, specifies the size of the output buffer (number of code elements). On return, the value is
modified to the actual number of code elements placed in OutBuf. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50100" name="ToC_309">UniCreateTransformObject</a>
<li><a href="#LENSM50105">UniFreeTransformObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and use a transform object.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject locale_object = NULL;<br>
XformObject  xform_object = NULL;
int          rc = ULS_SUCCESS;
int          in_unistr_elem = 0;
int          out_unistr_elem = 10;
UniChar      *pin_unistr = (UniChar *)L&quot;os2&quot;;
UniChar      out_unistr[10];
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Create an upper case transform object */
         rc = UniCreateTransformObject(locale_object,
                                      (UniChar *)L&quot;upper&quot;, &amp;xform_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateTransformObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Calculate the number of elements to transform */
         in_unistr_elem = UniStrlen (pin_unistr) + 1;
         /* Make call to transform input string to uppercase */
         rc = UniTransformStr(xform_object, pin_unistr,
                             &amp;in_unistr_elem, out_unistr,
                             &amp;out_unistr_elem);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniTransformStr error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_60" name="LENSM50169">UniTransLower</a></h2>
<p>UniTransLower converts a Unicode character to lowercase using the specified locale. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar UniTransLower </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50654">&nbsp;</a>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL. <a name="SPTSP50655">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The character to be transformed.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UniChar)&nbsp; -&nbsp; returns&nbsp;
<dd>UniTransLower returns the transformed character. The input character is returned if there is no transformation defined
for the character in locale_object.
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50170" name="ToC_309">UniTransUpper</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode character to lowercase.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject  locale_object;
UniChar       uni_upr = L'C';
UniChar       uni_lwr;
int           rc;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         uni_lwr = UniTransLower(locale_object, uni_upr);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_61" name="LENSM50170">UniTransUpper</a></h2>
<p>UniTransUpper converts Unicode character to uppercase using the specified locale. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;unidef.h&gt;</pre>
<dl>
<dt><b>UniChar UniTransUpper </b>
<dd><b>(const LocaleObject&nbsp;locale_object, UniChar&nbsp;uc)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>locale_object &nbsp;(const LocaleObject)&nbsp;
<dd>A locale object created by UniCreateLocaleObject or NULL <a name="SPTSP50658">&nbsp;</a>
<dd>&nbsp;
<dt>uc &nbsp;(UniChar)&nbsp;
<dd>The character to be transformed.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(UniChar)&nbsp; -&nbsp; returns&nbsp;
<dd>This function returns the transformed character. The input character is returned if there is no transformation defined
for the character in locale_object.
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50169" name="ToC_309">UniTransLower</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode character to uppercase.
#include &lt;stdio.h&gt;<br>
#include &lt;unidef.h&gt;
int main(void) {
LocaleObject  locale_object;
UniChar       uni_lwr = L'c';
UniChar       uni_upr;
int           rc;
         /*****************************************************************/
         /* Assumes LANG environment variable set to a valid locale name, */
         /* such as fr_FR                                                 */
         /*****************************************************************/
         rc = UniCreateLocaleObject(UNI_UCS_STRING_POINTER,
                                   (UniChar *)L&quot;&quot;, &amp;locale_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateLocaleObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         uni_upr = UniTransUpper(locale_object, uni_lwr);
         return (ULS_SUCCESS);</pre>
<p>} </p>
<p><hr> </p>
<p>&nbsp;
<hr> </p>
<h1><a href="#ToC_98" name="HDRUNICF">Conversion Functions</a></h1>
<p>It is expected that most of the processing by applications using the ULS will be done using UniChar* strings. Yet, many
applications will need to export data to and import data from non-UCS encodings (for example, ASCII or EBCDIC). For
this purpose, a set of functions are defined to perform conversions between UCS and non-UCS encodings. The Uconv
name is used to indicate these functions. The Uconv functions are capable of doing only UCS conversions, such as
converting to/from UCS. </p>
<h2><a href="#ToC_67" name="LENSM50177">UniCreateUconvObject</a></h2>
<p>UniCreateUconvObject creates and initializes a Uconv object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniCreateUconvObject </b>
<dd><b>(UniChar&nbsp;*cpname, UconvObject &nbsp;*uconv_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>cpname &nbsp;(UniChar *)&nbsp;
<dd>Name of the UCS conversion. <a name="SPTSP50680">&nbsp;</a>
<dd>&nbsp;
<dt>uconv_object &nbsp;(UconvObject *)&nbsp;
<dd>The conversion object being returned.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>Upon completion, UniCreateUconvObject returns one of the following:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Conversion object successfully initialized.
<dt><b>ULS_INVALID </b>
<dd>The conversion specified by cpname is not recognized by the implementation.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniCreateUconvObject returns a conversion object that describes a UCS-2 conversion between the code page specified
by <b>cpname</b> and UCS. </p>
<p>A conversion object remains valid until it is freed. </p>
<p>The cpname field is normally the Unicode string <i>IBM-</i> followed by the decimal number of the code page. Other names may
be used. UCONV tables are kept in the <i>\language\codepage</i> directory on the boot drive. </p>
<p>If the cpname parameter contains an empty string, UniCreateUconvObject will create a conversion object based upon the
value of the process codepage setting. </p>
<p>UniCreateUconvObject allows modifiers to be concatenated onto cpname, these modifiers change the default behavior of
conversion objects. The caller can concatenate the following modifiers onto cpname. </p>
<p>Modifiers are separated from the conversion object name by an at sign (@), and multiple modifiers are separated by a
comma (,). </p>
<p>displaymask </p>
<pre>              &nbsp; @map=data        All characters less than space are controls.
                                 (default)
                @map=display     All characters less than space are glyphs.
                @map=cdra        Use IBM standard control conversion.
                @map=clrf        CR and LF are controls, others are glyphs.</pre>
<p>converttype </p>
<pre>                @path=yes        When performing Unicode conversions strings
                                 are assumed to contain pathnames. This
                                 setting is only applicable when converting
                                 to or from DBCS codepages.
                                 (default)
                @path=no         When performing Unicode conversions strings
                                 are assumed to contain non path data. This
                                 setting is only applicable when converting
                                 to or from DBCS codepages.
                                 </pre>
<p>endian </p>
<pre>                @endian=Source:Target
                @endian=Both
                Source applies to UniUconvFromUcs; Target applies to
                UniUconvToUcs.  If only one endian is given, it applies
                to both source and target.
                The endian type can be one of the following:
                      system     Use system endian.
                      big        Use big endian.
                      little     Use little endian.
                                 (default)
                 For example @endian=little
                             @endian=big:system</pre>
<p>options </p>
<pre>               @sub=yes          Perform substitutions when converting to and
                                 from Unicode.
               @sub=no           Do not perform substitutions when converting
                                 to and from Unicode.
               @sub=to-ucs       Only perform substitutions when converting to
                                 Unicode.
               @sub=from-ucs     Only perform substitutions when converting from
                                 Unicode.
                                 (default)
               @subchar=\xXX     Where XX is a hex number
               @subchar=\DD      Where DD is a decimal number
                                 The substitution character attribute specifies
                                 which character the conversion object should
                                 use when there is no identical character for
                                 a given code element while converting from
                                 Unicode.
               @subuni=\xXX\xXX  Where XX is a hex number
               @subuni=\xXXXX    Where XXXX is a hex number
                                 The substitution character attribute specifies
                                 which character the conversion object should
                                 use when there is no identical character for
                                 a given code element while converting to
                                 Unicode.</pre>
<p>Examples of typical usage: </p>
<p>IBM-942@path=yes,map=display </p>
<pre>              This example creates a conversion object based upon an IBM-942
              encoding. When conversions are performed all strings will be treated
              as pathnames and all characters less than space will be considered
              to be glyphs.</pre>
<p>@path=yes,sub=no </p>
<pre>              This example creates a conversion object based upon the current
              process codepage setting. When conversions are performed all strings
              will be treated as pathnames and no substitutions will occur.</pre>
<p>IBM-850@path=no,sub=yes </p>
<pre>              This example creates a conversion object based upon an IBM-850
              encoding. When conversions are performed all strings will be treated
              as non pathnames and substitutions will occur when converting to and
              from Unicode if necessary.</pre>
<p>UniCreateUconvObject returns a conversion object in uconv_object for use in subsequent calls to either
UniUconvFromUcs or UniUconvToUcs. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50178" name="ToC_309">UniFreeUconvObject</a>
<li><a href="#LENSM50181">UniQueryUconvObject</a>
<li><a href="#LENSM50182">UniSetUconvObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create a conversion object.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UconvObject  uconv_object = NULL;<br>
int          rc = ULS_SUCCESS;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /* setting with the path modifier set                               */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;@path=yes&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_68" name="LENSM50178">UniFreeUconvObject</a></h2>
<p>UniFreeUconvObject frees a conversion object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniFreeUconvObject </b>
<dd><b>(UconvObject&nbsp;uconv_object)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50682">&nbsp;</a>
<dl>
<dt>uconv_object &nbsp;(UconvObject)&nbsp;
<dd>Conversion object created by a call to UniCreateUconvObject.
</dl>
<p><strong>Returns</strong>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>Upon completion, UniFreeUconvObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>All resources associated with <b>uconv</b> have been successfully freed.
<dt><b>ULS_BADOBJECT </b>
<dd>The uconv_object argument is not a valid conversion object.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniFreeUconvObject closes the conversion object. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50177" name="ToC_309">UniCreateUconvObject</a>
<li><a href="#LENSM50181">UniQueryUconvObject</a>
<li><a href="#LENSM50182">UniSetUconvObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to create and free a conversion object.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UconvObject  uconv_object = NULL;<br>
int          rc = ULS_SUCCESS;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /* setting with the path modifier set                               */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;@path=yes&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniFreeUconvObject(uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniFreeUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_69" name="LENSM50179">UniMapCpToUcsCp</a></h2>
<p>UniMapCpToUcsCp converts a code page number into a code page represented as a UniChar string that is acceptable as
input to UniCreateUconvObject. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniMapCpToUcsCp </b>
<dd><b>(unsigned long&nbsp;ulCodepage, UniChar&nbsp;*ucsCodepage, size_t&nbsp;n)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>ulCodepage &nbsp;(unsigned long)&nbsp; -&nbsp; input&nbsp;
<dd>A code page as returned from DosQueryCp. If the value is zero the current process codepage value will be used in
determining the returned Unicode string. <a name="SPTSP50685">&nbsp;</a>
<dd>&nbsp;
<dt>ucsCodepage &nbsp;(UniChar *)&nbsp; -&nbsp; output&nbsp;
<dd>A buffer for placing the Unicode string. <a name="SPTSP50686">&nbsp;</a>
<dd>&nbsp;
<dt>n &nbsp;(size_t)&nbsp; -&nbsp; input&nbsp;
<dd>Size of the ucsCodepage buffer in Unicode characters. This should be at least 12 Unicode characters.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50687">&nbsp;</a>
<dl>
<dt>retcode &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>Error code.
<p>UniMapCpToUcsCp returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The code page number was successfully converted to a Unicode string.
<dt><b>ULS_INVALID </b>
<dd>An invalid code page number or buffer was passed in; the contents of ucsCodepage are undefined.
</dl>
</dl>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50180" name="ToC_177">UniMapCtryToLocale</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a codepage number to a Unicode string.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UniChar      ucs_code_page[12];
size_t       num_elems = 12;
UconvObject  uconv_object = NULL;
int          rc = ULS_SUCCESS;
         /********************************************************************/
         /* Convert a code page number to a unichar string                   */
         /********************************************************************/</pre>
<p>rc = UniMapCpToUcsCp(850, ucs_code_page, num_elems); </p>
<pre>         if (rc != ULS_SUCCESS) {
           printf(&quot;UniMapCpToUcsCp error: return code = %u\n&quot;, rc);
           return 1;
         }
         rc = UniCreateUconvObject(ucs_code_page, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_71" name="LENSM50181">UniQueryUconvObject</a></h2>
<p>UniQueryUconvObject queries the attributes of a conversion object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniQueryUconvObject </b>
<dd><b>(UconvObject&nbsp;uobj, uconv_attribute_t&nbsp;*attr, size_t&nbsp;size, char&nbsp;first[256], char&nbsp;other[256],
udcrange_t&nbsp;udcrange[32])</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>uobj &nbsp;(UconvObject)&nbsp; -&nbsp; input&nbsp;
<dd>The conversion object created by a call to UniCreateUconvObject. <a name="SPTSP50693">&nbsp;</a>
<dd>&nbsp;
<dt>attr &nbsp;(uconv_attribute_t *)&nbsp; -&nbsp; output&nbsp;
<dd>Pointer to uconv_attribute_t; receives attribute information. <a name="SPTSP50694">&nbsp;</a>
<dd>&nbsp;
<dt>size &nbsp;(size_t )&nbsp; -&nbsp; input&nbsp;
<dd>Specifies the size of the attribute buffer. This must be at least as large as version 0 of the uconv_attribute_t structure. &nbsp;
<dd>&nbsp;
<dt>first[256] &nbsp;(char)&nbsp; -&nbsp; output&nbsp;
<dd>Gives an array of starting bytes for a multibyte character set. For some forms of stateful code pages, the length is
based on state and not this table. If this parameter is NULL, no value is returned. Each byte has one of the following
values:
<dl>
<dt>1 <a name="SPTSV50182">&nbsp;</a>
<dd>Valid single byte character.
<dt>2 <a name="SPTSV50183">&nbsp;</a>
<dd>for a double-byte character.
<dt>3 <a name="SPTSV50184">&nbsp;</a>
<dd>for a triple-byte character.
<dt>255 <a name="SPTSV50185">&nbsp;</a>
<dd>code point.
</dl>
<p><a name="SPTSP50696">&nbsp;</a>
<dt>other[256] &nbsp;(char)&nbsp; -&nbsp; output&nbsp;
<dd>An array indicating when the byte is used a secondary byte in a multi-byte sequence. This is used to allocate buffers.
There are two possible values for each byte:
<dl>
<dt>0 <a name="SPTSV50186">&nbsp;</a>
<dd>This is not used as a secondary character.
<dt>1 <a name="SPTSV50187">&nbsp;</a>
<dd>This is used as a secondary character.
</dl>
<p><a name="SPTSP50697">&nbsp;</a>
<dt>udcrange[32] &nbsp;(udcrange_t)&nbsp; -&nbsp; output&nbsp;
<dd>A set of ranges of characters that make up the user-defined character range.
</dl>
<p><strong>Returns</strong> <a name="SPTSP51234">&nbsp;</a>
<dl>
<dt>retcode &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>Error code.
<p>UniQueryUconvObject returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>The conversion object data was successfully returned
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniQueryUconvObject queries the attributes and characteristics of the given conversion object. The attributes are used to
modify the default conversion. </p>
<p>The substitution character attributes specify to the conversion object how to perform in cases that there is no identical
character for a given code element. UniQueryUconvObject may be used to query the substitution characters used by the
conversion. </p>
<p>Some of these are static and bound to the conversion table; others are settable through UniSetUconvObject </p>
<p>The <i>attr</i>, <i>first</i>, <i>other</i>, and <i>udcrange</i> parameters can be NULL to indicate that this data should not be returned. </p>
<p>See the uconv_attribute_t to see the conversion object attributes; the structure indicates which fields can be queried and
which can be set through UniSetUconvObject. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50177" name="ToC_309">UniCreateUconvObject</a>
<li><a href="#LENSM50178">UniFreeUconvObject</a>
<li><a href="#LENSM50182">UniSetUconvObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to query a conversion object.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
uconv_attribute_t   attr;
UconvObject         uconv_object = NULL;
int                 rc = ULS_SUCCESS;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /* setting with the path modifier set                               */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;@path=yes&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query the conversion object */
         rc = UniQueryUconvObject(uconv_object, &amp;attr,
                                  sizeof(uconv_attribute_t), NULL,
                                  NULL, NULL);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_72" name="LENSM50182">UniSetUconvObject</a></h2>
<p>UniSetUconvObject sets the attributes of a conversion object. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniSetUconvObject </b>
<dd><b>(UconvObject&nbsp;uconv_object, uconv_attribute_t&nbsp;*attr_t)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>uconv_object &nbsp;(UconvObject)&nbsp; -&nbsp; input&nbsp;
<dd>The conversion object created by a call to UniCreateUconvObject. :evallist. :eparm. <a name="SPTSP50699">&nbsp;</a>
<dd>&nbsp;
<dt>attr_t &nbsp;(uconv_attribute_t *)&nbsp; -&nbsp; input&nbsp;
<dd>The uconv_attribute_t structure, which the caller sets with values of the conversion object attributes. The caller can
set these fields:
<dl>
<dt><b>options </b>
<dd>Substitution options, which can have one of these values:
<ul><p>UCONV_OPTION_SUBSTITUTION_FROM_UNICODE
UCONV_OPTION_SUBSTITUTION_TO_UNICODE
UCONV_OPTION_SUBSTITUTION_BOTH
</ul>
<dt><b>endian </b>
<dd>Source and target endian. Thsi is a structure containing a source and target endian field. Source applies to
UniUconvFromUcs; target applies to UniUconvToUcs. Each of the fields can contain one of the following
values:
<dl>
<dt><b>0x000 </b>
<dd>Use system endian.
<dt><b>0xfeff </b>
<dd>Use big endian.
<dt><b>0xfffe </b>
<dd>Use little endian.
</dl>
<dt><b>displaymask </b>
<dd>A 32-bit display and data mask. Each bit represents a control character below space (1&lt;&lt;char). If the bit is 0,
the character is treated as a display glyph. If the bit is 1, the character is treated as a control. There are several
predefined values for this mask, but any value can be used:
<dl>
<dt><b>DSPMASK_DATA </b>
<dd>All characters less than space are controls.
<dt><b>DSPMASK_DISPLAY </b>
<dd>All characters less than space are glyphs.
<dt><b>DSPMASK_CRLF </b>
<dd>CR and LF are controls: Others are glyphs.
</dl>
<dt><b>converttype </b>
<dd>Conversion type. This is a set of flags. The following flags exist and can be ORed together:
<dl>
<dt><b>CVTTYPE_CTRL7F </b>
<dd>Treat the 0x7f character as a control.
<dt><b>CVTTYPE_CDRA </b>
<dd>Use IBM standard control conversion. If this bit is not set, controls are converted to an equal value.
Some conversions always do control conversions.
<dt><b>CVTTYPE_PATH </b>
<dd>When performing Unicode conversions strings are assumed to contain pathnames. This setting is only
applicable when converting to or from DBCS codepages.
</dl>
<dt><b>subchar_len </b>
<dt>Code page substitution length. This can be a value between 1 and 13 to indicate the substitution length. It may not
exceed the maximum size character in the encoding. A value of zero indicates that the substitution character from the
conversion table should be used.
<dt><b>subchar </b>
<dt>Substitution bytes. This is the actual value whose length is specified by subchar_len.
<dt><b>subuni_len </b>
<dd>Unicode substitution length. This can be either 0 or 1. A zero indicates that the Unicode substitution from the
conversion table should be used.
<dt><b>subuni </b>
<dd>If subuni_len is set to 1, the first element in this array gives the Unicode substitution character.
<dt><b>state </b>
<dd>When the state is set to 0, the conversion object is put into the base conversion state.
</dl>
</dl>
<p><strong>Returns</strong> <a name="SPTSP50700">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>Return Codes
<dl>
<dt><b>ULS_SUCCESS </b><a name="SPTSV50188">&nbsp;</a>
<dd>Indicates success.
<dt><b>ULS_BADATTR </b><a name="SPTSV50189">&nbsp;</a>
<dd>Indicates an invalid parameter.
</dl>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniSetUconvObject sets the attributes of the given conversion object. The attributes are used to modify the default
conversion. It is left up to each conversion to decide which attributes it will recognize. </p>
<p>The substitution character attributes specify to the conversion object how to perform in cases that there is no identical
character for a given code element. </p>
<p><strong>Remarks</strong> </p>
<p>This example sets the displaymask to all display and path to yes, meaning all code points below space are mapped as glyphs
and not as controls. It also treats data as pathnames. To modify only some attributes, a query should first be done using
UniQueryUconvObject. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50177" name="ToC_309">UniCreateUconvObject</a>
<li><a href="#LENSM50178">UniFreeUconvObject</a>
<li><a href="#LENSM50181">UniQueryUconvObject</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to set a conversion object.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
uconv_attribute_t   attr;
UconvObject         uconv_object = NULL;
int                 rc = ULS_SUCCESS;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /* setting with the path modifier set                               */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;@path=yes&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Query the conversion object */
         rc = UniQueryUconvObject(uconv_object, &amp;attr,
                                  sizeof(uconv_attribute_t), NULL,
                                  NULL, NULL);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniQueryUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         /* Turn the path modifier and display attributes on */
         attr.converttype = attr.converttype | CVTTYPE_PATH;
         attr.displaymask = DSPMASK_DISPLAY;
         rc = UniSetUconvObject(uconv_object, &amp;attr);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniSetUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
         return ULS_SUCCESS;</pre>
<p>} </p>
<p><hr> </p>
<h2><a href="#ToC_73" name="LENSM50183">UniUconvFromUcs</a></h2>
<p>UniUconvFromUcs converts UCS characters to code page characters. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniUconvFromUcs </b>
<dd><b>(UconvObject&nbsp;uconv_object, UniChar&nbsp;**ucsbuf, size_t&nbsp;*UniCharsleft, void&nbsp;**outbuf, size_t&nbsp;*outbytesleft,
size_t&nbsp;*nonidentical)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>uconv_object &nbsp;(UconvObject)&nbsp;
<dd>Conversion object created by a call to UniCreateUconvObject. <a name="SPTSP50702">&nbsp;</a>
<dd>&nbsp;
<dt>ucsbuf &nbsp;(UniChar **)&nbsp;
<dd>Input buffer. <a name="SPTSP50703">&nbsp;</a>
<dd>&nbsp;
<dt>UniCharsleft &nbsp;(size_t *)&nbsp;
<dd>Number of UniChar elements in ucsbuf. <a name="SPTSP50704">&nbsp;</a>
<dd>&nbsp;
<dt>outbuf &nbsp;(void **)&nbsp;
<dd>Output buffer. <a name="SPTSP50705">&nbsp;</a>
<dd>&nbsp;
<dt>outbytesleft &nbsp;(size_t *)&nbsp;
<dd>Size of outbuf, in units of bytes. <a name="SPTSP50706">&nbsp;</a>
<dd>&nbsp;
<dt>nonidentical &nbsp;(size_t *)&nbsp;
<dd>Number of nonidentical conversions.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50707">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniUconvToUcs returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Conversion successful.
<dt><b>ULS_BUFFERFULL </b>
<dd>Input conversion stopped due to lack of space in the output buffer.
<dt><b>ULS_ILLEGALSEQUENCE </b>
<dd>Input conversion stopped due to an incomplete character or shift sequence at the end of the input buffer. This
condition will be given when the last UniChar element is recognized as a combining character.
<dt><b>ULS_INVALID </b>
<dd>The uconv_object argument is not a valid, open conversion object.
</dl>
<p>UniUconvFromUcs updates the variables pointed to by the arguments to reflect the extent of the conversion and
returns, in <b>nonidentical</b>, the number of substitution (nonidentical) conversions performed. If the entire string in the
input buffer is converted, the value pointed to by <b>UniCharsleft</b> will be 0. If the input conversion is stopped due to
any condition mentioned above, the value pointed to by <b>UniCharsleft</b> will be nonzero. If any error occurs,
UniUconvToUcs returns a nonzero value. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniUconvFromUcs converts a sequence of code elements, in the array specified by <b>ucsbuf</b>, into a sequence of
corresponding characters in another code page, in the array specified by <b>outbuf</b>. The code page of the <b>outbuf</b> is the string
specified in the UniCreateUconvObject call that returned the conversion object, <b>uconv_object</b>. The <b>ucsbuf</b> argument
points to a variable that points to the first UniChar in the input buffer, and the <b>UniCharsleft</b> indicates the number of
UniChar elements to the end of the buffer to be converted. The <b>outbuf</b> argument points to a variable that points to the first
available character in <b>outbuf</b>, and <b>outbytesleft</b> indicates the number of bytes available to the end of the buffer. </p>
<p>If the <b>outbuf</b> buffer is not large enough to hold the entire converted input, conversion stops just prior to the input UniChar
that would cause the output buffer to overflow. The variable pointed to by <b>ucsbuf</b> is updated to point to the UniChar
following the last UniChar successfully used in the conversion. The value pointed to by <b>outbytesleft</b> is decremented to
reflect the number of bytes still available in <b>outbuf</b>. </p>
<p>If UniUconvFromUcs encounters a code element in the <b>ucsbuf</b> that is legal, but for which an identical character does not
exist in the target code page, UniUconvFromUcs replaces the character with a predefined substitution character, if the
attributes of the conversion object allow this operation. If substitution is not selected, an error is returned and conversion
stops after the previous successfully converted UniChar. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50184" name="ToC_309">UniUconvToUcs</a>
<li><a href="#LENSM50185">UniStrFromUcs</a>
<li><a href="#LENSM50186">UniStrToUcs</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to code page characters.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UconvObject  uconv_object = NULL;
int          rc = ULS_SUCCESS;
size_t       out_bytes_left;
size_t       uni_chars_left;
size_t       num_subs;
size_t       char_buf_size = 50;
char         char_buffer[50];
char         *pout_char_str;
UniChar      *pin_uni_str;
UniChar      uni_data[] = L&quot;UniCode string to convert&quot;;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
        /*********************************************************************/
        /* pin_uni_str points to the unicode string to be converted to       */
        /* codepage characters                                               */
        /*********************************************************************/
        pout_char_str = char_buffer;
        pin_uni_str = uni_data;
        uni_chars_left = UniStrlen(pin_uni_str)+1;
        out_bytes_left = char_buf_size;
        /*********************************************************************/
        /* make call to convert unicode string  to codepage characters       */
        /*********************************************************************/
        rc = UniUconvFromUcs(uconv_object, &amp;pin_uni_str, &amp;uni_chars_left,
                            (void **)&amp;pout_char_str, &amp;out_bytes_left,
                            &amp;num_subs);
        if(rc != ULS_SUCCESS &amp;&amp; uni_chars_left &gt; 0) {
           printf(&quot;UniUconvFromUcs error: return code = %u\n&quot;, rc);
           printf(&quot;Unicode string was not completely converted\n&quot;);
           return 1;
        }</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_74" name="LENSM50184">UniUconvToUcs</a></h2>
<p>UniUconvToUcs converts a code page string to a UCS string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniUconvToUcs </b>
<dd><b>(UconvObject&nbsp;uconv_object, void&nbsp;**inbuf, size_t&nbsp;*inbytesleft, UniChar&nbsp;**ucsbuf, size_t&nbsp;*UniCharsleft,
size_t&nbsp;*nonidentical)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>uconv_object &nbsp;(UconvObject)&nbsp;
<dd>Conversion object created by a call to UniCreateUconvObject. <a name="SPTSP50709">&nbsp;</a>
<dd>&nbsp;
<dt>inbuf &nbsp;(void **)&nbsp;
<dd>Input buffer. <a name="SPTSP50710">&nbsp;</a>
<dd>&nbsp;
<dt>inbytesleft &nbsp;(size_t *)&nbsp;
<dd>Size of inbuf, in units of bytes. <a name="SPTSP50711">&nbsp;</a>
<dd>&nbsp;
<dt>ucsbuf &nbsp;(UniChar **)&nbsp;
<dd>Output buffer. <a name="SPTSP50712">&nbsp;</a>
<dd>&nbsp;
<dt>UniCharsleft &nbsp;(size_t *)&nbsp;
<dd>Number of Unichar elements in ucsbuf. <a name="SPTSP50713">&nbsp;</a>
<dd>&nbsp;
<dt>nonidentical &nbsp;(size_t *)&nbsp;
<dd>Number of non-identical conversions.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50714">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniUconvToUcs returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Conversion successful.
<dt><b>ULS_INVALID </b>
<dd>Input conversion stopped due to an error condition such as lack of buffer space.
</dl>
<p>UniUconvToUcs updates the variables pointed to by the arguments to reflect the extent of the conversion and returns,
in <b>nonidentical</b>, the number of substitutions (non-identical) conversions performed. If the entire string in the input
buffer is converted, the value pointed to by <b>inbytesleft</b> will be zero. If the input conversion is stopped due to any
condition mentioned above, the value pointed to by <b>inbytesleft</b> will be non zero and a non zero value is returned to
indicate the condition. If an error occurs, UniUconvToUcs returns a non zero value. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniUconvToUcs converts a sequence of characters encoded in one code page, in the array specified by <b>inbuf</b>, into a
sequence of corresponding UCS code elements, in the array specified by <b>ucsbuf</b>. The code page of the <b>inbuf</b> is the string
specified in the UniCreateUconvObject call that returned the conversion object, <b>uconv_object</b>. The <b>inbuf</b> argument points
to a variable that points to the first byte in the input buffer, and the <b>inbytesleft</b> indicates the number of bytes to the end of
the buffer to be converted. The <b>ucsbuf</b> argument points to a variable that points to the first available UniChar in <b>ucsbuf</b>, and
<b>UniCharsleft</b> indicates the number of UniChar elements available to the end of the buffer. </p>
<p>If a sequence of bytes within <b>inbuf</b> does not form a valid character in the specified code page and substitution to UCS is not
turned on, conversion stops after the previous successfully converted character. If the input buffer ends with an incomplete
character, conversion stops after the previous successfully converted bytes. If the <b>ucsbuf</b> buffer is not large enough to hold
the entire converted input, conversion stops just prior to the input bytes that would cause the output buffer to overflow. The
variable pointed to by <b>inbuf</b> is updated to point to the byte following the last byte successfully used in the conversion. The
value pointed to by <b>UniCharsleft</b> is decremented to reflect the number of UniChar elements still available in <b>ucsbuf</b>. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50183" name="ToC_309">UniUconvFromUcs</a>
<li><a href="#LENSM50185">UniStrFromUcs</a>
<li><a href="#LENSM50186">UniStrToUcs</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert code page encoded characters to Unicode.
#include &lt;stdio.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UconvObject  uconv_object = NULL;
int          rc = ULS_SUCCESS;
size_t       in_bytes_left;
size_t       uni_chars_left;
size_t       num_subs;
int          uni_buf_length = 50;
UniChar      uni_buffer[50];
UniChar      *pout_uni_str;
char         char_data[] = &quot;Character string to convert&quot;;
char         *pin_char_str;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
        /*********************************************************************/
        /* pin_char_str points to the character string to be converted to    */
        /* Unicode characters                                                */
        /*********************************************************************/
        pout_uni_str = uni_buffer;
        pin_char_str = char_data;
        uni_chars_left = uni_buf_length;
        in_bytes_left = ( strlen(char_data) + 1 ) * sizeof(char);
       /**********************************************************************/
       /* make call to convert codepage character string to a Unicode string */
       /**********************************************************************/
       rc = UniUconvToUcs(uconv_object, (void **)&amp;pin_char_str, &amp;in_bytes_left,
                         &amp;pout_uni_str, &amp;uni_chars_left,
                         &amp;num_subs);
        if(rc != ULS_SUCCESS &amp;&amp; in_bytes_left &gt; 0) {
           printf(&quot;UniUconvToUcs error: return code = %u\n&quot;, rc);
           printf(&quot;Character string was not completely converted to Unicode\n&quot;);
           return 1;
        }</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr> </p>
<h2><a href="#ToC_75" name="LENSM50185">UniStrFromUcs</a></h2>
<p>UniStrFromUcs converts a UCS string to a code page string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniStrFromUcs </b>
<dd><b>(UconvObject&nbsp;uconv_object, char *outbuf, UniChar *ucsstr, int size)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong> <a name="SPTSP50708">&nbsp;</a>
<dl>
<dt>uconv_object &nbsp;(UconvObject)&nbsp;
<dd>Conversion object created by a call to UniCreateUconvObject. <a name="SPTSP50709">&nbsp;</a>
<dd>&nbsp;
<dt>outbuf &nbsp;(char *)&nbsp;
<dd>Output buffer to hold converted string. <a name="SPTSP50710">&nbsp;</a>
<dd>&nbsp;
<dt>ucsstr &nbsp;(UniChar *)&nbsp;
<dd>Null terminated Unicode string. <a name="SPTSP50711">&nbsp;</a>
<dd>&nbsp;
<dt>size &nbsp;(int )&nbsp;
<dd>number of bytes that output buffer can hold
</dl>
<p><strong>Returns</strong> <a name="SPTSP50714">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniStrFromUcs returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Conversion successful.
<dt><b>ULS_BADOBJECT </b>
<dd>The <b>uconv_object</b> argument is not a valid, open conversion object.
<dt><b>ULS_BUFFERFULL </b>
<dd>Input conversion stopped due to lack of space in the output buffer.
<dt><b>ULS_ILLEGALSEQUENCE </b>
<dd>Input conversion stopped due to an input byte that does not belong to the input code page.
</dl>
<p>UniStrFromUcs always performs conversions with substitution on. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniStrFromUcs converts a sequence of code elements up to and including the null terminator, in the array specified by
<b>ucsstr</b>, into a sequence of corresponding characters in another code page in the array specified by <b>outbuf</b>. The code page
of <b>outbuf</b> is the string specified in the UniCreateUconvObject call that returned the conversion object, <b>uconv_object</b>. The
<b>ucsstr</b> argument points to a variable that points to the first UniChar in the input bufer. The <b>outbuf</b> argument points to a
variable that points to the first available character in <b>outbuf</b>, and <b>size</b> indicates the number of bytes available to the end of
the buffer. </p>
<p>If the <b>outbuf</b> buffer is not large enough to hold the entire converted input, conversion stops just prior to the input UniChar
that would cause the output buffer to overflow. </p>
<p>If UniStrFromUcs encounters a code element in the <b>ucsstr</b> that is legal, but for which an identical character does not exist in
the target code page, UniStrFromUcs replaces the character with a predefined substitution character. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50183">UniUconvFromUcs</a>
<li><a href="#LENSM50184">UniUconvToUcs</a>
<li><a href="#LENSM50186" name="ToC_309">UniStrToUcs</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert a Unicode string to code page characters.
#include &lt;stdio.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UconvObject  uconv_object = NULL;
int          rc = ULS_SUCCESS;
size_t       buf_size = 50;
char         char_buffer[50];
UniChar      uni_data[] = L&quot;UniCode string to convert&quot;;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }

        /*********************************************************************/
        /* make call to convert unicode string  to codepage characters       */
        /*********************************************************************/
        rc = UniStrFromUcs(uconv_object, char_buffer, uni_data, buf_size);
        if(rc != ULS_SUCCESS) {
           printf(&quot;UniStrFromUcs error: return code = %u\n&quot;, rc);
           printf(&quot;Unicode string was not completely converted\n&quot;);
           return 1;
        }</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p><hr>
<hr> </p>
<h2><a href="#ToC_74" name="LENSM50186">UniStrToUcs</a></h2>
<p>UniStrToUcs converts a code page string to a UCS string. </p>
<p><strong>Format</strong>
<hr> </p>
<pre>#include &lt;uconv.h&gt;</pre>
<dl>
<dt><b>int UniStrToUcs </b>
<dd><b>(UconvObject&nbsp;uconv_object, void&nbsp;**inbuf, size_t&nbsp;*inbytesleft, UniChar&nbsp;**ucsbuf, size_t&nbsp;*UniCharsleft,
size_t&nbsp;*nonidentical)</b>
</dl>
<p><hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>uconv_object &nbsp;(UconvObject)&nbsp;
<dd>Conversion object created by a call to UniCreateUconvObject. <a name="SPTSP50709">&nbsp;</a>
<dd>&nbsp;
<dt>inbuf &nbsp;(void **)&nbsp;
<dd>Input buffer. <a name="SPTSP50710">&nbsp;</a>
<dd>&nbsp;
<dt>inbytesleft &nbsp;(size_t *)&nbsp;
<dd>Size of inbuf, in units of bytes. <a name="SPTSP50711">&nbsp;</a>
<dd>&nbsp;
<dt>ucsbuf &nbsp;(UniChar **)&nbsp;
<dd>Output buffer. <a name="SPTSP50712">&nbsp;</a>
<dd>&nbsp;
<dt>UniCharsleft &nbsp;(size_t *)&nbsp;
<dd>Number of Unichar elements in ucsbuf. <a name="SPTSP50713">&nbsp;</a>
<dd>&nbsp;
<dt>nonidentical &nbsp;(size_t *)&nbsp;
<dd>Number of non-identical conversions.
</dl>
<p><strong>Returns</strong> <a name="SPTSP50714">&nbsp;</a>
<dl>
<dt>return value &nbsp;(int)&nbsp; -&nbsp; returns&nbsp;
<dd>UniUconvToUcs returns one of the following values:
<dl>
<dt><b>ULS_SUCCESS </b>
<dd>Conversion successful.
<dt><b>ULS_BADOBJECT </b>
<dd>The <b>uconv_object</b> argument is not a valid, open conversion object.
<dt><b>ULS_BUFFERFULL </b>
<dd>Input conversion stopped due to lack of space in the output buffer.
<dt><b>ULS_ILLEGALSEQUENCE </b>
<dd>Input conversion stopped due to an input byte that does not belong to the input code page.
<dt><b>ULS_INVALID </b>
<dd>Input conversion stopped due to an incomplete character or shift sequence at the end of the input buffer.
</dl>
<p>UniUconvToUcs updates the variables pointed to by the arguments to reflect the extent of the conversion and returns,
in <b>nonidentical</b>, the number of substitutions (non-identical) conversions performed. If the entire string in the input
buffer is converted, the value pointed to by <b>inbytesleft</b> will be zero. If the input conversion is stopped due to any
condition mentioned above, the value pointed to by <b>inbytesleft</b> will be non zero and a non zero value is returned to
indicate the condition. If an error occurs, UniUconvToUcs returns a non zero value. </p>
</dl>
<p><strong>Remarks</strong> </p>
<p>UniUconvToUcs converts a sequence of characters encoded in one code page, in the array specified by <b>inbuf</b>, into a
sequence of corresponding UCS code elements, in the array specified by <b>ucsbuf</b>. The code page of the <b>inbuf</b> is the string
specified in the UniCreateUconvObject call that returned the conversion object, <b>uconv_object</b>. The <b>inbuf</b> argument points
to a variable that points to the first byte in the input buffer, and the <b>inbytesleft</b> indicates the number of bytes to the end of
the buffer to be converted. The <b>ucsbuf</b> argument points to a variable that points to the first available UniChar in <b>ucsbuf</b>, and
<b>UniCharsleft</b> indicates the number of UniChar elements available to the end of the buffer. </p>
<p>If a sequence of bytes within <b>inbuf</b> does not form a valid character in the specified code page and substitution to UCS is not
turned on, conversion stops after the previous successfully converted character. If the input buffer ends with an incomplete
character, conversion stops after the previous successfully converted bytes. If the <b>ucsbuf</b> buffer is not large enough to hold
the entire converted input, conversion stops just prior to the input bytes that would cause the output buffer to overflow. The
variable pointed to by <b>inbuf</b> is updated to point to the byte following the last byte successfully used in the conversion. The
value pointed to by <b>UniCharsleft</b> is decremented to reflect the number of UniChar elements still available in <b>ucsbuf</b>. </p>
<p><strong>Related Functions</strong>
<ul type="disc">
<li><a href="#LENSM50183" name="ToC_309">UniUconvFromUcs</a>
<li><a href="#LENSM50184">UniUconvToUcs</a>
<li><a href="#LENSM50185">UniStrFromUcs</a>
</ul>
<p><strong>Example</strong>
<hr> </p>
<pre>This example shows how to convert code page encoded characters to Unicode.
#include &lt;stdio.h&gt;<br>
#include &lt;string.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
#include &lt;uconv.h&gt;
int main(void) {
UconvObject  uconv_object = NULL;
int          rc = ULS_SUCCESS;
size_t       in_bytes_left;
size_t       uni_chars_left;
size_t       num_subs;
int          uni_buf_length = 50;
UniChar      uni_buffer[50];
UniChar      *pout_uni_str;
char         char_data[] = &quot;Character string to convert&quot;;
char         *pin_char_str;
         /********************************************************************/
         /* Create a conversion object based upon the process codepage       */
         /********************************************************************/
         rc = UniCreateUconvObject((UniChar *)L&quot;&quot;, &amp;uconv_object);
         if (rc != ULS_SUCCESS) {
           printf(&quot;UniCreateUconvObject error: return code = %u\n&quot;, rc);
           return 1;
         }
        /*********************************************************************/
        /* pin_char_str points to the character string to be converted to    */
        /* Unicode characters                                                */
        /*********************************************************************/
        pout_uni_str = uni_buffer;
        pin_char_str = char_data;
        uni_chars_left = uni_buf_length;
        in_bytes_left = ( strlen(char_data) + 1 ) * sizeof(char);
       /**********************************************************************/
       /* make call to convert codepage character string to a Unicode string */
       /**********************************************************************/
       rc = UniUconvToUcs(uconv_object, (void **)&amp;pin_char_str, &amp;in_bytes_left,
                         &amp;pout_uni_str, &amp;uni_chars_left,
                         &amp;num_subs);
        if(rc != ULS_SUCCESS &amp;&amp; in_bytes_left &gt; 0) {
           printf(&quot;UniUconvToUcs error: return code = %u\n&quot;, rc);
           printf(&quot;Character string was not completely converted to Unicode\n&quot;);
           return 1;
        }</pre>
<p>return ULS_SUCCESS;<br>
} </p>
<p>&nbsp; &nbsp;
<hr> </p>
<h1><a href="#ToC_9" name="HDRUNIDATA">ULS Data Types</a></h1>
<p>The following data types are used by the Unicode functions.
<hr> </p>
<h3><a href="#ToC_180" name="LENSM50290">AttrObject</a></h3>
<p>AttrObject is used to determine character classifications. </p>
<p><hr><br></p>
<pre>typedef void *AttrObject;</pre>
<p><br>
<hr>
<hr> </p>
<h3><a href="#ToC_93" name="LENSM50203">conv_endian_t</a></h3>
<p>conv_endian_t Information about the source and target endian. </p>
<p><hr><br></p>
<pre>typedef struct _conv_endian_rec {
&nbsp;&nbsp;unsigned short       source;
&nbsp;&nbsp;unsigned short       target;
} conv_endian_t;</pre>
<p><br>
<hr> </p>
<p><strong>Parameters</strong> </p>
<ul><p><a name="SPTSP50801">&nbsp;</a>
</ul>
<dl>
<dt>source &nbsp;(unsigned short)&nbsp;
<dd>Source information. <a name="SPTSP50802">&nbsp;</a>
<dt>target &nbsp;(unsigned short)&nbsp;
<dd>Target information.
</dl>
<p><hr>
<hr> </p>
<h3><a href="#ToC_181" name="LENSM50291">LocaleItem</a></h3>
<p>LocaleItem is used to identify a language or cultural item within a locale. </p>
<p><hr><br></p>
<pre>typedef int LocaleItem;</pre>
<p><br>
<hr>
<hr> </p>
<h3><a href="#ToC_179" name="LENSM50289">LocaleObject</a></h3>
<p>LocaleObject is used by APIs that require language or cultural sensitive processing. </p>
<p><hr><br></p>
<pre>typedef void *LocaleObject;</pre>
<p><br>
<hr>
<hr> </p>
<h3><a href="#ToC_182" name="LENSM50292">LocaleToken</a></h3>
<p>LocaleToken is used as a shorthand method for identifying locales. </p>
<p><hr><br></p>
<pre>typedef unsigned int LocaleToken;</pre>
<p><br>
<hr>
<hr> </p>
<h3><a href="#ToC_183" name="LENSM50293">struct UniLconv</a></h3>
<p>struct UniLconv describes the locale conventions. </p>
<p><hr><br></p>
<pre>struct UniLconv {
&nbsp;&nbsp;UniChar *decimal_point;
&nbsp;&nbsp;UniChar *thousands_sep;
&nbsp;&nbsp;short       *grouping;
&nbsp;&nbsp;UniChar *int_curr_symbol;
&nbsp;&nbsp;UniChar *currency_symbol;
&nbsp;&nbsp;UniChar *mon_decimal_point;
&nbsp;&nbsp;UniChar *mon_thousands_sep;
&nbsp;&nbsp;short       *mon_grouping;
&nbsp;&nbsp;UniChar *positive_sign;
&nbsp;&nbsp;UniChar *negative_sign;
&nbsp;&nbsp;short       int_frac_digits;
&nbsp;&nbsp;short       frac_digits;
&nbsp;&nbsp;short       p_cs_precedes;
&nbsp;&nbsp;short       p_sep_by_space;
&nbsp;&nbsp;short       n_cs_precedes;
&nbsp;&nbsp;short       n_sep_by_space;
&nbsp;&nbsp;short       p_sign_posn;
&nbsp;&nbsp;short       n_sign_posn;
&nbsp;&nbsp;short       os2_mondecpt;
&nbsp;&nbsp;UniChar *debit_sign;
&nbsp;&nbsp;UniChar *credit_sign;
&nbsp;&nbsp;UniChar *left_parenthesis;
&nbsp;&nbsp;UniChar *right_parenthesis;
};</pre>
<p><br>
<hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>decimal_point &nbsp;(UniChar *)&nbsp;
<dd>Non-monetary decimal point. <a name="SPTSP51241">&nbsp;</a>
<dt>thousands_sep &nbsp;(UniChar *)&nbsp;
<dd>Non-monetary thousands separator. <a name="SPTSP51242">&nbsp;</a>
<dt>grouping &nbsp;(short *)&nbsp;
<dd>Size of each group of digits in non-monetary quantities. <a name="SPTSP51243">&nbsp;</a>
<dt>int_curr_symbol &nbsp;(UniChar *)&nbsp;
<dd>International currency symbol and separator. <a name="SPTSP51244">&nbsp;</a>
<dt>currency_symbol &nbsp;(UniChar *)&nbsp;
<dd>Local currency symbol. <a name="SPTSP51245">&nbsp;</a>
<dt>mon_decimal_point &nbsp;(UniChar *)&nbsp;
<dd>Monetary decimal point. <a name="SPTSP51246">&nbsp;</a>
<dt>mon_thousands_sep &nbsp;(UniChar *)&nbsp;
<dd>Monetary thousands separator. <a name="SPTSP51247">&nbsp;</a>
<dt>mon_grouping &nbsp;(short *)&nbsp;
<dd>Size of each group of digits in monetary quantities. <a name="SPTSP51248">&nbsp;</a>
<dt>positive_sign &nbsp;(UniChar *)&nbsp;
<dd>Non-negative values sign. <a name="SPTSP51249">&nbsp;</a>
<dt>negative_sign &nbsp;(UniChar *)&nbsp;
<dd>Negative values sign. <a name="SPTSP51250">&nbsp;</a>
<dt>int_frac_digits &nbsp;(short)&nbsp;
<dd>Number of fractional digits for international currency. <a name="SPTSP51251">&nbsp;</a>
<dt>frac_digits &nbsp;(short)&nbsp;
<dd>Number of fractional digits for local currency. <a name="SPTSP51252">&nbsp;</a>
<dt>p_cs_precedes &nbsp;(short)&nbsp;
<dd>Nonnegative currency symbol 1-precedes, 0-succeeds. <a name="SPTSP51253">&nbsp;</a>
<dt>p_sep_by_space &nbsp;(short)&nbsp;
<dd>Nonnegative currency symbol 1-space, 0-no space. <a name="SPTSP51254">&nbsp;</a>
<dt>n_cs_precedes &nbsp;(short)&nbsp;
<dd>Negative currency symbol 1-precedes, 0-succeeds. <a name="SPTSP51255">&nbsp;</a>
<dt>n_sep_by_space &nbsp;(short)&nbsp;
<dd>Negative currency symbol 1-space, 0-no space. <a name="SPTSP51256">&nbsp;</a>
<dt>p_sign_posn &nbsp;(short)&nbsp;
<dd>Positioning of nonnegative monetary sign. <a name="SPTSP51257">&nbsp;</a>
<dt>n_sign_posn &nbsp;(short)&nbsp;
<dd>Positioning of negative monetary sign. <a name="SPTSP51258">&nbsp;</a>
<dt>os2_mondecpt &nbsp;(short)&nbsp;
<dd>OS2 currency symbol positioning. <a name="SPTSP51259">&nbsp;</a>
<dt>debit_sign &nbsp;(UniChar *)&nbsp;
<dd>Non-negative valued debit monetary symbol. <a name="SPTSP51260">&nbsp;</a>
<dt>credit_sign &nbsp;(UniChar *)&nbsp;
<dd>Negative valued credit monetary symbol. <a name="SPTSP51261">&nbsp;</a>
<dt>left_parenthesis &nbsp;(UniChar *)&nbsp;
<dd>Negative valued left parenthesis monetary symbol. <a name="SPTSP51262">&nbsp;</a>
<dt>right_parenthesis &nbsp;(UniChar *)&nbsp;
<dd>Negative valued right parenthesis monetary symbol.
</dl>
<p><hr>
<hr> </p>
<h3><a href="#ToC_175" name="LENSM50285">uconv_attribute_t</a></h3>
<p>uconv_attribute_t This structure describes the attributes and characteristics of a conversion object. All of these fields are
queryable through UniQueryUconvObject. Some of the fields are settable through UniSetUconvObject; these are marked in
the descriptions. </p>
<p><hr><br></p>
<pre>typedef struct _uconv_attribute_t {
&nbsp;&nbsp;unsigned long  version;
&nbsp;&nbsp;char           mb_min_len;
&nbsp;&nbsp;char           mb_max_len;
&nbsp;&nbsp;char           usc_min_len;
&nbsp;&nbsp;char           usc_max_len;
&nbsp;&nbsp;unsigned short esid;
&nbsp;&nbsp;char           options;
&nbsp;&nbsp;char           state;
&nbsp;&nbsp;conv_endian_t  endian;
&nbsp;&nbsp;unsigned long  displaymask;
&nbsp;&nbsp;unsigned long  converttype;
&nbsp;&nbsp;unsigned short subchar_len;
&nbsp;&nbsp;unsigned short subuni_len;
&nbsp;&nbsp;char           subchar[16];
&nbsp;&nbsp;UniChar        subuni[8];
} uconv_attribute_t;
typedef uconv_attribute_t *uconv_attribute_t;</pre>
<p><br>
<hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>version &nbsp;(unsigned long)&nbsp;
<dd>Version (must be zero). Settable. <a name="SPTSP51218">&nbsp;</a>
<dt>mb_min_len &nbsp;(char)&nbsp;
<dd>Minimum character size. <a name="SPTSP51219">&nbsp;</a>
<dt>mb_max_len &nbsp;(char)&nbsp;
<dd>Maximum character size. <a name="SPTSP51220">&nbsp;</a>
<dt>usc_min_len &nbsp;(char)&nbsp;
<dd>UCS minimum character size. <a name="SPTSP51221">&nbsp;</a>
<dt>usc_max_len &nbsp;(char)&nbsp;
<dd>UCS maximum character size. <a name="SPTSP51222">&nbsp;</a>
<dt>esid &nbsp;(unsigned short)&nbsp;
<dd>Encoding scheme ID. <a name="SPTSP51223">&nbsp;</a>
<dt>options &nbsp;(char)&nbsp;
<dd>Substitution options. Settable. <a name="SPTSP51224">&nbsp;</a>
<dt>state &nbsp;(char)&nbsp;
<dd>Current state. Settable. <a name="SPTSP51225">&nbsp;</a>
<dt>endian &nbsp;(conv_endian_t)&nbsp;
<dd>Source and target chain. Settable. <a name="SPTSP51226">&nbsp;</a>
<dt>displaymask &nbsp;(unsigned long)&nbsp;
<dd>Display and data mask. Settable. <a name="SPTSP51227">&nbsp;</a>
<dt>converttype &nbsp;(unsigned long)&nbsp;
<dd>Conversion type. Settable. <a name="SPTSP51228">&nbsp;</a>
<dt>subchar_len &nbsp;(unsigned short)&nbsp;
<dd>MBCS sub-character length. Settable. <a name="SPTSP51229">&nbsp;</a>
<dt>subuni_len &nbsp;(unsigned short)&nbsp;
<dd>Unicode sub-character length. Settable. <a name="SPTSP51230">&nbsp;</a>
<dt>subchar[16] &nbsp;(char)&nbsp;
<dd>MBCS sub-characters. Settable. <a name="SPTSP51231">&nbsp;</a>
<dt>subuni[8] &nbsp;(UniChar)&nbsp;
<dd>Unicode sub-characters. Settable.
</dl>
<p><hr>
<hr> </p>
<h3><a href="#ToC_184" name="LENSM50294">UconvObject</a></h3>
<p>UconvObject is used by APIs that convert to and from UniCode. </p>
<p><hr><br></p>
<pre>typedef void *UconvObject;</pre>
<p><hr>
<hr> </p>
<h3><a href="#ToC_799" name="LENSM70999">UNICTYPE</a></h3>
<p>The UNICTYPE structure provides a range of information regarding the type of a character. </p>
<pre><hr>
<br>
typedef struct {
&nbsp;&nbsp;USHORT itype;
&nbsp;&nbsp;CHAR bidi;
&nbsp;&nbsp;CHAR charset;
&nbsp;&nbsp;USHORT extend;
&nbsp;&nbsp;USHORT codepage;
} UNICTYPE;</pre>
<p><br>
<hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>itype &nbsp;(USHORT)&nbsp;
<dd>XPG/4 type attributes (CTYPE1).
<dd>&nbsp;
<dt>bidi &nbsp;(CHAR)
<dd><a name="SPTSP51218">&nbsp;</a> BiDi type attributes (CTYPE2).
<dd>&nbsp;
<dt>charset &nbsp;(CHAR)
<dd>Character set (CHARSET).
<dd>&nbsp;
<dt>extend &nbsp;(USHORT)
<dd>Win32 Extended attributes (CTYPE3).
<dd>&nbsp;
<dt>codepage &nbsp;(USHORT)
<dd>Codepage bits.<br>
<dd>&nbsp;
</dl>
<p><hr>
<hr> </p>
<h3><a href="#ToC_176" name="LENSM50286">udcrange_t</a></h3>
<p>udcrange_t provides a set of ranges of characters that make up the user-defined character range. </p>
<p><hr><br></p>
<pre>typedef struct {
&nbsp;&nbsp;unsigned short     first;
&nbsp;&nbsp;unsigned short     last;
} udcrange_t;</pre>
<p><br>
<hr> </p>
<p><strong>Parameters</strong>
<dl>
<dt>first &nbsp;(unsigned short)&nbsp;
<dd>First code point. <a name="SPTSP51233">&nbsp;</a>
<dd>&nbsp;
<dt>last &nbsp;(unsigned short)&nbsp;
<dd>Last code point.
</dl>
<p>&nbsp;</p>
<p><hr>
<hr> </p>
<h3><a href="#ToC_185" name="LENSM50295">ulsBool</a></h3>
<p>ulsBool </p>
<p><hr><br></p>
<pre>typedef int ulsBool;<br>
&nbsp;&nbsp;0 - FALSE<br>
&nbsp;&nbsp;1 - TRUE</pre>
<p><br>
<hr>
<hr> </p>
<h3><a href="#ToC_178" name="LENSM50288">UniChar</a></h3>
<p>A unicode character. Unicode is code that is independent of language and culture, and supports multiple simultaneous
character sets. </p>
<p><hr><br></p>
<pre>typedef unsigned short UniChar;</pre>
<p><br>
<hr>
<hr> </p>
<h3><a href="#ToC_186" name="LENSM50296">XformObject</a></h3>
<p>XformObject is used to perform string transformations. </p>
<p><hr><br></p>
<pre>typedef void *XformObject;</pre>
<p><br>
<hr> </p>



<h1><a href="#ToC" name="NOTICES">Notices</a></h1>
<HR>
<h3>Unicode Functions (OS/2 Warp)</h3>
<p><b>Second Edition (October 1997)</b></p>
<p>
<b>The following paragraph does not apply to the United
Kingdom or any
country where such provisions are inconsistent with local
law:</b>
</p>

<p>INTERNATIONAL
BUSINESS MACHINES CORPORATION PROVIDES THIS PUBLICATION
"AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR
IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.
</p>

<p>Some states do not allow disclaimer of express or implied warranties
in certain transactions, therefore, this statement may not
apply to you.
</p>

<p>
This publication could include technical inaccuracies or typographical
errors.  Changes are periodically made to the information herein;
these changes will be incorporated in new editions of the publication.
IBM may make improvements and/or changes in the product(s) and/or
the program(s) described in this publication at any time.
</p>

<p>
This publication was developed for products and services offered in the
United States of America.  IBM may not offer the products, services, or
features
discussed in this document in other countries, and the information is
subject to change without notice.
Consult your local IBM representative for information on the products,
services, and features available
in your area.</p>

<p>Requests for technical information about IBM
products should be made to your IBM reseller or IBM marketing
representative.
</p>
<HR>

<h2>Copyright Notices</h2>

<p><b>COPYRIGHT LICENSE:</b>
This publication contains printed sample application programs
in source language, which illustrate OS/2 programming techniques.
You may copy, modify, and distribute these sample programs in any
form without payment to IBM, for the purposes of developing, using,
marketing or distributing application programs conforming to the OS/2
application programming interface.
</p>
<p>
Each copy of any portion of these sample programs or any derivative work,
which is distributed to others,
must include a copyright notice as follows:
"&#169 (your company name) (year).  All rights reserved."   <!do not
change this>
</p>
<p><b>&#169 Copyright International Business Machines
Corporation 1997.  All rights reserved.</b>
</p>

<p>Note to U.S. Government Users: Documentation related to
restricted rights - use, duplication or disclosure is
subject to
restrictions set forth in GSA ADP Schedule Contract with IBM
Corp.
</p>
<HR>

<h2>Disclaimers</h2>

<p>References in this publication to IBM products, programs,
or services
do not imply that IBM intends to make these available in all countries
in which IBM operates.
Any reference to an IBM product, program or service is not intended to
state or imply that only that IBM product, program,
or service may be used.
Subject to IBM's valid intellectual property or other legally
protectable rights, any functionally equivalent product, program, or
service may be used instead of the IBM product, program, or service.
The evaluation and verification of operation in conjunction with other
products,
except those expressly designated by IBM, are the responsibility of the
user.
</p>

<p>IBM may have patents or pending patent applications covering
subject matter in this document.
The furnishing of this document does not give you any
license to these patents.
You can send license inquiries, in writing, to:
</p>

<p>
IBM Director of Licensing
<br>
IBM Corporation
<br>
500 Columbus Avenue
<br>
Thornwood, NY  10594
<br>
U.S.A.
</p>

<p>
Asia-Pacific users can inquire, in writing, to the IBM Director of
Intellectual Property and Licensing, IBM World Trade Asia Corporation,
2-31 Roppongi 3-chome, Minato-ku, Tokyo 106, Japan.
</p>

<p>
Licensees of this program who wish to have information about it for
the purpose of enabling: (i) the exchange of information between
independently created programs and other programs (including this
one) and (ii) the mutual use of the information which has been
exchanged, should contact IBM Corporation, Department LZKS,
11400 Burnet Road, Austin, TX 78758 U.S.A.  Such information may be
available, subject to appropriate terms and conditions, including
in some cases, payment of a fee.
</p>
<p>
The following terms are trademarks of the IBM Corporation in
the United States or other countries or both:
</p>
<p><! If you use any other IBM trademarks, add them here.  Look them up on
the web page at http://www.ibm.com/Legal/copytrade.html.  The old book
used the generic Merlin trademark wording, which is no longer necessary
and obsolete, to boot>
IBM
<br>
OS/2
<br>
</p>

<p>
The following terms are trademarks of other companies:
</p> <! If you use anything by these companies, use the exact wording in
this section, even if it includes things you don't use and omits things
you do use.  If you don't feel like scanning for them, there's no harm in
leaving them all in.>
<p>

Microsoft, Windows, Windows NT&reg;, and the Windows 95
logo                        <! new>
are trademarks or registered trademarks of Microsoft Corporation. <br>
</p>

<p>
Other company, product, and service names, which may be denoted
by a double asterisk (**), may be trademarks
or service marks of others. <! you don't have to use the **>
</p>
</body>
</html>
