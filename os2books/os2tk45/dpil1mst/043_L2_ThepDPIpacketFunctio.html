<HTML>
<HEAD>
<TITLE>The pDPIpacket() Function</TITLE>
</HEAD>
<BODY>
<H1>The pDPIpacket() Function</H1><!-- entering slot 46 -->
<P>
<B>Syntax</B>
<PRE>#include &lt;snmp_dpi.h&gt;

snmp_dpi_hdr *pDPIpacket(unsigned char *packet_p);
</PRE>

<P>
<B>Parameters</B><!-- lm: 0x2 1 -->
<UL>
<P>
packet_p<!-- lm: 0x11 3 -->
<UL> A pointer to a serialized DPI packet.<!-- lm: 0x2 1 -->
</UL>
<P>
<B>Return Values</B><!-- lm: 0x2 6 -->
<UL>
<P>
If successful, a pointer to a DPI parse tree (snmp_dpi_hdr) is returned.
 Memory for the parse tree has been dynamically allocated, and it is the
callers responsibility to free it when no longer needed. You can use the
fDPIparse() function to free the parse tree.<!-- lm: 0x2 6 -->
<P>
If failure, a NULL pointer is returned.<!-- lm: 0x2 1 -->
</UL>
<P>
<B>Description</B>
<P>
The pDPIpacket() function parses the buffer pointed to by the<I> packet_p
</I>parameter.  It ensures that the buffer contains a valid DPI packet and
that the packet is for a DPI version and release that is supported by the
DPI functions in use.
<P>
<B>Examples</B>
<PRE>  #include &lt;snmp_dpi.h&gt;  unsigned char       *pack_p;
  snmp_dpi_hdr        *hdr_p;

  hdr_p = pDPIpacket(pack_p);       /* parse incoming packet */
                                    /* assume it's in pack_p */
  if (hdr_p) {
     /* analyze packet, and handle it */
  }
</PRE>

<P>
<B>Related Information</B><!-- lm: 0x2 6 -->
<UL>
<P>
<A HREF="057_L2_Thesnmp_dpi_hdrStruc.html">The snmp_dpi_hdr Structure</A><!-- lm: 0x2 6 -->
<BR>
<A HREF="073_L2_Thesnmp_dpihIncludeF.html">The snmp_dpi.h Include File</A><!-- lm: 0x2 6 -->
<BR>
<A HREF="033_L2_ThefDPIparseFunction.html">The fDPIparse() Function</A><!-- lm: 0x2 1 -->
</UL>

<P><HR>

<A HREF="042_L2_ThemkDPIunregisterFu.html">[Back: The mkDPIunregister() Function]</A> <BR>
<A HREF="044_L1_TransportRelatedDPIA.html">[Next: Transport-Related DPI API Functions]</A> 
</BODY>
</HTML>
