<HTML>
<HEAD>
<TITLE>Handling Multiple Sockets</TITLE>
</HEAD>
<BODY>
<H1>Handling Multiple Sockets</H1><!-- entering slot 44 -->
<P>
Applications can handle multiple sockets. In such situations, you can use
the select() call to determine the sockets that have data to be read, those
that are ready for data to be written, and the sockets that have pending
exception conditions. If the timeout parameter is positive, select() waits
up to the amount of time indicated for at least one socket to become ready
on the indicated conditions. This is useful for applications servicing multiple
connections that cannot afford to block waiting for data on one connection.

<P>
There are two versions of the select() call: a TCP/IP Version 4.21 for OS/2
Warp version and a version modeled after the BSD select() call. An example
of how the TCP/IP Version 4.21 for OS/2 Warp select() call is used is shown
in the next figure. For information on using the BSD version of the select()
call, see <A HREF="197_L2_select.html">select()</A>.
<BR>
An Application Using the select() Call
<BR>

<PRE>...
int socks[3];    /* array of sockets */
long timeout = MAX_TIMEOUT;
int s1, s2, s3;
int number_ready;
...
/* put sockets to check in socks[] */
socks[0] = s1;     /* read socket number */
socks[1] = s2;     /* write socket number */
socks[2] = s3;     /* second write socket number */

/* check for READ on s1, WRITE on s2 and s3 */
number_ready = os2_select(socks, 1, 2, 0, timeout);
</PRE>

<P>
In this example, the application indicates the sockets to be checked for
readability or readiness for writing.

<P><HR>

<A HREF="040_L2_ServerConnections.html">[Back: Server Connections]</A> <BR>
<A HREF="042_L2_ConnectionlessDatagr.html">[Next: Connectionless Datagram Services]</A> 
</BODY>
</HTML>
