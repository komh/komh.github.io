<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Synchronization Features</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Synchronization Features</H1><!-- entering slot 75 -->
<P>
The ability to synchronize events is essential for multimedia applications.
For example, you might decide to display a certain bitmap (an image of fireworks
bursting) at precisely the same time you play an audio waveform (a specific
cymbal crash during the "Star Spangled Banner"). From a standard OS/2 application
perspective, two independent threads or a single thread might control these
events. However, there is no way for either of these approaches to guarantee
that both events will occur within a specified time span. The longer the
time delay between events, the more likely a user will notice the loss of
synchronization.
<P>
The sync/stream subsystem design supports multimedia application synchronization
requirements by ensuring that program events such as the output of specific
data elements (digital audio, image, MIDI audio, and so on) can be reliably
synchronized within very narrow real-time limits. The sync/stream subsystem
also reduces the complexity of application code required to synchronize
events.
<P>
Being able to synchronize user-oriented and system-driven events is also
important to multimedia application developers. For example, an application
might need to adjust the tempo of a musical playback sequence while responding
to the user's movement of the mouse or pressing arrow keys ( ) on the
keyboard. Any perceivable delay in response might be unacceptable. Of more
urgent importance is a pilot training program that requires the trainee
to press a key to respond to a ground-proximity alarm. If the trainee senses
a delay between pressing the key and the alarm sound muting, it would be
reasonable to expect the real cockpit controls to react the same way. This
false expectation might lead to a crash in real life.
<P>
SSM synchronization functions simplify a programmer's work. For example,
instead of establishing large and complex control structures to synchronize
a group of streams, a programmer needs only to identify the streams as part
of a group.
<P>
The sync/stream subsystem design includes several features that provide
for simple, effective control of real-time event synchronization:<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->Master/slave relationship<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->Sync pulse generation<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->Sync pulse processing<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->Sync/stream subsystem events<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->Null stream handler<!-- lm: 0x2 1 -->
</UL>
<P>
These features exploit the multitasking capability of OS/2 to prevent specific
regions of code and data in physical memory from being paged to disk. This
ensures that the required modules can process data and requests in a real-time
manner, avoiding the latency that would arise should those critical regions
be swapped out when needed.

<P><HR>

<A HREF="059_L2_StreamHandlerArchite.html">[Back: Stream Handler Architecture]</A> <BR>
<A HREF="061_L3_MasterSlaveRelations.html">[Next: Master/Slave Relationship]</A> 
</BODY>
</HTML>
