<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Message Flags</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Message Flags</H1><!-- entering slot 1705 -->
<P>
Applications decode WM_CHAR messages by examining individual bits in the
flag word contained in the first message parameter (<I>mp1</I>) that the
system passes with every WM_CHAR message.  The type of flag word indicates
the nature of the message.  The system can set the bits in the flag word
in various combinations.  For example, a WM_CHAR message can have the KC_CHAR,
KC_SCANCODE, and KC_SHIFT attribute bits all set at the same time.  An application
can use the following list of flag values to test the flag word and determine
the nature of a WM_CHAR message:
<PRE>┌───────────────┬─────────────────────────────────────────────┐
│Flag Name      │Description                                  │
├───────────────┼─────────────────────────────────────────────┤
│KC_ALT         │Indicates that the Alt key was down when the │
│               │message was generated.                       │
├───────────────┼─────────────────────────────────────────────┤
│KC_CHAR        │Indicates that the message contains a valid  │
│               │character code for a key, typically an ASCII │
│               │character code.                              │
├───────────────┼─────────────────────────────────────────────┤
│KC_COMPOSITE   │In combination with the KC_CHAR flag, this   │
│               │flag indicates that the character code is a  │
│               │combination of the key that was pressed and  │
│               │the previous dead key.  This flag is used to │
│               │create characters with diacritical marks.    │
├───────────────┼─────────────────────────────────────────────┤
│KC_CTRL        │Indicates that the Ctrl key was down when the│
│               │message was generated.                       │
├───────────────┼─────────────────────────────────────────────┤
│KC_DEADKEY     │In combination with the KC_CHAR flag, this   │
│               │flag indicates that the character code       │
│               │represents a dead-key glyph (such as an      │
│               │accent).  An application displays the        │
│               │dead-key glyph and does not advance the      │
│               │cursor.  Typically, the next WM_CHAR message │
│               │is a KC_COMPOSITE message, containing the    │
│               │glyph associated with the dead key.          │
├───────────────┼─────────────────────────────────────────────┤
│KC_INVALIDCHAR │Indicates that the character is not valid for│
│               │the current translation tables.              │
├───────────────┼─────────────────────────────────────────────┤
│KC_INVALIDCOMP │Indicates that the character code is not     │
│               │valid in combination with the previous dead  │
│               │key.                                         │
├───────────────┼─────────────────────────────────────────────┤
│KC_KEYUP       │Indicates that the message was generated when│
│               │the user released the key. If this flag is   │
│               │clear, the message was generated when the    │
│               │user pressed the key.  An application can use│
│               │this flag to determine key-down and key-up   │
│               │events.                                      │
├───────────────┼─────────────────────────────────────────────┤
│KC_LONEKEY     │In combination with the KC_KEYUP flag, this  │
│               │flag indicates that the user pressed no other│
│               │key while this key was down.                 │
├───────────────┼─────────────────────────────────────────────┤
│KC_PREVDOWN    │In combination with the KC_VIRTUALKEY flag,  │
│               │this flag indicates that the virtual key was │
│               │pressed previously. If this flag is clear,   │
│               │the virtual key was not previously pressed.  │
├───────────────┼─────────────────────────────────────────────┤
│KC_SCANCODE    │Indicates that the message contains a valid  │
│               │scan code generated by the keyboard when the │
│               │user pressed the key. The system uses the    │
│               │scan code to identify the character code in  │
│               │the current code page; therefore, most       │
│               │applications do not need the scan code unless│
│               │they cannot identify the key that the user   │
│               │pressed. WM_CHAR messages generated by user  │
│               │keyboard input generally have a valid scan   │
│               │code, but WM_CHAR messages posted to the     │
│               │queue by other applications might not contain│
│               │a scan code.                                 │
├───────────────┼─────────────────────────────────────────────┤
│KC_SHIFT       │Indicates that the Shift key was down when   │
│               │the message was generated.                   │
├───────────────┼─────────────────────────────────────────────┤
│KC_TOGGLE      │Toggles on and off every time the user       │
│               │presses a specified key. This is important   │
│               │for keys like NumLock, which have an on or   │
│               │off state.                                   │
├───────────────┼─────────────────────────────────────────────┤
│KC_VIRTUALKEY  │Indicates that the message contains a valid  │
│               │virtual-key code for a key. Virtual keys     │
│               │typically correspond to function keys.       │
│               │For those using hooks, when this bit is set, │
│               │KC_SCANCODE should usually be set as well.   │
└───────────────┴─────────────────────────────────────────────┘
</PRE>

<P>
The<I> mp1</I> and<I> mp2</I> parameters of the WM_CHAR message contain
information describing the nature of a keyboard input event, as follows:
<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->SHORT1FROMMP (<I>mp1</I>) contains the flag word.
<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->CHAR3FROMMP (<I>mp1</I>) contains the key-repeat count.
<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->CHAR4FROMMP (<I>mp1</I>) contains the scan code.<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->SHORT1FROMMP (<I>mp2</I>) contains the character code.
<!-- lm: 0x2 3 -->
<BR>
<LI><!-- lm: 0x2 6 -->SHORT2FROMMP (<I>mp2</I>) contains the virtual key
code.<!-- lm: 0x2 1 -->
</UL>
<P>
An application window procedure should return TRUE if it processes a particular
WM_CHAR message or FALSE if it does not. Typically, applications respond
to key-down events and ignore key-up events.
<P>
The following sections describe the different types of WM_CHAR messages.
 Generally, an application decodes these messages by creating layers of
conditional statements that discriminate among the different combinations
of flag and code attributes that can occur in a keyboard message.
<P>


<P><HR>

<A HREF="1667_L3_KeyboardMessages.html">[Back: Keyboard Messages]</A> <BR>
<A HREF="1669_L4_KeyDownorKeyUpEvents.html">[Next: Key-Down or Key-Up Events]</A> 
</BODY>
</HTML>
