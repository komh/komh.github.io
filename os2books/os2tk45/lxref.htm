<HTML>
<HEAD>
<TITLE>IBM OS/2 16/32-bit Linear eXecutable Module Format (LX) Specification</TITLE>
</HEAD>
<BODY CLASS=WM-BODY>

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING1></A>
<A NAME=LINK-FM-firstpage></A><H1 CLASS=Title></H1>
<HR CLASS=Title>
<H1 CLASS=Title>IBM OS/2 16/32-bit Linear eXecutable Module Format (LX)</H1>
<HR CLASS=Title>
<P CLASS=Body> </P>
<P CLASS=Body> </P>
<P CLASS=Body> </P>
<P CLASS=Body> Revision 11</P>
<P CLASS=Body> June 14, 2001 11:00 am</P>
<P CLASS=Body>
<TT CLASS="Uppercase Body">
The information furnished herein is on an "as-is" basis, and IBM makes no
warranties, either express or implied, including, but not limited to, the
implied warranties of merchantability and fitness for a particular purpose.
In no event will IBM be liable for any damages arising from the use of the
information contained herein, including infringement of any proprietary rights,
or for any lost profits or other incidental and/or consequential damages, even
if IBM has been advised of the possibility of such damages.
</TT>
</P>
<P CLASS=Body>
FURTHERMORE, THIS DOCUMENTATION IS IN A PRELIMINARY FORM; IS NOT COMPLETE; HAS
NOT YET BEEN TESTED, VALIDATED OR REVIEWED; MAY CONTAIN ERRORS, OMISSIONS,
INACCURACIES OR THE LIKE; AND IS SUBJECT TO BEING CHANGED, REVISED OR
SUPERSEDED IN WHOLE OR IN PART BY IBM. IBM DOES NOT ASSUME ANY RESPONSIBILITY
TO NOTIFY ANY PARTIES, COMPANIES, USERS, AND OR OTHERS OF DEFECTS,
DEFICIENCIES, CHANGES, ERRORS OR OTHER FAILINGS OR SHORTCOMING OF THE
DOCUMENTATION.
</P>
<P CLASS=Body>
This document is being furnished by IBM for evaluation/development feedback
purposes only and IBM does not guarantee that IBM will make this document
generally available. RECIPIENT'S USE OF THIS DOCUMENT IS LIMITED TO RECIPIENT'S
PERSONAL USE FOR THE SOLE PURPOSE OF CREATING TOOLS FOR THE OS/2 OPERATING
SYSTEM.
</P>
<P CLASS=Body>
IBM may have patents or pending patent applications covering subject matter
in this document. The furnishing of this document does not give you any
license to these patents. You can send license inquiries, in writing, to
the IBM Director of Commercial Relations, IBM Corporation, Purchase, NY, 10577.
</P>
<P CLASS=Body>
The following copyright notice protects this document under the Copyright
laws of the United States and other countries which prohibits such actions
as, but not limited to, copying, distributing, modifying, and making
derivative works.
</P>
<P CLASS=Copyright>
&copy; Copyright International Business Machines Corporation, 1991-2001.
All Rights Reserved.
</P>
<P CLASS=Body>
Notice to US Government Users - Documentation related to restricted
rights - Use, duplication or disclosure is subject to restrictions set
forth in GSA ADP Schedule Contract with IBM Corp.
</P>
<P CLASS=Body>
The following terms are trademarks of International Business Machines
Corporation in the United States and/or other countries:
</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>IBM<BR>Operating System/2<BR>OS/2
</DL>

<A NAME=LINK-TOC-firstpage></A>
<HR CLASS=Contents>
<H1 CLASS=Contents>Contents</H1>
<A NAME=LINK-TOC-lastpage></A>

<DIV CLASS=WM-DIV-TOC>
<!-- TOC -->
<DL>
<DT><A NAME="TOC-1-0" HREF="#HEADING-1-0"><B>1   </B> - Introduction</A>
<DD>
<DT><A NAME="TOC-2-0" HREF="#HEADING-2-0"><B>2  </B> - Linear Executable Module Format</A>
<DD>
<DT><A NAME="TOC-2-1" HREF="#HEADING-2-1"><B>2.1  </B> - Linear Executable Sections</A>
<DD>
<DT><A NAME="TOC-2-2" HREF="#HEADING-2-2"><B>2.2  </B> - LX Header Fields</A>
<DD>
<DT><A NAME="TOC-2-3" HREF="#HEADING-2-3"><B>2.3  </B> - Program (EXE) startup registers and Library entry registers</A>
<DD>
<DT><A NAME="TOC-2-4" HREF="#HEADING-2-4"><B>2.4  </B> - Object Table</A>
<DD>
<DT><A NAME="TOC-2-5" HREF="#HEADING-2-5"><B>2.5  </B> - Object Page Table</A>
<DD>
<DT><A NAME="TOC-2-6" HREF="#HEADING-2-6"><B>2.6  </B> - Resource Table</A>
<DD>
<DT><A NAME="TOC-2-7" HREF="#HEADING-2-7"><B>2.7  </B> - Resident or Non-resident Name Table Entry</A>
<DD>
<DT><A NAME="TOC-2-8" HREF="#HEADING-2-8"><B>2.8  </B> - Entry Table</A>
<DD>
<DT><A NAME="TOC-2-8-1" HREF="#HEADING-2-8-1"><B>2.8.1  </B> - Unused Entry</A>
<DD>
<DT><A NAME="TOC-2-8-2" HREF="#HEADING-2-8-2"><B>2.8.2  </B> - 16-bit Entry</A>
<DD>
<DT><A NAME="TOC-2-8-3" HREF="#HEADING-2-8-3"><B>2.8.3  </B> - 286 Call Gate Entry</A>
<DD>
<DT><A NAME="TOC-2-8-4" HREF="#HEADING-2-8-4"><B>2.8.4  </B> - 32-bit Entry</A>
<DD>
<DT><A NAME="TOC-2-8-5" HREF="#HEADING-2-8-5"><B>2.8.5  </B> - Forwarder Entry</A>
<DD>
<DT><A NAME="TOC-2-9" HREF="#HEADING-2-9"><B>2.9  </B> - Module Format Directives Table</A>
<DD>
<DT><A NAME="TOC-2-9-1" HREF="#HEADING-2-9-1"><B>2.9.1  </B> - Verify Record Directive Table</A>
<DD>
<DT><A NAME="TOC-2-10" HREF="#HEADING-2-10"><B>2.10  </B> - Per-Page Checksum</A>
<DD>
<DT><A NAME="TOC-2-11" HREF="#HEADING-2-11"><B>2.11  </B> - Fixup Page Table</A>
<DD>
<DT><A NAME="TOC-2-12" HREF="#HEADING-2-12"><B>2.12  </B> - Fixup Record Table</A>
<DD>
<DT><A NAME="TOC-2-12-1" HREF="#HEADING-2-12-1"><B>2.12.1  </B> - Internal Fixup Record</A>
<DD>
<DT><A NAME="TOC-2-12-2" HREF="#HEADING-2-12-2"><B>2.12.2  </B> - Import by Ordinal Fixup Record</A>
<DD>
<DT><A NAME="TOC-2-12-3" HREF="#HEADING-2-12-3"><B>2.12.3  </B> - Import by Name Fixup Record</A>
<DD>
<DT><A NAME="TOC-2-12-4" HREF="#HEADING-2-12-4"><B>2.12.4  </B> - Internal Entry Table Fixup Record</A>
<DD>
<DT><A NAME="TOC-2-12-5" HREF="#HEADING-2-12-5"><B>2.12.5  </B> - Internal Chaining Fixups</A>
<DD>
<DT><A NAME="TOC-2-13" HREF="#HEADING-2-13"><B>2.13  </B> - Import Module Name Table</A>
<DD>
<DT><A NAME="TOC-2-14" HREF="#HEADING-2-14"><B>2.14  </B> - Import Procedure Name Table</A>
<DD>
<DT><A NAME="TOC-2-15" HREF="#HEADING-2-15"><B>2.15  </B> - Preload Pages</A>
<DD>
<DT><A NAME="TOC-2-16" HREF="#HEADING-2-16"><B>2.16  </B> - Demand Load Pages</A>
<DD>
<DT><A NAME="TOC-2-17" HREF="#HEADING-2-17"><B>2.17  </B> - Iterated Data Pages</A>
<DD>
<DT><A NAME="TOC-2-18" HREF="#HEADING-2-18"><B>2.18  </B> - Debug Information</A>
<DD>
</DL>
</DIV>

<HR CLASS=Heading1>
<A NAME=LINK-01-firstpage></A>
<A NAME=HEADING-1-0></A>
<H1 CLASS=Heading1><A HREF="#TOC-1-0">1   Introduction</A></H1>
<P CLASS=BodyFirst>This document describes the IBM OS/2 16/32-bit Linear
eXecutable Module Format (LX).  This is the load module format understood
by the OS/2 32-bit system loader (for OS/2 version 2.0 and greater).  LX
load modules are created by Linear Executable linker utilities (such as IBM
LINK386).  A Linear Executable linker must be used in order to create 32-bit
(flat-model) OS/2 programs; however, the LX format also allows for any
combination of 16-bit and 32-bit code or data sections to exist within the
same module.

<HR CLASS=Heading1>
<A NAME=HEADING-2-0></A>
<H1 CLASS=Heading1><A HREF="#TOC-2-0">2  Linear Executable Module Format</A></H1>
<P CLASS=Body>
The following sections describe the Linear Executable Module Format in detail.
</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-1></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-1">2.1   Linear Executable Sections</A></H1>

<P CLASS=Body>
The LX module header may optionally be preceded by a DOS 2 compatible module
header. The DOS 2 compatible module header is identified by the first two bytes
of the header containing the signature characters "MZ". If the DOS 2 compatible
module header is absent then the module will start with the LX module header.
</P>
<P CLASS=Body>
If a module begins with a DOS 2 compatible module header, then the following
technique should be used to locate the LX module header, if present. The word
at offset 18h in the DOS 2 compatible module header is the offset to the DOS
relocation table. If this offset is 40h, then the doubleword at offset 3Ch in
the DOS 2 compatible module header contains the offset, from the beginning of
the file, to the new module header. This may be an LX module header and can be
identified by the first two bytes of the header containing the signature
characters "LX". If a valid module header is not found, then the file is a
DOS 2 compatible module.
</P>
<P CLASS=Body>
The remainder of the DOS 2 compatible module header will describe a DOS stub
program. The stub may be any valid program but will typically be a program
which displays an error message. It may also be a DOS version of the LX
program.
</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-1:  <B CLASS=FigureTitle>DOS 2.0 Section (</B>Discarded after processed by the loader)</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=CellBody> DOS 2 Compatible EXE header</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 1Ch</P>
</TD><TD><P CLASS=CellBody> unused</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 24h</P>
</TD><TD><P CLASS=CellBody> OEM Identifier</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 26h</P>
</TD><TD><P CLASS=CellBody> OEM Info</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 3Ch</P>
</TD><TD><P CLASS=CellBody> Offset to Linear EXE Header</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 40h</P>
</TD><TD><P CLASS=CellBody> DOS 2.0 Stub Program and Relocation Table</P>
</TD></TR></TABLE><TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-2:  Linear Executable Module Header (In-memory copy maintained)</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> xxh</P>
</TD><TD><P CLASS=CellBody> Executable Information</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD><P CLASS=CellBody> Module Information</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD><P CLASS=CellBody> Loader Section Information</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD><P CLASS=CellBody> Table Offset Information</P>
</TD></TR></TABLE><TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-3:  Loader Section (In-memory copy maintained)</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody> Object Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Object Page Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Resource Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Resident Name Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Entry Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Module Format Directives Table (Optional)</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Resident Directives Data (Optional) </P>
<P CLASS=CellBody> (Verify Record)</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Per-Page Checksum</P>
</TD></TR></TABLE><TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-4:  Fixup Section (In-memory copy maintained)</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody> Fixup Page Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Fixup Record Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Import Module Name Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Import Procedure Name Table</P>
</TD></TR></TABLE><P CLASS=Note3> The Fixup Section must immediately follow the Loader Section in the executable file. Although they are defined as two separate sections, the OS/2 loader currently treats these two sections as one section.</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-5:  Data Section (No In-memory copy maintained)</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody> Preload Pages</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Demand Load Pages</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Iterated Pages</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Non-Resident Name Table</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Non-Resident Directives Data (Optional)</P>
<P CLASS=CellBody> (To be Defined) </P>
</TD></TR></TABLE>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-6:  Debug Section (Not used by the Loader)</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody>Debugger Information</P>
</TD></TR></TABLE><P CLASS=Note>Note:  The standard section ordering of an LX module is the LX module header, the resident sections, the non-resident sections and finally the debug section (if present). It is also permissable to use an alternate section ordering of the LX module header, the non-resident sections, the resident sections and finally the debug section (if present).</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-2></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-2">2.2   LX Header Fields</A></H1>

<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-7:  32-bit Linear EXE Header</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> "L" "X"</P>
</TD><TD><P CLASS=FigureBody> B-ORD</P>
</TD><TD><P CLASS=FigureBody> W-ORD</P>
</TD><TD><P CLASS=FigureBody> FORMAT LEVEL</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 08h</P>
</TD><TD><P CLASS=FigureBody> CPU TYPE</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OS TYPE</P>
</TD><TD><P CLASS=FigureBody> MODULE VERSION</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 10h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> MODULE FLAGS</P>
</TD><TD><P CLASS=FigureBody> MODULE # OF PAGES</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 18h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> EIP OBJECT #</P>
</TD><TD><P CLASS=FigureBody> EIP</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 20h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> ESP OBJECT #</P>
</TD><TD><P CLASS=FigureBody> ESP</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 28h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> PAGE SIZE</P>
</TD><TD><P CLASS=FigureBody> PAGE OFFSET SHIFT</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 30h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> FIXUP SECTION SIZE</P>
</TD><TD><P CLASS=FigureBody> FIXUP SECTION CHECKSUM</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 38h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> LOADER SECTION SIZE</P>
</TD><TD><P CLASS=FigureBody> LOADER SECTION CHECKSUM</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 40h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> OBJECT TABLE OFF</P>
</TD><TD><P CLASS=FigureBody> # OBJECTS IN MODULE</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 48h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> OBJECT PAGE TABLE OFF</P>
</TD><TD><P CLASS=FigureBody> OBJECT ITER PAGES OFF</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 50h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> RESOURCE TABLE OFFSET</P>
</TD><TD><P CLASS=FigureBody> #RESOURCE TABLE ENTRIES</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 58h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> RESIDENT NAME TBL OFF</P>
</TD><TD><P CLASS=FigureBody> ENTRY TABLE OFFSET</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 60h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> MODULE DIRECTIVES OFF</P>
</TD><TD><P CLASS=FigureBody> # MODULE DIRECTIVES</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 68h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> FIXUP PAGE TABLE OFF</P>
</TD><TD><P CLASS=FigureBody> FIXUP RECORD TABLE OFF</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 70h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> IMPORT MODULE TBL OFF</P>
</TD><TD><P CLASS=FigureBody> # IMPORT MOD ENTRIES</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 78h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> IMPORT PROC TBL OFF</P>
</TD><TD><P CLASS=FigureBody> PER-PAGE CHECKSUM OFF</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 80h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> DATA PAGES OFFSET</P>
</TD><TD><P CLASS=FigureBody> #PRELOAD PAGES</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 88h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> NON-RES NAME TBL OFF</P>
</TD><TD><P CLASS=FigureBody> NON-RES NAME TBL LEN</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 90h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> NON-RES NAME TBL CKSM</P>
</TD><TD><P CLASS=FigureBody> AUTO DS OBJECT #</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 98h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> DEBUG INFO OFF</P>
</TD><TD><P CLASS=FigureBody> DEBUG INFO LEN</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> A0h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> #INSTANCE PRELOAD</P>
</TD><TD><P CLASS=FigureBody> #INSTANCE DEMAND</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> A8h</P>
</TD><TD COLSPAN=3><P CLASS=FigureBody> HEAPSIZE</P>
</TD><TD><P CLASS=FigureBody> STACKSIZE</P>
</TD></TR></TABLE><P CLASS=Note>Note:  The OBJECT ITER PAGES OFF must either be 0 or set to the same value as DATA PAGES OFFSET in OS/2 2.0. I.e. iterated pages are required to be in the same section of the file as regular pages.</P>
<P CLASS=Note>Note:  Table offsets in the Linear EXE Header may be set to zero to indicate that the table does not exist in the EXE file and it's size is zero.</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>"L" "X" = DW Signature word.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The signature word is used by the loader to identify the EXE file as a valid 32-bit Linear Executable Module Format. "L" is low order byte. "X" is high order byte.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>B-ORD = DB Byte Ordering.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This byte specifies the byte ordering for the linear EXE format. The values are:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00H - Little Endian Byte Ordering.
<DT CLASS=Body3><DD CLASS=Body3>01H - Big Endian Byte Ordering.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>W-ORD = DB Word Ordering.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This byte specifies the Word ordering for the linear EXE format. The values are:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00H - Little Endian Word Ordering.
<DT CLASS=Body3><DD CLASS=Body3>01H - Big Endian Word Ordering.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>Format Level = DD Linear EXE Format Level.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The Linear EXE Format Level is set to 0 for the initial version of the 32-bit linear EXE format. Each incompatible change to the linear EXE format must increment this value. This allows the system to recognized future EXE file versions so that an appropriate error message may be displayed if an attempt is made to load them.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>CPU Type = DW Module CPU Type.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the type of CPU required by this module to run. The values are:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>01H - 80286 or upwardly compatible CPU is required to execute this module.
<DT CLASS=Body3><DD CLASS=Body3>02H - 80386 or upwardly compatible CPU is required to execute this module.
<DT CLASS=Body3><DD CLASS=Body3>03H - 80486 or upwardly compatible CPU is required to execute this module.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OS Type = DW Module OS Type.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the type of Operating system required to run this module. The currently defined values are:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00H - Unknown (any "new-format" OS)
<DT CLASS=Body3><DD CLASS=Body3>01H - OS/2 (default)
<DT CLASS=Body3><DD CLASS=Body3>02H - Windows<A REL=FOOTNOTE HREF="#FOOTNOTE-1" CLASS=Body3>[1]</A>
<DT CLASS=Body3><DD CLASS=Body3>03H - DOS 4.x
<DT CLASS=Body3><DD CLASS=Body3>04H - Windows 386
<DT CLASS=Body3><DD CLASS=Body3>05H - IBM Microkernel Personality Neutral
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MODULE VERSION = DD Version of the linear EXE module.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is useful for differentiating between revisions of dynamic linked modules. This value is specified at link time by the user.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MODULE FLAGS = DD Flag bits for the module.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The module flag bits have the following definitions.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00000001h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00000002h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00000004h = Per-Process Library Initialization.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>The setting of this bit requires the EIP Object # and EIP fields to have valid values. If the EIP Object # and EIP fields are valid and this bit is NOT set, then Global Library Initialization is assumed. Setting this bit for an EXE file is invalid.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>00000008h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00000010h = Internal fixups for the module have been applied.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>The setting of this bit in a Linear Executable Module indicates that each object of the module has a preferred load address specified in the Object Table Reloc Base Addr. If the module's objects can not be loaded at these preferred addresses, then the relocation records that have been retained in the file data will be applied.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>00000020h = External fixups for the module have been applied.
<DT CLASS=Body3><DD CLASS=Body3>00000040h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00000080h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00000100h = Incompatible with PM windowing.
<DT CLASS=Body3><DD CLASS=Body3>00000200h = Compatible with PM windowing.
<DT CLASS=Body3><DD CLASS=Body3>00000300h = Uses PM windowing API.
<DT CLASS=Body3><DD CLASS=Body3>00000400h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00000800h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00001000h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00002000h = Module is not loadable.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When the 'Module is not loadable' flag is set, it indicates that either errors were detected at link time or that the module is being incrementally linked and therefore can't be loaded.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>00004000h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00038000h = Module type mask.
<DT CLASS=Body3><DD CLASS=Body3>00000000h = Program module (EXE).
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>A module can not contain dynamic links to other modules that have the 'program module' type.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>00008000h = Library module (DLL).
<DT CLASS=Body3><DD CLASS=Body3>00010000h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00018000h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00020000h = Physical Device Driver module.
<DT CLASS=Body3><DD CLASS=Body3>00028000h = Virtual Device Driver module.
<DT CLASS=Body3><DD CLASS=Body3>00030000h = DLD module.
<DT CLASS=Body3><DD CLASS=Body3>00038000h = Reserved for system use.
<DT CLASS=Body3><DD CLASS=Body3>00080000h = MP-unsafe.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>The program module is multiple-processor unsafe. It does not provide the necessary serialization to run on more than one CPU at a time.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>40000000h = Per-process Library Termination.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>The setting of this bit requires the EIP Object # and EIP fields to have valid values. If the EIP Object # and EIP fields are valid and this bit is NOT set, then Global Library Termination is assumed. Setting this bit for an EXE file is invalid.
</DL>
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MODULE # PAGES = DD Physical number of pages in module.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the number of pages physically contained in this module. In other words, pages containing either enumerated or iterated data, not invalid or zero-fill pages. These pages are contained in the 'preload pages', 'demand load pages' and 'iterated data pages' sections of the linear EXE module. This is used to determine the size of the other physical page based tables in the linear EXE module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>EIP OBJECT # = DD The Object number to which the Entry Address is relative.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This specifies the object to which the Entry Address is relative. This must be a nonzero value for a program module to be correctly loaded. A zero value for a library module indicates that no library entry routine exists. If this value is zero, then both the Per-process Library Initialization bit and the Per-process Library Termination bit must be clear in the module flags, or else the loader will fail to load the module. Further, if the Per-process Library Termination bit is set, then the object to which this field refers must be a 32-bit object (i.e., the Big/Default bit must be set in the object flags; see below).
</DL>
<DT CLASS=Body1><DD CLASS=Body1>EIP = DD Entry Address of module.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The Entry Address is the starting address for program modules and the library initialization and Library termination address for library modules.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ESP OBJECT # = DD The Object number to which the ESP is relative.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This specifies the object to which the starting ESP is relative. This must be a nonzero value for a program module to be correctly loaded. This field is ignored for a library module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ESP = DD Starting stack address of module.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The ESP defines the starting stack pointer address for program modules. A zero value in this field indicates that the stack pointer is to be initialized to the highest address/offset in the object. This field is ignored for a library module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>PAGE SIZE = DD The size of one page for this system.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the page size used by the linear EXE format and the system. For the initial version of this linear EXE format the page size is 4Kbytes. (The 4K page size is specified by a value of 4096 in this field.)
</DL>
<DT CLASS=Body1><DD CLASS=Body1>PAGE OFFSET SHIFT = DD The shift left bits for page offsets.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field gives the number of bit positions to shift left when interpreting the Object Page Table entries' page offset field. This determines the alignment of the page information in the file. For example, a value of 4 in this field would align all pages in the Data Pages and Iterated Pages sections on 16 byte (paragraph) boundaries. A Page Offset Shift of 9 would align all pages on a 512 byte (disk sector) basis. All other offsets are byte aligned.
<DT CLASS=Body2><DD CLASS=Body2>A page might not start at the next available alignment boundary. Extra padding is acceptable between pages as long as each page starts on an alignment boundary. For example, several alignment boundaries may be skipped in order to start a frequently accessed page on a sector boundary.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FIXUP SECTION SIZE = DD Total size of the fixup information in bytes.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This includes the following 4 tables:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>Fixup Page Table
<DT CLASS=Body3><DD CLASS=Body3>Fixup Record Table
<DT CLASS=Body3><DD CLASS=Body3>Import Module name Table
<DT CLASS=Body3><DD CLASS=Body3>Import Procedure Name Table
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FIXUP SECTION CHECKSUM = DD Checksum for fixup information.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is a cryptographic checksum covering all of the fixup information. The checksum for the fixup information is kept separate because the fixup data is not always loaded into main memory with the 'loader section'. If the checksum feature is not implemented, then the linker will set these fields to zero.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>LOADER SECTION SIZE = DD Size of memory resident tables.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the total size in bytes of the tables required to be memory resident for the module, while the module is in use. This total size includes all tables from the Object Table down to and including the Per-Page Checksum Table.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>LOADER SECTION CHECKSUM = DD Checksum for loader section.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is a cryptographic checksum covering all of the loader section information. If the checksum feature is not implemented, then the linker will set these fields to zero.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT TABLE OFF = DD Object Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header. This offset also points to the start of the Loader Section.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># OBJECTS IN MODULE = DD Object Table Count.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This defines the number of entries in Object Table.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT PAGE TABLE OFFSET = DD Object Page Table offset
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT ITER PAGES OFF = DD Object Iterated Pages offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the EXE file.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>RESOURCE TABLE OFF = DD Resource Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># RESOURCE TABLE ENTRIES = DD Number of entries in Resource Table.
<DT CLASS=Body1><DD CLASS=Body1>RESIDENT NAME TBL OFF = DD Resident Name Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ENTRY TBL OFF = DD Entry Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MODULE DIRECTIVES OFF = DD Module Format Directives Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># MODULE DIRECTIVES = DD Number of Module Format Directives in the Table.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the number of entries in the Module Format Directives Table.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FIXUP PAGE TABLE OFF = DD Fixup Page Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header. This offset also points to the start of the Fixup Section.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FIXUP RECORD TABLE OFF = DD Fixup Record Table Offset
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>IMPORT MODULE TBL OFF = DD Import Module Name Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># IMPORT MOD ENTRIES = DD The number of entries in the Import Module Name Table.
<DT CLASS=Body1><DD CLASS=Body1>IMPORT PROC TBL OFF = DD Import Procedure Name Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>PER-PAGE CHECKSUM OFF = DD Per-Page Checksum Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the linear EXE header.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DATA PAGES OFFSET = DD Data Pages Offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the EXE file. This offset also points to the start of the Data Section.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># PRELOAD PAGES = DD Number of Preload pages for this module.
</DL>
<P CLASS=Note2>Note:  OS/2 2.0 does not respect the preload of pages as specified in the executable file for performance reasons.</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>NON-RES NAME TBL OFF = DD Non-Resident Name Table offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This offset is relative to the beginning of the EXE file.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>NON-RES NAME TBL LEN = DD Number of bytes in the Non-resident name table.
<DT CLASS=Body1><DD CLASS=Body1>NON-RES NAME TBL CKSM = DD Non-Resident Name Table Checksum.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is a cryptographic checksum of the Non-Resident Name Table.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>AUTO DS OBJECT # = DD The Auto Data Segment Object number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the object number for the Auto Data Segment used by 16-bit modules. This field is supported for 16-bit compatibility only and is not used by 32-bit modules.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DEBUG INFO OFF = DD Debug Information offset.
<DL CLASS=Body2>
<DT CLASS=Body1><DD CLASS=Body1>This offset is relative to the beginning of the file. This offset also points to the start of the Debug Section.
</DL>
<P CLASS=Note2>Note:  Earlier versions of this document stated that this offset was from the linear EXE header - this is incorrect.</P>
<DT CLASS=Body1><DD CLASS=Body1>DEBUG INFO LEN = DD Debug Information length.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The length of the debug information in bytes.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># INSTANCE PRELOAD = DD Instance pages in preload section.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The number of instance data pages found in the preload section.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># INSTANCE DEMAND = DD Instance pages in demand section.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The number of instance data pages found in the demand section.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>HEAPSIZE = DD Heap size added to the Auto DS Object.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The heap size is the number of bytes added to the Auto Data Segment by the loader. This field is supported for 16-bit compatibility only and is not used by 32-bit modules.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>STACKSIZE = DD Stack size.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The stack size is the number of bytes specified by:
<DL CLASS=OList3Begin>
<DT CLASS=OList3Begin><DD CLASS=OList3Begin>1.  size of a segment with combine type stack
<DT CLASS=OList3><DD CLASS=OList3>2.  STACKSIZE in the .DEF file
<DT CLASS=OList3><DD CLASS=OList3>3.  /STACK link option
<DT CLASS=Body3><DD CLASS=Body3>The stacksize may be zero.
</DL>
</DL>
</DL>
<P CLASS=Note2>Note:  Stack sizes with byte 2 equal to 02 or 04 (e.g. 00020000h, 11041111h, 0f02ffffh) should be avoided for programs that will run on OS/2 2.0.</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-3></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-3">2.3   Program (EXE) startup registers and Library entry registers</A></H1>

<P CLASS=Body> Program startup registers are defined as follows.</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>EIP = Starting program entry address.
<DT CLASS=Body1><DD CLASS=Body1>ESP = Top of stack address.
<DT CLASS=Body1><DD CLASS=Body1>CS = Code selector for base of linear address space.
<DT CLASS=Body1><DD CLASS=Body1>DS = ES = SS = Data selector for base of linear address space.
<DT CLASS=Body1><DD CLASS=Body1>FS = Data selector of base of Thread Information Block (TIB).
<DT CLASS=Body1><DD CLASS=Body1>GS = 0.
<DT CLASS=Body1><DD CLASS=Body1>EAX = EBX = 0.
<DT CLASS=Body1><DD CLASS=Body1>ECX = EDX = 0.
<DT CLASS=Body1><DD CLASS=Body1>ESI = EDI = 0.
<DT CLASS=Body1><DD CLASS=Body1>EBP = 0.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+0] = Return address to routine which calls DosExit(1,EAX).
<DT CLASS=Body1><DD CLASS=Body1>[ESP+4] = Module handle for program module.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+8] = Reserved.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+12] = Environment data object address.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+16] = Command line linear address in environment data object.
</DL>
<P CLASS=Body> Library initialization registers are defined as follows.</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>EIP = Library entry address.
<DT CLASS=Body1><DD CLASS=Body1>ESP = User program stack.
<DT CLASS=Body1><DD CLASS=Body1>CS = Code selector for base of linear address space.
<DT CLASS=Body1><DD CLASS=Body1>DS = ES = SS = Data selector for base of linear address space.
<DT CLASS=Body1><DD CLASS=Body1>FS = Data selector of base of Thread Information Block (TIB).
<DT CLASS=Body1><DD CLASS=Body1>GS = 0.
<DT CLASS=Body1><DD CLASS=Body1>EAX = EBX = 0.
<DT CLASS=Body1><DD CLASS=Body1>ECX = EDX = 0.
<DT CLASS=Body1><DD CLASS=Body1>ESI = EDI = 0.
<DT CLASS=Body1><DD CLASS=Body1>EBP = 0.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+0] = Return address to system, (EAX) = return code.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+4] = Module handle for library module.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+8] = 0 (Initialization)
</DL>
<P CLASS=Note>Note:  A 32-bit library may specify that its entry address is in a 16-bit code object. In this case, the entry registers are the same as for entry to a library using the Segmented EXE format. These are documented elsewhere. This means that a 16-bit library may be relinked to take advantage of the benefits of the Linear EXE format (notably, efficient paging).</P>
<P CLASS=Body> Library termination registers are defined as follows.</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>EIP = Library entry address.
<DT CLASS=Body1><DD CLASS=Body1>ESP = User program stack.
<DT CLASS=Body1><DD CLASS=Body1>CS = Code selector for base of linear address space.
<DT CLASS=Body1><DD CLASS=Body1>DS = ES = SS = Data selector for base of linear address space.
<DT CLASS=Body1><DD CLASS=Body1>FS = Data selector of base of Thread Information Block (TIB).
<DT CLASS=Body1><DD CLASS=Body1>GS = 0.
<DT CLASS=Body1><DD CLASS=Body1>EAX = EBX = 0.
<DT CLASS=Body1><DD CLASS=Body1>ECX = EDX = 0.
<DT CLASS=Body1><DD CLASS=Body1>ESI = EDI = 0.
<DT CLASS=Body1><DD CLASS=Body1>EBP = 0.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+0] = Return address to system.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+4] = Module handle for library module.
<DT CLASS=Body1><DD CLASS=Body1>[ESP+8] = 1 (Termination)
</DL>
<P CLASS=Note>Note:  Library termination is not allowed for libraries with 16-bit entries.</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-4></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-4">2.4   Object Table</A></H1>

<P CLASS=Body> The number of entries in the Object Table is given by the # Objects in Module field in the linear EXE header. Entries in the Object Table are numbered starting from one.</P>
<P CLASS=Body> Each Object Table entry has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-8:  Object Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> VIRTUAL SIZE</P>
</TD><TD><P CLASS=FigureBody> RELOC BASE ADDR</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 08h</P>
</TD><TD><P CLASS=FigureBody> OBJECT FLAGS</P>
</TD><TD><P CLASS=FigureBody> PAGE TABLE INDEX</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 10h</P>
</TD><TD><P CLASS=FigureBody> # PAGE TABLE ENTRIES</P>
</TD><TD><P CLASS=FigureBody> RESERVED </P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>VIRTUAL SIZE = DD Virtual memory size.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the size of the object that will be allocated when the object is loaded. The object data length must be less than or equal to the total size of the pages in the EXE file for the object. This memory size must also be large enough to contain all of the iterated data and uninitialized data in the EXE file.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>RELOC BASE ADDR = DD Relocation Base Address.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The relocation base address the object is currently relocated to. If the internal relocation fixups for the module have been removed, this is the address the object will be allocated at by the loader.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT FLAGS = DW Flag bits for the object.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The object flag bits have the following definitions.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>0001h = Readable Object.
<DT CLASS=Body3><DD CLASS=Body3>0002h = Writable Object.
<DT CLASS=Body3><DD CLASS=Body3>0004h = Executable Object.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>The readable, writable and executable flags provide support for all possible protections. In systems where all of these protections are not supported, the loader will be responsible for making the appropriate protection match for the system.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>0008h = Resource Object.
<DT CLASS=Body3><DD CLASS=Body3>0010h = Discardable Object.
<DT CLASS=Body3><DD CLASS=Body3>0020h = Object is Shared.
<DT CLASS=Body3><DD CLASS=Body3>0040h = Object has Preload Pages.
<DT CLASS=Body3><DD CLASS=Body3>0080h = Object has Invalid Pages.
<DT CLASS=Body3><DD CLASS=Body3>0100h = Object is Resident (valid for VDDs, PDDs only).
<DT CLASS=Body3><DD CLASS=Body3>0200h = Reserved.
<DT CLASS=Body3><DD CLASS=Body3>0300h = Object is Resident &amp; Contiguous (VDDs, PDDs only).
<DT CLASS=Body3><DD CLASS=Body3>0400h = Object is Resident &amp; 'long-lockable' (VDDs, PDDs only).
<DT CLASS=Body3><DD CLASS=Body3>0800h = Object is marked as an IBM Microkernel extension.
<DT CLASS=Body3><DD CLASS=Body3>1000h = 16:16 Alias Required (80x86 Specific).
<DT CLASS=Body3><DD CLASS=Body3>2000h = Big/Default Bit Setting (80x86 Specific).
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>The 'big/default' bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction stream.)
</DL>
<DT CLASS=Body3><DD CLASS=Body3>4000h = Object is conforming for code (80x86 Specific).
<DT CLASS=Body3><DD CLASS=Body3>8000h = Object I/O privilege level (80x86 Specific).
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>Only used for 16:16 Alias Objects.
</DL>
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>PAGE TABLE INDEX = DD Object Page Table Index.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This specifies the number of the first object page table entry for this object. The object page table specifies where in the EXE file a page can be found for a given object and specifies per-page attributes.
<DT CLASS=Body2><DD CLASS=Body2>The object table entries are ordered by logical page in the object table. In other words the object table entries are sorted based on the object page table index value.
</DL>
<DT CLASS=Body1><DD CLASS=Body1># PAGE TABLE ENTRIES = DD # of object page table entries for this object.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>Any logical pages at the end of an object that do not have an entry in the object page table associated with them are handled as zero filled or invalid pages by the loader.
<DT CLASS=Body2><DD CLASS=Body2>When the last logical pages of an object are not specified with an object page table entry, they are treated as either zero filled pages or invalid pages based on the last entry in the object page table for that object. If the last entry was neither a zero filled or invalid page, then the additional pages are treated as zero filled pages.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>RESERVED = DD Reserved for future use. Must be set to zero.
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-5></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-5">2.5   Object Page Table</A></H1>

<P CLASS=Body> The Object page table provides information about a logical page in an object. A logical page may be an enumerated page, a pseudo page or an iterated page. The structure of the object page table in conjunction with the structure of the object table allows for efficient access of a page when a page fault occurs, while still allowing the physical page data to be located in the preload page, demand load page or iterated data page sections in the linear EXE module. The logical page entries in the Object Page Table are numbered starting from one. The Object Page Table is parallel to the Fixup Page Table as they are both indexed by the logical page number.</P>
<P CLASS=Body> Each Object Page Table entry has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-9:  Object Page Table Entry</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD><P CLASS=FigureBody> 63 32</P>
</TD><TD><P CLASS=FigureBody> 31  16</P>
</TD><TD><P CLASS=FigureBody> 15  0</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> PAGE DATA OFFSET</P>
</TD><TD><P CLASS=FigureBody> DATA SIZE</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>PAGE DATA OFFSET = DD Offset to the page data in the EXE file.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field, when bit shifted left by the PAGE OFFSET SHIFT from the module header, specifies the offset from the beginning of the Preload Page section of the physical page data in the EXE file that corresponds to this logical page entry. The page data may reside in the Preload Pages, Demand Load Pages or the Iterated Data Pages sections.
<DT CLASS=Body2><DD CLASS=Body2> A page might not start at the next available alignment boundary. Extra padding is acceptable between pages as long as each page starts on an alignment boundary. For example, several alignment boundaries may be skipped in order to start a frequently accessed page on a sector boundary.
<DT CLASS=Body2><DD CLASS=Body2>If the FLAGS field specifies that this is a Zero-Filled page then the PAGE DATA OFFSET field will contain a 0.
<DT CLASS=Body2><DD CLASS=Body2>If the logical page is specified as an iterated data page, as indicated by the FLAGS field, then this field specifies the offset into the Iterated Data Pages section.
<DT CLASS=Body2><DD CLASS=Body2>The logical page number (Object Page Table index), is used to index the Fixup Page Table to find any fixups associated with the logical page.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DATA SIZE = DW Number of bytes of data for this page.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the actual number of bytes that represent the page in the file. If the PAGE SIZE field from the module header is greater than the value of this field and the FLAGS field indicates a Legal Physical Page, the remaining bytes are to be filled with zeros. If the FLAGS field indicates an Iterated Data Page, the iterated data records will completely fill out the remainder.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FLAGS = DW Attributes specifying characteristics of this logical page.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The bit definitions for this word field follow,
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00h = Legal Physical Page in the module (Offset from Preload Page Section).
<DT CLASS=Body3><DD CLASS=Body3>01h = Iterated Data Page (Offset from Iterated Data Pages Section).
<DT CLASS=Body3><DD CLASS=Body3>02h = Invalid Page (zero).
<DT CLASS=Body3><DD CLASS=Body3>03h = Zero Filled Page (zero).
<DT CLASS=Body3><DD CLASS=Body3>04h = Unused.
<DT CLASS=Body3><DD CLASS=Body3>05h = Compressed Page (Offset from Preload Pages Section).
</DL>
</DL>
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-6></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-6">2.6   Resource Table</A></H1>

<P CLASS=BodyFirst> The resource table is an array of resource table entries. Each resource table entry contains a type ID and name ID. These entries are used to locate resource objects contained in the Object table. The number of entries in the resource table is defined by the Resource Table Count located in the linear EXE header. More than one resource may be contained within a single object. Resource table entries are in a sorted order, (ascending, by Resource Name ID within the Resource Type ID). This allows the DosGetResource API function to use a binary search when looking up a resource in a 32-bit module instead of the linear search being used in the current 16-bit module.</P>
<P CLASS=Body> Each resource entry has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-10:  Resource Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> TYPE ID</P>
</TD><TD><P CLASS=FigureBody> NAME ID</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 04h</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> RESOURCE SIZE</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 08h</P>
</TD><TD><P CLASS=FigureBody> OBJECT</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OFFSET</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>TYPE ID = DW Resource type ID.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The type of resources are:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>01h = RT_POINTER = mouse pointer shape
<DT CLASS=Body3><DD CLASS=Body3>02h = RT_BITMAP = bitmap
<DT CLASS=Body3><DD CLASS=Body3>03h = RT_MENU = menu template
<DT CLASS=Body3><DD CLASS=Body3>04h = RT_DIALOG = dialog template
<DT CLASS=Body3><DD CLASS=Body3>05h = RT_STRING = string tables
<DT CLASS=Body3><DD CLASS=Body3>06h = RT_FONTDIR = font directory
<DT CLASS=Body3><DD CLASS=Body3>07h = RT_FONT = font
<DT CLASS=Body3><DD CLASS=Body3>08h = RT_ACCELTABLE = accelerator tables
<DT CLASS=Body3><DD CLASS=Body3>09h = RT_RCDATA = binary data
<DT CLASS=Body3><DD CLASS=Body3>0Ah = RT_MESSAGE = error msg tables
<DT CLASS=Body3><DD CLASS=Body3>0Bh = RT_DLGINCLUDE = dialog include file name
<DT CLASS=Body3><DD CLASS=Body3>0Ch = RT_VKEYTBL = key to vkey tables
<DT CLASS=Body3><DD CLASS=Body3>0Dh = RT_KEYTBL = key to UGL tables
<DT CLASS=Body3><DD CLASS=Body3>0Eh = RT_CHARTBL = glyph to character tables
<DT CLASS=Body3><DD CLASS=Body3>0Fh = RT_DISPLAYINFO = screen display information
<DT CLASS=Body3><DD CLASS=Body3>10h = RT_FKASHORT = function key area short form
<DT CLASS=Body3><DD CLASS=Body3>11h = RT_FKALONG = function key area long form
<DT CLASS=Body3><DD CLASS=Body3>12h = RT_HELPTABLE = Help table for Cary Help manager
<DT CLASS=Body3><DD CLASS=Body3>13h = RT_HELPSUBTABLE = Help subtable for Cary Help manager
<DT CLASS=Body3><DD CLASS=Body3>14h = RT_FDDIR = DBCS uniq/font driver directory
<DT CLASS=Body3><DD CLASS=Body3>15h = RT_FD = DBCS uniq/font driver
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>NAME ID = DW An ID used as a name for the resource when referred to.
<DT CLASS=Body1><DD CLASS=Body1>RESOURCE SIZE = DD The number of bytes the resource consists of.
<DT CLASS=Body1><DD CLASS=Body1>OBJECT = DW The number of the object which contains the resource.
<DT CLASS=Body1><DD CLASS=Body1>OFFSET = DD The offset within the specified object where the resource begins.
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-7></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-7">2.7   Resident or Non-resident Name Table Entry</A></H1>

<P CLASS=Body>
The resident and non-resident name tables define the ASCII names and ordinal
numbers for exported entries in the module. In addition the first entry in
the resident name table contains the module name. These tables are used to
translate a procedure name string into an ordinal number by searching for a
matching name string. The ordinal number is used to locate the entry point
information in the entry table.
</P>
<P CLASS=Body>
The resident name table is kept resident in system memory while the module
is loaded. It is intended to contain the exported entry point names that are
frequently dynamically linked to by name. Non-resident names are not kept in
memory and are read from the EXE file when a dynamic link reference is made.
Exported entry point names that are infrequently dynamically linked to by
name or are commonly referenced by ordinal number should be placed in the
non-resident name table. The trade off made for references by name is
performance vs. memory usage.
</P>
<P CLASS=Body>
Import references by name require these tables to be searched to obtain the
entry point ordinal number. Import references by ordinal number provide the
fastest lookup since the search of these tables is not required.
</P>
<P CLASS=Body>
Installable File Systems, Physical Device Drivers, and Virtual Device Drivers
are closed after the file is loaded. Any reference to the non-resident name
table after this time will fail.
</P>
<P CLASS=Body>
The strings are CASE SENSITIVE and are NOT NULL TERMINATED.
</P>
<P CLASS=Body>
Each name table entry has the following format:
</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-11:  Resident or Non-resident Name Table Entry</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> LEN</P>
</TD><TD><P CLASS=FigureBody> ASCII STRING . . . </P>
</TD><TD><P CLASS=FigureBody> ORDINAL</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>LEN = DB String Length.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This defines the length of the string in bytes. A zero length indicates there are no more entries in table. The length of each ascii name string is limited to 255 characters.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ASCII STRING = DB ASCII String.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is a variable length string with it's length defined in bytes by the LEN field. The string is case sensitive and is not null terminated.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ORDINAL # = DW Ordinal number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The ordinal number in an ordered index into the entry table for this entry point.
</DL>
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-8></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-8">2.8   Entry Table</A></H1>

<P CLASS=Body> The entry table contains object and offset information that is used to resolve fixup references to the entry points within this module. Not all entry points in the entry table will be exported, some entry points will only be used within the module. An ordinal number is used to index into the entry table. The entry table entries are numbered starting from one.</P>
<P CLASS=Body> The list of entries are compressed into 'bundles', where possible. The entries within each bundle are all the same size. A bundle starts with a count field which indicates the number of entries in the bundle. The count is followed by a type field which identifies the bundle format. This provides both a means for saving space as well as a mechanism for extending the bundle types.</P>
<P CLASS=Body> The type field allows the definition of 256 bundle types. The following bundle types will initially be defined:</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>Unused Entry.
<DT CLASS=Body1><DD CLASS=Body1>16-bit Entry.
<DT CLASS=Body1><DD CLASS=Body1>286 Call Gate Entry.
<DT CLASS=Body1><DD CLASS=Body1>32-bit Entry.
<DT CLASS=Body1><DD CLASS=Body1>Forwarder Entry.
</DL>
<P CLASS=Body> The bundled entry table has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-12:  Entry Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> CNT</P>
</TD><TD><P CLASS=FigureBody> TYPE</P>
</TD><TD><P CLASS=FigureBody> BUNDLE INFO . . .</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CNT = DB Number of entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the number of entries in this bundle.
<DT CLASS=Body2><DD CLASS=Body2>A zero value for the number of entries identifies the end of the entry table. There is no further bundle information when the number of entries is zero. In other words the entry table is terminated by a single zero byte.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB Bundle type.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This defines the bundle type which determines the contents of the BUNDLE INFO.
<DT CLASS=Body2><DD CLASS=Body2>The follow types are defined:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00h = Unused Entry.
<DT CLASS=Body3><DD CLASS=Body3>01h = 16-bit Entry.
<DT CLASS=Body3><DD CLASS=Body3>02h = 286 Call Gate Entry.
<DT CLASS=Body3><DD CLASS=Body3>03h = 32-bit Entry.
<DT CLASS=Body3><DD CLASS=Body3>04h = Forwarder Entry.
<DT CLASS=Body3><DD CLASS=Body3>80h = Parameter Typing Information Present.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>This bit signifies that additional information is contained in the linear EXE module and will be used in the future for parameter type checking.
</DL>
</DL>
</DL>
</DL>
<P CLASS=Body> The following is the format for each bundle type:</P>

<A NAME=HEADING-2-8-1></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-8-1">2.8.1   Unused Entry</A></H1>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> CNT</P>
</TD><TD><P CLASS=FigureBody> TYPE</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CNT = DB Number of entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the number of unused entries to skip.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB 0 (Unused Entry)
</DL>
<A NAME=HEADING-2-8-2></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-8-2">2.8.2   16-bit Entry</A></H1>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> CNT</P>
</TD><TD><P CLASS=FigureBody> TYPE</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OBJECT</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 04h</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OFFSET</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 07h</P>
</TD><TD><P CLASS=FigureBody> ...</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ...</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CNT = DB Number of entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the number of 16-bit entries in this bundle. The flags and offset value are repeated this number of times.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB 1 (16-bit Entry)
<DT CLASS=Body1><DD CLASS=Body1>OBJECT = DW Object number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the object number for the entries in this bundle. If the object number is zero, then the entries in this bundle are absolute values.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FLAGS = DB Entry flags.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>These are the flags for this entry point. They have the following definition.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>01h = Exported entry flag.
<DT CLASS=Body3><DD CLASS=Body3>F8h = Parameter word count mask.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OFFSET = DW Offset in object.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the offset in the object for the entry point defined at this ordinal number.
</DL>
</DL>
<A NAME=HEADING-2-8-3></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-8-3">2.8.3   286 Call Gate Entry</A></H1>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> CNT</P>
</TD><TD><P CLASS=FigureBody> TYPE</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OBJECT</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 04h</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OFFSET</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> CALLGATE</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 09h</P>
</TD><TD><P CLASS=FigureBody> ...</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ...</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ...</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CNT = DB Number of entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the number of 286 call gate entries in this bundle. The flags, callgate, and offset value are repeated this number of times.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB 2 (286 Call Gate Entry)
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The 286 Call Gate Entry Point type is needed by the loader only if ring 2 segments are to be supported. 286 Call Gate entries contain 2 extra bytes which are used by the loader to store an LDT callgate selector value.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT = DW Object number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the object number for the entries in this bundle.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FLAGS = DB Entry flags.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>These are the flags for this entry point. They have the following definition.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>01h = Exported entry flag.
<DT CLASS=Body3><DD CLASS=Body3>F8h = Parameter word count mask.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OFFSET = DW Offset in object.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the offset in the object for the entry point defined at this ordinal number.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>CALLGATE = DW Callgate selector.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The callgate selector is a reserved field used by the loader to store a call gate selector value for references to ring 2 entry points. When a ring 3 reference to a ring 2 entry point is made, the callgate selector with a zero offset is place in the relocation fixup address. The segment number and offset in segment is placed in the LDT callgate.
</DL>
</DL>
<A NAME=HEADING-2-8-4></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-8-4">2.8.4   32-bit Entry</A></H1>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> CNT</P>
</TD><TD><P CLASS=FigureBody> TYPE</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OBJECT</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 04h</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD COLSPAN=4><P CLASS=FigureBody> OFFSET</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 09h</P>
</TD><TD><P CLASS=FigureBody> ...</P>
</TD><TD COLSPAN=4><P CLASS=FigureBody> ...</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CNT = DB Number of entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the number of 32-bit entries in this bundle. The flags and offset value are repeated this number of times.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB 3 (32-bit Entry)
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The 32-bit Entry type will only be defined by the linker when the offset in the object can not be specified by a 16-bit offset.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT = DW Object number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the object number for the entries in this bundle. If the object number is zero, then the entries in this bundle are absolute values.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FLAGS = DB Entry flags.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>These are the flags for this entry point. They have the following definition.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>01h = Exported entry flag.
<DT CLASS=Body3><DD CLASS=Body3>F8h = Parameter dword count mask.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OFFSET = DD Offset in object.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the offset in the object for the entry point defined at this ordinal number.
</DL>
</DL>
<A NAME=HEADING-2-8-5></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-8-5">2.8.5   Forwarder Entry</A></H1>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> CNT</P>
</TD><TD><P CLASS=FigureBody> TYPE</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> RESERVED</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 04h</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> MOD ORD#</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OFFSET / ORDNUM</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 09h</P>
</TD><TD><P CLASS=FigureBody> ...</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ...</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ...</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CNT = DB Number of entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the number of forwarder entries in this bundle. The FLAGS, MOD ORD#, and OFFSET/ORDNUM values are repeated this number of times.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB 4 (Forwarder Entry)
<DT CLASS=Body1><DD CLASS=Body1>RESERVED = DW 0
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field is reserved for future use.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FLAGS = DB Forwarder flags.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>These are the flags for this entry point. They have the following definition.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>01h = Import by ordinal.
<DT CLASS=Body3><DD CLASS=Body3>F7h = Reserved for future use; should be zero.
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MOD ORD# = DW Module Ordinal Number
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the index into the Import Module Name Table for this forwarder.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OFFSET / ORDNUM = DD Procedure Name Offset or Import Ordinal Number
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>If the FLAGS field indicates import by ordinal, then this field is the ordinal number into the Entry Table of the target module, otherwise this field is the offset into the Procedure Names Table of the target module.
</DL>
</DL>
<P>
A Forwarder entry (type = 4) is an entry point whose value is an imported
reference. When a load time fixup occurs whose target is a forwarder, the
loader obtains the address imported by the forwarder and uses that imported
address to resolve the fixup.
<P>
A forwarder may refer to an entry point in another module which is itself
a forwarder, so there can be a chain of forwarders. The loader will traverse
the chain until it finds a non-forwarded entry point which terminates the
chain, and use this to resolve the original fixup. Circular chains are
detected by the loader and result in a load time error. A maximum of 1024
forwarders is allowed in a chain; more than this results in a load time error.
<P>
Forwarders are useful for merging and recombining API calls into different
sets of libraries, while maintaining compatibility with applications.  For
example, if one wanted to combine MONCALLS, MOUCALLS, and VIOCALLS into a
single libraries, one could provide entry points for the three libraries
that are forwarders pointing to the common implementation.

<HR CLASS=Heading2>
<A NAME=HEADING-2-9></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-9">2.9   Module Format Directives Table</A></H1>

<P CLASS=Body> The Module Format Directives Table is an optional table that allows additional options to be specified. It also allows for the extension of the linear EXE format by allowing additional tables of information to be added to the linear EXE module without affecting the format of the linear EXE header. Likewise, module format directives provide a place in the linear EXE module for 'temporary tables' of information, such as incremental linking information and statistic information gathered on the module. When there are no module format directives for a linear EXE module, the fields in the linear EXE header referencing the module format directives table are zero.</P>
<P CLASS=Body> Each Module Format Directive Table entry has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-13:  Module Format Directive Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> DIRECT #</P>
</TD><TD><P CLASS=FigureBody> DATA LEN</P>
</TD><TD><P CLASS=FigureBody> DATA OFFSET</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>DIRECT # = DW Directive number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The directive number specifies the type of directive defined. This can be used to determine the format of the information in the directive data. The following directive numbers have been defined:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>8001h = Verify Record Directive. (Verify record is a resident table.)
<DT CLASS=Body3><DD CLASS=Body3>0002h = Language Information Directive. (This is a non-resident table.)
<DT CLASS=Body3><DD CLASS=Body3>0003h = Co-Processor Required Support Table.
<DT CLASS=Body3><DD CLASS=Body3>0004h = Thread State Initialization Directive.
<DT CLASS=Body3><DD CLASS=Body3>0005h = C Set ++ Browse Information. Additional directives can be added as needed in the future, as long as they do not overlap previously defined directive numbers.
</DL>
<DT CLASS=Body2><DD CLASS=Body2>8000h = Resident Flag Mask.
<DT CLASS=Body2><DD CLASS=Body2>Directive numbers with this bit set indicate that the directive data is in the resident area and will be kept resident in memory when the module is loaded.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DATA LEN = DW Directive data length.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This specifies the length in bytes of the directive data for this directive number.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DIRECTIVE OFFSET = DD Directive data offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the offset to the directive data for this directive number. It is relative to beginning of linear EXE header for a resident table, and relative to the beginning of the EXE file for non-resident tables.
</DL>
</DL>
<A NAME=HEADING-2-9-1></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-9-1">2.9.1   Verify Record Directive Table</A></H1>
<P CLASS=Body> The Verify Record Directive Table is an optional table. It maintains a record of the pages in the EXE file that have been fixed up and written back to the original linear EXE module, along with the module dependencies used to perform these fixups. This table provides an efficient means for verifying the virtual addresses required for the fixed up pages when the module is loaded.</P>
<P CLASS=Body> Each Verify Record entry has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-14:  Verify Record Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> # OF ENTRY</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 02h</P>
</TD><TD><P CLASS=FigureBody> MOD ORD #</P>
</TD><TD><P CLASS=FigureBody> VERSION</P>
</TD><TD><P CLASS=FigureBody> MOD # OBJ</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 08h</P>
</TD><TD><P CLASS=FigureBody> OBJECT #</P>
</TD><TD><P CLASS=FigureBody> BASE ADDR</P>
</TD><TD><P CLASS=FigureBody> VIRTUAL</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 0Eh</P>
</TD><TD><P CLASS=FigureBody> . . . </P>
</TD><TD><P CLASS=FigureBody> . . . </P>
</TD><TD><P CLASS=FigureBody> . . . </P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1># OF ENTRY = DW Number of module dependencies.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies how many entries there are in the verify record directive table. This is equal to the number of modules referenced by this module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MOD ORD # = DW Ordinal index into the Import Module Name Table.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This value is an ordered index in to the Import Module Name Table for the referenced module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>VERSION = DW Module Version.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the version of the referenced module that the fixups were originally performed. This is used to insure the same version of the referenced module is loaded that was fixed up in this module and therefore the fixups are still correct. This requires the version number in a module to be incremented anytime the entry point offsets change.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>MOD # OBJ = DW Module # of Object Entries.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field is used to identify the number of object verify entries that follow for the referenced module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT # = DW Object # in Module.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the object number in the referenced module that is being verified.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>BASE ADDR = DW Object load base address.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the address that the object was loaded at when the fixups were performed.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>VIRTUAL = DW Object virtual address size.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the total amount of virtual memory required for this object.
</DL>
</DL>


<HR CLASS=Heading2>
<A NAME=HEADING-2-10></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-10">2.10   Per-Page Checksum</A></H1>

<P CLASS=Body> The Per-Page Checksum table provides space for a cryptographic checksum for each physical page in the EXE file.</P>
<P CLASS=Body> The checksum table is arranged such that the first entry in the table corresponds to the first logical page of code/data in the EXE file (usually a preload page) and the last entry corresponds to the last logical page in the EXE file (usually a iterated data page).</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-15:  Per-Page Checksum</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody> Logical Page #1</P>
</TD><TD><P CLASS=FigureBody> CHECKSUM</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Logical Page #2</P>
</TD><TD><P CLASS=FigureBody> CHECKSUM</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> </P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Logical Page #n</P>
</TD><TD><P CLASS=FigureBody> CHECKSUM</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>CHECKSUM = DD Cryptographic checksum.
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-11></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-11">2.11   Fixup Page Table</A></H1>

<P CLASS=Body> The Fixup Page Table provides a simple mapping of a logical page number to an offset into the Fixup Record Table for that page.</P>
<P CLASS=Body> This table is parallel to the Object Page Table, except that there is one additional entry in this table to indicate the end of the Fixup Record Table.</P>
<P CLASS=Body> The format of each entry is:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-16:  Fixup Page Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody> Logical Page #1</P>
</TD><TD><P CLASS=FigureBody> OFFSET FOR PAGE #1</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Logical Page #2</P>
</TD><TD><P CLASS=FigureBody> OFFSET FOR PAGE #2</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> </P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> Logical Page #n</P>
</TD><TD><P CLASS=FigureBody> OFFSET FOR PAGE #n</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> </P>
</TD><TD><P CLASS=FigureBody> OFF TO END OF FIXUP REC</P>
</TD><TD ROWSPAN=2><P CLASS=FigureBody> This is equal to: Offset for page #n + Size of fixups for page #n</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>OFFSET FOR PAGE # = DD Offset for fixup record for this page.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the offset, from the beginning of the fixup record table, to the first fixup record for this page.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>OFF TO END OF FIXUP REC = DD Offset to the end of the fixup records.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field specifies the offset following the last fixup record in the fixup record table. This is the last entry in the fixup page table.
<DT CLASS=Body2><DD CLASS=Body2>The fixup records are kept in order by logical page in the fixup record table. This allows the end of each page's fixup records is defined by the offset for the next logical page's fixup records. This last entry provides support of this mechanism for the last page in the fixup page table.
</DL>
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-12></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-12">2.12   Fixup Record Table</A></H1>

<P CLASS=Body> The Fixup Record Table contains entries for all fixups in the linear EXE module. The fixup records for a logical page are grouped together and kept in sorted order by logical page number. The fixups for each page are further sorted such that all external fixups and internal selector/pointer fixups come before internal non-selector/non-pointer fixups. This allows the loader to ignore internal fixups if the loader is able to load all objects at the addresses specified in the object table.</P>
<P CLASS=Body> Each relocation record has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-17:  Fixup Record Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> SRC</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD><P CLASS=FigureBody> SRCOFF/CNT1</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 03h/04h</P>
</TD><TD COLSPAN=4><P CLASS=FigureBody> TARGET DATA1</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> SRCOFF12</P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD><TD><P CLASS=FigureBody> SRCOFFn2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=4><P CLASS=CellBody> 1These fields are variable size.<BR>2These fields are optional.</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>SRC = DB Source type.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The source type specifies the size and type of the fixup to be performed on the fixup source. The source type is defined as follows:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>0Fh = Source mask.
<DT CLASS=Body3><DD CLASS=Body3>00h = Byte fixup (8-bits).
<DT CLASS=Body3><DD CLASS=Body3>01h = (undefined).
<DT CLASS=Body3><DD CLASS=Body3>02h = 16-bit Selector fixup (16-bits).
<DT CLASS=Body3><DD CLASS=Body3>03h = 16:16 Pointer fixup (32-bits).
<DT CLASS=Body3><DD CLASS=Body3>04h = (undefined).
<DT CLASS=Body3><DD CLASS=Body3>05h = 16-bit Offset fixup (16-bits).
<DT CLASS=Body3><DD CLASS=Body3>06h = 16:32 Pointer fixup (48-bits).
<DT CLASS=Body3><DD CLASS=Body3>07h = 32-bit Offset fixup (32-bits).
<DT CLASS=Body3><DD CLASS=Body3>08h = 32-bit Self-relative offset fixup (32-bits).
<DT CLASS=Body3><DD CLASS=Body3>10h = Fixup to Alias Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When the 'Fixup to Alias' Flag is set, the source fixup refers to the 16:16 alias for the object. This is only valid for source types of 2, 3, and 6. For fixups such as this, the linker and loader will be required to perform additional checks such as ensuring that the target offset for this fixup is less than 64K.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>20h = Source List Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When the 'Source List' Flag is set, the SRCOFF field is compressed to a byte and contains the number of source offsets, and a list of source offsets follows the end of fixup record (after the optional additive value).
</DL>
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>FLAGS = DB Target Flags.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The target flags specify how the target information is interpreted. The target flags are defined as follows:
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>03h = Fixup target type mask.
<DT CLASS=Body3><DD CLASS=Body3>00h = Internal reference.
<DT CLASS=Body3><DD CLASS=Body3>01h = Imported reference by ordinal.
<DT CLASS=Body3><DD CLASS=Body3>02h = Imported reference by name.
<DT CLASS=Body3><DD CLASS=Body3>03h = Internal reference via entry table.
<DT CLASS=Body3><DD CLASS=Body3>04h = Additive Fixup Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When set, an additive value trails the fixup record (before the optional source offset list).
</DL>
<DT CLASS=Body3><DD CLASS=Body3>08h = Internal Chaining Fixup Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>
When set, this bit indicates that this fixup
record is the beginning of a chain of fixups. The remaining fixups in the
chain are contained within the page rather than as additional entries in the
fixup record table. See <A HREF="#HEADING-2-12-5" CLASS=Body4>&sect;&nbsp;2.12.5,
"Internal Chaining Fixups"</A> for additional details on this fixup type.
<DT CLASS=Body4><DD CLASS=Body4>
Setting this bit is only valid for fixups of source type 07h (32-bit Offset)
and target types 00h and 03h (Internal references). This bit is only valid if
the Source List Flag is not set.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>10h = 32-bit Target Offset Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When set, the target offset is 32-bits, otherwise it is 16-bits.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>20h = 32-bit Additive Fixup Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When set, the additive value is 32-bits, otherwise it is 16-bits.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>40h = 16-bit Object Number/Module Ordinal Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When set, the object number or module ordinal number is 16-bits, otherwise it is 8-bits.
</DL>
<DT CLASS=Body3><DD CLASS=Body3>80h = 8-bit Ordinal Flag.
<DL CLASS=Body4>
<DT CLASS=Body4><DD CLASS=Body4>When set, the ordinal number is 8-bits, otherwise it is 16-bits.
</DL>
</DL>
</DL>
<DT CLASS=Body1><DD CLASS=Body1>SRCOFF = DW/CNT = DB Source offset or source offset list count.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field contains either an offset or a count depending on the Source List Flag. If the Source List Flag is set, a list of source offsets follows the additive field and this field contains the count of the entries in the source offset list. Otherwise, this is the single source offset for the fixup. Source offsets are relative to the beginning of the page where the fixup is to be made.
</DL>
</DL>
<P CLASS=Note2>Note:  For fixups that cross page boundaries, a separate fixup record is specified for each page. An offset is still used for the 2nd page but it now becomes a negative offset since the fixup originated on the preceding page. (For example, if only the last one byte of a 32-bit address is on the page to be fixed up, then the offset would have a value of -3.)</P>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>TARGET DATA = Target data for fixup.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The format of the TARGET DATA is dependent upon target flags.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>SRCOFF1 - SRCOFFn = DW[] Source offset list.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This list is present if the Source List Flag is set in the Target Flags field. The number of entries in the source offset list is defined in the SRCOFF/CNT field. The source offsets are relative to the beginning of the page where the fixups are to be made.
</DL>
</DL>

<A NAME=HEADING-2-12-1></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-12-1">2.12.1   Internal Fixup Record</A></H1>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-18:  Internal Fixup Record</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> SRC</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD><P CLASS=FigureBody> SRCOFF/CNT1</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 03h/04h</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> OBJECT1</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> TRGOFF1,2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> SRCOFF12</P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD><TD><P CLASS=FigureBody> SRCOFFn2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=4><P CLASS=CellBody> 1These fields are variable size.<BR>2These fields are optional.</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>OBJECT = D[B|W] Target object number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field is an index into the current module's Object Table to specify the target Object. It is a Byte value when the '16-bit Object Number/Module Ordinal Flag' bit in the target flags field is clear and a Word value when the bit is set.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TRGOFF = D[W|D] Target offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field is an offset into the specified target Object. It is not present when the Source Type specifies a 16-bit Selector fixup. It is a Word value when the '32-bit Target Offset Flag' bit in the target flags field is clear and a Dword value when the bit is set.
</DL>
</DL>
<A NAME=HEADING-2-12-2></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-12-2">2.12.2   Import by Ordinal Fixup Record</A></H1>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-19:  Import by Ordinal Fixup Record</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> SRC</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD><P CLASS=FigureBody> SRCOFF/CNT1</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 03h/04h</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> MOD ORD#1</P>
</TD><TD><P CLASS=FigureBody> IMPORT ORD1</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ADDITIVE1,2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> SRCOFF12</P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD><TD><P CLASS=FigureBody> SRCOFFn2</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=4><P CLASS=CellBody> 1These fields are variable size.<BR>2These fields are optional.</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>MOD ORD # = D[B|W] Ordinal index into the Import Module Name Table.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This value is an ordered index in to the Import Module Name Table for the module containing the procedure entry point. It is a Byte value when the '16-bit Object Number/Module Ordinal' Flag bit in the target flags field is clear and a Word value when the bit is set. The loader creates a table of pointers with each pointer in the table corresponds to the modules named in the Import Module Name Table. This value is used by the loader to index into this table created by the loader to locate the referenced module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>IMPORT ORD = D[B|W|D] Imported ordinal number.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is the imported procedure's ordinal number. It is a Byte value when the '8-bit Ordinal' bit in the target flags field is set. Otherwise it is a Word value when the '32-bit Target Offset Flag' bit in the target flags field is clear and a Dword value when the bit is set.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ADDITIVE = D[W|D] Additive fixup value.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field exists in the fixup record only when the 'Additive Fixup Flag' bit in the target flags field is set. When the 'Additive Fixup Flag' is clear the fixup record does not contain this field and is immediately followed by the next fixup record (or by the source offset list for this fixup record).
<DT CLASS=Body2><DD CLASS=Body2>This value is added to the address derived from the target entry point. This field is a Word value when the '32-bit Additive Flag' bit in the target flags field is clear and a Dword value when the bit is set.
</DL>
</DL>
<A NAME=HEADING-2-12-3></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-12-3">2.12.3   Import by Name Fixup Record</A></H1>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-20:  Import by Name Fixup Record</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> SRC</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD><P CLASS=FigureBody> SRCOFF/CNT1</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 03h/04h</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> MOD ORD#1</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> PROCEDURE NAME OFFSET1</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ADDITIVE1,2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> SRCOFF12</P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD><TD><P CLASS=FigureBody> SRCOFFn2</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=4><P CLASS=CellBody> 1These fields are variable size.<BR>2These fields are optional.</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>MOD ORD # = D[B|W] Ordinal index into the Import Module Name Table.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This value is an ordered index in to the Import Module Name Table for the module containing the procedure entry point. It is a Byte value when the '16-bit Object Number/Module Ordinal' Flag bit in the target flags field is clear and a Word value when the bit is set. The loader creates a table of pointers with each pointer in the table corresponds to the modules named in the Import Module Name Table. This value is used by the loader to index into this table created by the loader to locate the referenced module.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>PROCEDURE NAME OFFSET = D[W|D] Offset into the Import Procedure Name Table.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field is an offset into the Import Procedure Name Table. It is a Word value when the '32-bit Target Offset Flag' bit in the target flags field is clear and a Dword value when the bit is set.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ADDITIVE = D[W|D] Additive fixup value.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field exists in the fixup record only when the 'Additive Fixup Flag' bit in the target flags field is set. When the 'Additive Fixup Flag' is clear the fixup record does not contain this field and is immediately followed by the next fixup record (or by the source offset list for this fixup record).
<DT CLASS=Body2><DD CLASS=Body2>This value is added to the address derived from the target entry point. This field is a Word value when the '32-bit Additive Flag' bit in the target flags field is clear and a Dword value when the bit is set.
</DL>
</DL>
<A NAME=HEADING-2-12-4></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-12-4">2.12.4   Internal Entry Table Fixup Record</A></H1>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-21:  Internal Entry Table Fixup Record</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> SRC</P>
</TD><TD><P CLASS=FigureBody> FLAGS</P>
</TD><TD><P CLASS=FigureBody> SRCOFF/CNT1</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 03h/04h</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ORD #1</P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> ADDITIVE1,2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=2><P CLASS=FigureBody> SRCOFF12</P>
</TD><TD><P CLASS=FigureBody> . . .</P>
</TD><TD><P CLASS=FigureBody> SRCOFFn2</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> </P>
</TD><TD COLSPAN=4><P CLASS=CellBody> 1These fields are variable size.<BR>2These fields are optional.</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>ENTRY # = D[B|W] Ordinal index into the Entry Table.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field is an index into the current module's Entry Table to specify the target Object and offset. It is a Byte value when the '16-bit Object Number/Module Ordinal' Flag bit in the target flags field is clear and a Word value when the bit is set.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ADDITIVE = D[W|D] Additive fixup value.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field exists in the fixup record only when the 'Additive Fixup Flag' bit in the target flags field is set. When the 'Additive Fixup Flag' is clear the fixup record does not contain this field and is immediately followed by the next fixup record (or by the source offset list for this fixup record).
<DT CLASS=Body2><DD CLASS=Body2>This value is added to the address derived from the target entry point. This field is a Word value when the '32-bit Additive Flag' bit in the target flags field is clear and a Dword value when the bit is set.
</DL>
</DL>
<A NAME=HEADING-2-12-5></A>
<H3 CLASS=Heading3><A HREF="#TOC-2-12-5">2.12.5   Internal Chaining Fixups</A></H1>
<P CLASS=BodyFirst> Internal chaining fixups are 32-bit offset fixups (source type 07h) to internal references (target types 00h and 03h) where the first fixup in the chain is a record in the Fixup Record Table and the remaining fixups are located in the page referenced by the first fixup rather than as records in the Fixup Record Table. The chain is a linked-list with each fixup pointing to the next fixup in the chain until the end of the chain is reached. All fixups in the chain must fixup source offsets within the same page. All fixups in the chain must reference targets within the same memory object. All target references within a chain are also restricted to be within a 1 MB virtual memory range. Of course multiple chains can be used to meet the restrictions on an individual chain.</P>
<P CLASS=Body> The first fixup in the chain is contained in a record in the Fixup Record Table with the 'Internal Chaining Fixup Flag' bit in the target flags field set. This fixup is otherwise normal except that the 32-bit source location contains information about this fixup and the next fixup in the chain.</P>
<P CLASS=Body> Before applying an internal chaining fixup, the 32-bit value at the source location should be read. The first 12-bits of the value contain the source offset, within the page, for the next fixup in the chain and the remaining 20-bits contain the target offset of the current fixup.</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-22:  Internal Chaining Fixup Source Location</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=FigureBody> &lt; 12 bits &gt;</P>
</TD><TD><P CLASS=FigureBody> &lt; 20 bits &gt;</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=FigureBody> SRCOFF</P>
</TD><TD><P CLASS=FigureBody> TRGOFF</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>SRCOFF = Source offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field contains the source offset, from the start of the page, to the <EM CLASS="Emphasis Body2">next</EM> fixup in the chain. The final fixup in the chain is identified by the value of 0xFFF indicating no further fixups in the chain.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>TRGOFF = Target offset.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This field contains the target offset from a base target address for the <EM CLASS="Emphasis Body2">current</EM> fixup. A base target address for the all the fixups in the chain is computed by subtracting the TRGOFF value, found in the source location of the first fixup, from the target address computed for the first fixup, using the normal technique for the record in the Fixup Record Table. This base target address is then added to each TRGOFF in the fixup chain to compute the proper target address for the individual fixup.
<DT CLASS=Body2><DD CLASS=Body2>Since TRGOFF is limited to 20-bits, there is a 1 MB virtual memory range for the targets of all the fixups in a chain. The range is base target address to base target address + (1MB - 1).
</DL>
</DL>
<P CLASS=Body> The following pseudocode illustrates how the chain of fixups work.</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-23:  Internal Chaining Fixup Pseudocode</P>
</CAPTION><TR VALIGN=TOP><TD><PRE CLASS=Code>
source_page = address of source page containing fixups
source_offset = offset in page of fixup (from Fixup Record Table record)
target_address = address of target reference (from Fixup Record Table record)

if (fixup is an Internal Chaining Fixup)
{
	fixupinfo = *(source_page + source_offset)
	base_target_address = target_address - (fixupinfo &amp; 0xFFFFF)
	do
	{
		fixupinfo = *(source_page + source_offset)
		*(source_page + source_offset) =
				base_target_address + (fixupinfo &amp; 0xFFFFF)
		source_offset = (fixupinfo &gt;&gt; 20) &amp; 0xFFF)
	}
	while (source_offset != 0xFFF)
}
else
{
	*(source_page + source_offset) = target_address
}
</TD></TR></TABLE></PRE>

<HR CLASS=Heading2>
<A NAME=HEADING-2-13></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-13">2.13   Import Module Name Table</A></H1>

<P CLASS=Body> The import module name table defines the module name strings imported through dynamic link references. These strings are referenced through the imported relocation fixups.</P>
<P CLASS=Body> To determine the length of the import module name table subtract the import module name table offset from the import procedure name table offset. These values are located in the linear EXE header. The end of the import module name table is not terminated by a special character, it is followed directly by the import procedure name table.</P>
<P CLASS=Body> The strings are CASE SENSITIVE and NOT NULL TERMINATED.</P>
<P CLASS=Body> Each name table entry has the following format:</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-24:  Import Module Name Table</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> LEN</P>
</TD><TD><P CLASS=FigureBody> ASCII STRING ...</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>LEN = DB String Length.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This defines the length of the string in bytes. The length of each ascii name string is limited to 255 characters.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ASCII STRING = DB ASCII String.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This is a variable length string with it's length defined in bytes by the LEN field. The string is case sensitive and is not null terminated.
</DL>
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-14></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-14">2.14   Import Procedure Name Table</A></H1>

<P CLASS=Body>
The import procedure name table defines the procedure name strings imported
by this module through dynamic link references. These strings are referenced
through the imported relocation fixups.
</P>
<P CLASS=Body>
To determine the length of the import procedure name table add the fixup
section size to the fixup page table offset, this computes the offset to
the end of the fixup section, then subtract the import procedure name table
offset. These values are located in the linear EXE header. The import
procedure name table is followed by the data pages section.
</P>
<P CLASS=Body>
The strings are CASE SENSITIVE and NOT NULL TERMINATED.
</P>
<P CLASS=Body>
Each name table entry has the following format:
</P>
<TABLE BORDER=1><CAPTION>
<P CLASS=FigureTitle>
Figure 3-25:  Import Procedure Name Table
</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> LEN</P>
</TD><TD><P CLASS=FigureBody> ASCII STRING ...</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>LEN = DB String Length.
<DL CLASS=Body2>
<DT CLASS=Body2>
<DD CLASS=Body2>
This defines the length of the string in bytes. The length of each ascii name
string is limited to 255 characters.
<DT CLASS=Body2>
<DD CLASS=Body2>
The high bit in the LEN field (bit 7) is defined as an Overload bit. This bit
signifies that additional information is contained in the linear EXE module
and will be used in the future for parameter type checking.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>ASCII STRING = DB ASCII String.
<DL CLASS=Body2>
<DT CLASS=Body2>
<DD CLASS=Body2>This is a variable length string with it's length defined in
bytes by the LEN field. The string is case sensitive and is not null terminated.
</DL>
</DL>
<P CLASS=Note>
Note:  The first entry in the import procedure name table must be a null
entry. That is, the LEN field should be zero followed an empty ASCII STRING
(no bytes).
</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-15></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-15">2.15   Preload Pages</A></H1>

<P CLASS=Body>
The Preload Pages section is an optional section in the linear EXE module that
coalesces a 'preload page set' into a contiguous section. The preload page set
can be defined as the set of first used pages in the module. The preload page
set can be specified by the application developer or can be derived by a tool
that analyzes the programs memory usage while it is running. By grouping the
preload page set together, the preload pages can be read from the linear EXE
module with one disk read.
</P>
<P CLASS=Body>
The structure of the preload pages is no different than if they were demand
loaded. Their sizes are determined by the Object Page Table entries that
correspond. If the specified size is less than the PAGE SIZE field given in
the linear EXE module header the remainder of the page is filled with zeros
when loaded.
</P>
<P CLASS=Body>
All pages begin on a PAGE OFFSET SHIFT boundary from the base of the preload
page section, as specified in the linear EXE header. The pages are ordered by
logical page number within this section.
</P>
<P CLASS=Note>
Note:  OS/2 2.x does not respect the preload of pages as specified in the
executable file for performance reasons.
</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-16></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-16">2.16   Demand Load Pages</A></H1>

<P CLASS=Body> The Demand Loaded Pages section contains all the non-iterated
pages for a linear EXE module that are not preloaded. When required, the whole
page is loaded into memory from the module. The characteristics of each of
these pages is specified in the Object Page Table. Every page begins on a
PAGE OFFSET SHIFT boundary aligned offset from the demand loaded pages base
specified in the linear EXE header. Their sizes are determined by the Object
Page Table entries that correspond. If the specified size is less than the
PAGE SIZE field given in the linear EXE module header the remainder of the
page is filled with zeros when loaded. The pages are ordered by logical page
number within this section.</P>

<HR CLASS=Heading2>
<A NAME=HEADING-2-17></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-17">2.17   Iterated Data Pages</A></H1>

<P CLASS=Body>
The Iterated Data Pages section contains all the pages for a
linear EXE module that are iterated. When required, the set of iteration
records are loaded into memory from the module and expanded to reconstitute
the page. Every set of iteration records begins on a PAGE OFFSET SHIFT offset
from the OBJECT ITER PAGES OFF specified in the linear EXE header. Their sizes
are determined by the Object Page Table entries that correspond. The pages are
ordered by logical page number within this section.
</P>
<P CLASS=Body>
This record structure is used to describe the iterated data for an object on
a per-page basis.
</P>
<TABLE BORDER=1><CAPTION>
<P CLASS=FigureTitle>
Figure 3-26:  Object Iterated Data Record (Iteration Record)
</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellValue> 00h</P>
</TD><TD><P CLASS=FigureBody> #ITERATIONS</P>
</TD><TD><P CLASS=FigureBody> DATA LENGTH</P>
</TD><TD><P CLASS=FigureBody> </P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=CellValue> 04h</P>
</TD><TD><P CLASS=FigureBody> DATA BYTES</P>
</TD><TD><P CLASS=FigureBody> ...</P>
</TD><TD><P CLASS=FigureBody> ...</P>
</TD></TR></TABLE><DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>#ITERATIONS = DW Number of iterations.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This specifies the number of times that the
data is replicated.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DATA LENGTH = DW The size of the data pattern
in bytes.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This specifies the number of bytes of data of
which the pattern consists. The maximum size is one half of the PAGE SIZE
(given in the module header). If a pattern exceeds this value then the data
page will not be condensed into iterated data.
</DL>
<DT CLASS=Body1><DD CLASS=Body1>DATA = DB * DATA LENGTH The Data pattern to
be replicated.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>The next iteration record will immediately
follow the last byte of the pattern. The offset of the next iteration record
is easily calculated from the offset of this record by adding the DATA LENGTH
field and the sizes of the #ITERATIONS and DATA LENGTH fields.
</DL>
</DL>

<HR CLASS=Heading2>
<A NAME=HEADING-2-18></A>
<H2 CLASS=Heading2><A HREF="#TOC-2-18">2.18   Debug Information</A></H1>

<P CLASS=Body>
The debug information is defined by the debugger and is not controlled by the
linear EXE format or linker. The only data defined by the linear EXE format
relative to the debug information is it's offset in the EXE file and length
in bytes as defined in the linear EXE header.
</P>
<P CLASS=Body>
To support multiple debuggers the first word of the debug information is a
type field which determines the format of the debug information.
</P>
<TABLE BORDER=1><CAPTION><P CLASS=FigureTitle>Figure 3-27:  Debug Information</P>
</CAPTION><TR VALIGN=TOP><TD><P CLASS=CellBody> 00h</P>
</TD><TD><P CLASS=CellBody> 01h</P>
</TD><TD><P CLASS=CellBody> 02h</P>
</TD><TD><P CLASS=CellBody> 03h</P>
</TD><TD><P CLASS=CellBody> 04h</P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=FigureBody> 'N'</P>
</TD><TD><P CLASS=FigureBody> 'B'</P>
</TD><TD><P CLASS=FigureBody> '0'</P>
</TD><TD><P CLASS=FigureBody> n</P>
</TD><TD><P CLASS=FigureBody> DEBUGGER DATA . . . .</P>
</TD></TR>
</TABLE>
<DL CLASS=Body1>
<DT CLASS=Body1><DD CLASS=Body1>TYPE = DB DUP 4 Format type.
<DL CLASS=Body2>
<DT CLASS=Body2><DD CLASS=Body2>This defines the type of debugger data that
exists in the remainder of the debug information. The signature consists of
a string of four (4) ASCII characters: "NB0" followed by the ASCII
representation for 'n'. The values for 'n' are defined as follows.
<DT CLASS=Body2><DD CLASS=Body2>These format types are defined.
<DL CLASS=Body3>
<DT CLASS=Body3><DD CLASS=Body3>00h = 32-bit CodeView debugger format.
<DT CLASS=Body3><DD CLASS=Body3>01h = AIX debugger format.
<DT CLASS=Body3><DD CLASS=Body3>02h = 16-bit CodeView debugger format.
<DT CLASS=Body3><DD CLASS=Body3>04h = 32-bit OS/2 PM debugger (IBM) format.
<DT CLASS=Body3><DD CLASS=Body3>DEBUGGER DATA = Debugger specific data.
</DL>
<DT CLASS=Body2><DD CLASS=Body2>The format of the debugger data is defined by
the debugger that is being used.
<DT CLASS=Body2><DD CLASS=Body2>The values defined for the type field are not
enforced by the system. It is the responsibility of the linker or debugging
tools to follow the convention for the type field that is defined here. 
</DL>
</DL>
</DIV>

<DIV CLASS=WM-DIV-FOOTNOTES>
<HR>
<A NAME=FOOTNOTE-1>[1] </A>
Windows is a Registered Trademark of Microsoft Corp.
</DIV>

<DIV CLASS=WM-DIV-FOOTERS>
<HR>
<ADDRESS>IBM OS/2 16/32-bit Linear eXecutable Module Format (LX) - 14 Jun 2001</ADDRESS>
</DIV>

</BODY>
</HTML>
