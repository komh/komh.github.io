<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Using Threads</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Using Threads</H1><!-- entering slot 46 -->
<P>
Threads are an important DCE feature that can affect DSS performance.  It
is recommended to conserve threads whenever possible.  Although threads
are convenient for structuring an application, they have a cost.  Each thread
has its own stack and associated data structures that add to the memory
requirements of the application.  In addition, threads are usually scheduled
in round-robin fashion, with each thread waiting its turn to run.  Thus,
the more active threads, the longer a given thread may have to wait before
it runs.
<P>
Also, creating and destroying threads takes time.  Instead of creating a
thread whenever needed and destroying it when the job is done, consider
using a thread pooling strategy.  This way, threads that have finished their
assignment check a queue of jobs for more work, and wait if no work is available.

<P>
Because a thread can be interrupted at any moment and another one scheduled,
try to avoid holding locks unnecessarily.  If a thread is interrupted while
it holds an important lock and another thread is dispatched, only to try
to grab the lock and get blocked, time has been wasted on context switching
back and forth.  The second thread is not going to make any progress until
the first one releases the lock.  You can reduce this occurrence by holding
locks for shorter times, and by using finer grained locks.  Use different
locks for logically separate structures rather than one global lock.  However,
you have to trade this against the cost of locking and unlocking.

<P><HR>

<A HREF="038_L2_GeneralDCEPerformanc.html">[Back: General DCE Performance Suggestions]</A> <BR>
<A HREF="040_L1_SamplePrograms.html">[Next: Sample Programs]</A> 
</BODY>
</HTML>
