<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Programming with Objects</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Programming with Objects</H1><!-- entering slot 277 -->
<P>
An example might make object-oriented programming concepts clearer. A stack
is a common programming construct, permitting data to be stored and retrieved
in a Last-In, First-Out (LIFO) manner, that is, the last data element placed
on the stack is the first element that is retrieved from the stack.
<P>
The data structure for the stack describes the stack, a place to store the
data put on the stack and a variable to keep track of the location of the
top of the stack. Given the definition of the data structure, multiple instances
of the stack can be declared within a program.
<P>
There are two basic operations that can be performed on a stack: pushing
data onto the stack and popping data off from the stack. It also is beneficial
to dynamically create a stack. Functions to perform these activities must
be defined.
<P>
The following sample code shows the definition of a stack data structure
and functions and the implementation for the Push function:
<PRE>/* Define the stack */
struct stackType
{
  void *stackArray[STACK_SIZE];
  int stackTop;
};
typedef struct stackType Stack;

/* Define the stack's functions */
Stack *Create();                /* Create a new stack                  */
void Push(Stack *thisStack,     /* Push an element onto the stack      */
          void *nextElement);
void *Pop(Stack *thisStack);    /* Pop an element off from the stack   */

/* The definition of the Push function is provided as an example.  */
/* The rest of the functions would be defined in a similar manner. */
void Push(Stack *thisStack, void *nextElement)
{
  thisStackstackArray[thisStackstackTop] = nextElement;
  thisStackstackTop++;
}

</PRE>

<P>
A client program might use this stack to create a stack of words needing
interpretation, as in the following sample code:
<PRE>main()
{
  Stack *WordStack;

  char *Subject = "Emily";
  char *Verb    = "eats";
  char *Object  = "ice cream";
  char *NextWord;

  WordStack = Create();
  Push(WordStack, Object);
  Push(WordStack, Verb);
  Push(WordStack, Subject);
     .
     .
     .

  while (NextWord = Pop(WordStack))
  {
    printf("%s\n", NextWord);
     .
     .
     .
  }
}

</PRE>

<P>
The stack is an example of a class. The stack contains two data elements,
<I>stackArray</I> and<I> stackTop</I>, and supports three methods: Create,
Push, and Pop.<I> WordStack</I> is an object of class Stack; it also can
be called an<I> instance</I> of a stack.
<P>
Methods must know the specific object on which they are to operate, which
is called the<I> target object</I> or, sometimes, the<I> receiving object</I>.
Notice that each method (except Create) takes as its first parameter a pointer
to the target object. This is because a program might have many objects
of a given class, and each is a potential target for the class methods.


<P><HR>

<A HREF="257_L2_UsingWorkplaceShella.html">[Back: Using Workplace Shell and SOM]</A> <BR>
<A HREF="259_L3_UsingaReleaseOrderLi.html">[Next: Using a Release Order List]</A> 
</BODY>
</HTML>
