<HTML>
<HEAD>
<TITLE>Initialization of Scalar Types</TITLE>
</HEAD>
<BODY>
<H1>Initialization of Scalar Types</H1><!-- entering slot 719 -->
<P>
A scalar data item represents a numeric quantity that may be increased or
decreased in magnitude as a single unit.  Thus, an<I> Initializer</I> expression
for a scalar data item must be coded such that it resolves to a single scalar
value.  See the section on <A HREF="620_L3_InitializerExpressio.html"><I>Scalar-Initializer-ExpressionType
</I></A>for the syntax and semantics of such expressions.
<P>
The old-style allocation directives (DB, DW, DD, DF, DQ, and DT) are supported
in all assembler emulation modes, but for modes other than <A HREF="111_L5_SvSetVersionBehavior.html">M510</A>,
the <A HREF="131_L3_ScalarTypeNames.html"><I>Scalar-TypeName</I></A> keywords
should be used instead.
<P>
When the <A HREF="131_L3_ScalarTypeNames.html"><I>Scalar-TypeName</I></A> keywords
are used instead of the old-style allocation directives, the assembler has
full knowledge of the data types of the variables being created.  This allows
the assembler to make more intelligent code generation decisions, and it
enables the assembler to correctly describe the variable in the symbolic
debugging information that it generates for the source level debugger.  <A HREF="131_L3_ScalarTypeNames.html"><I>Scalar-TypeName</I></A><I>s
</I>may not be used as allocation directives in the <A HREF="111_L5_SvSetVersionBehavior.html">M510
</A>mode.
<P>
To allocate an uninitialized scalar data item, use the <A HREF="146_L3_IndeterminateValueAl.html"><I>Indeterminate-Value-Alias
</I></A>($) in the<I> Initializer</I> field.
<PRE>ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Type Name³Data Type           ³Initializer Description                 ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³DB, BYTE,³Allocates 8-bit     ³Each <I>Initializer</I> must be in the range   ³
³or SBYTE ³(byte) values.      ³from 0 to 255 (unsigned) for a DB or    ³
³         ³                    ³BYTE directive, and from -128 to 127    ³
³         ³                    ³(signed) for a SBYTE directive.         ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³DW, WORD,³Allocates 16-bit    ³Each <I>Initializer</I> must be in the range   ³
³or SWORD ³(word) values.      ³from 0 to 65535 (unsigned) for a DW or  ³
³         ³                    ³WORD directive, and from -32768 to 32767³
³         ³                    ³(signed) for a SWORD directive.         ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³DD,      ³Allocates 32-bit    ³If the <I>Initializer</I> is an integer, each  ³
³DWORD, or³(double-word)       ³must be in the range from 0 to          ³
³SDWORD   ³values.             ³4,294,967,295 (unsigned) for a DD or    ³
³         ³                    ³DWORD directive, and from -2,147,483,648³
³         ³                    ³to 2,147,483,647 (signed) for a SDWORD  ³
³         ³                    ³directive.  If the DD directive is being³
³         ³                    ³used, an <I>Initializer</I> may also resolve to³
³         ³                    ³a 32-bit <A HREF="613_L4_FloatingPointExpress.html"><I>Floating-Point-ExpressionType</I></A>. ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³DF or    ³Allocates 48-bit    ³Each <I>Initializer</I> typically specifies the³
³FWORD    ³(6-byte far-word)   ³full address of a 32-bit far code or    ³
³         ³values.             ³data label, but normal 32-bit integer   ³
³         ³                    ³values may also be used.  The processor ³
³         ³                    ³does not support 48-bit integer         ³
³         ³                    ³operations, thus the assembler does     ³
³         ³                    ³support 48-bit integer precision when   ³
³         ³                    ³initializing such variables.  These     ³
³         ³                    ³directives are typically only useful for³
³         ³                    ³defining pointer variables for use on   ³
³         ³                    ³32-bit processors.                      ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³DQ or    ³Allocates 64-bit    ³Both DQ and QWORD allow an integer      ³
³QWORD    ³(quad-word) values. ³<I>Initializer</I> with 64-bit (8-byte)        ³
³         ³                    ³precision.  If the DQ directive is being³
³         ³                    ³used, the <I>Initializer</I> field may resolve ³
³         ³                    ³to a 64-bit                             ³
³         ³                    ³<A HREF="613_L4_FloatingPointExpress.html"><I>Floating-Point-ExpressionType</I></A>.          ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³DT or    ³Allocates 80-bit    ³Both DT and TBYTE allow an integer      ³
³TBYTE    ³(10-byte) values    ³<I>Initializer</I> with 80-bit (10-byte)       ³
³         ³                    ³precision.  If the DT directive is being³
³         ³                    ³used, the <I>Initializer</I> field may resolve ³
³         ³                    ³to a 80-bit                             ³
³         ³                    ³<A HREF="613_L4_FloatingPointExpress.html"><I>Floating-Point-ExpressionType</I></A>.          ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³REAL4,   ³Allocates real      ³Each <I>Initializer</I> must resolve to a      ³
³REAL8, or³(floating-point)    ³<A HREF="613_L4_FloatingPointExpress.html"><I>Floating-Point-ExpressionType</I></A>.  The     ³
³REAL10   ³values of a specific³assembler converts the floating-point   ³
³         ³size (4 bytes, 8    ³literal to the IEEE format appropriate  ³
³         ³bytes, or 10 bytes).³for the type of variable being          ³
³         ³                    ³allocated.                              ³
ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
</PRE>
<!-- lm: 0x2 1 -->
<UL>
<P>
<B>Examples</B><!-- lm: 0x2 11 -->
<UL>
<P>
Here are some examples of scalar initialization:
<PRE>; Allocate some integer variables
uint8      BYTE      0, 255             ; min, max values for unsigned byte
sint8      SBYTE     -128, 127          ; min, max values for signed byte
USHORT_<!-- entering slot 720 -->T   TYPEDEF   WORD               ; Define a typedef alias for WORD
ushort     USHORT_T  0, 0FFFFh          ; and use it as allocation type name

; Some things to know about string-literal initializers
char       BYTE      "a"                ; a single BYTE value (061h)
is_int     WORD      "ab"               ; a single WORD value (06162h)
this_too   DWORD     "abcd"             ; a single DWORD value (061626364h)
too_long   WORD      "abcd"             ; error, expression too big for a word
string     BYTE      "string", 0        ; but strings can allocate many bytes

; Integers, pointers, and old-style initializations
PDWORD_T   TYPEDEF   PTR DWORD          ; First, define a pointer type
ulong      DWORD     0, 0FFFFFFFFh      ; min, max values for unsigned dword
pulong     PDWORD_T  OFFSET ulong       ; pointer to the ulong variable
old_style  DD        1.314              ; old style, floats are accepted
new_int    SDWORD    1.314              ; new style, error-must use integers
new_real   REAL4     1314               ; new style, error-must use floats

; Allocate some real numbers using decimal floating-point literals
float_f    REAL4     123.45             ; 4-byte IEEE real
double_f   REAL8     98.7654E1          ; 8-byte IEEE real
longdbl_f  REAL10    1000.0E-2          ;10-byte IEEE real

; The same values using hexdecimal floating-point literals
float_h    REAL4  42F6E666r             ; 4-byte IEEE real
double_h   REAL8  408EDD3B645A1CACr     ; 8-byte IEEE real
longdbl_h  REAL10 4002A000000000000000r ;10-byte IEEE real
</PRE>
<!-- lm: 0x2 1 -->
</UL>

<P><HR>

<A HREF="715_L2_DataAllocation.html">[Back: Data Allocation]</A> <BR>
<A HREF="717_L3_InitializationofAggr.html">[Next: Initialization of Aggregate Types]</A> 
</BODY>
</HTML>
