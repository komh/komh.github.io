<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Implementing SOM Classes</TITLE>
</HEAD>
<BODY>
<H1>Implementing SOM Classes</H1><!-- entering slot 167 -->
<P>
The<I> interface</I> to a class of objects contains the information that
a client must know to use an object - namely, the signatures of its methods
and the names of its attributes. The interface is described in a formal
language independent of the programming language used to implement the object's
methods. In SOM, the formal language used to define object interfaces is
the Interface Definition Language (described in Chapter 4, "SOM IDL and
the SOM Compiler").
<P>
The<I> implementation</I> of a class of objects  (that is, the procedures
that implement the methods and the instance variables that store an object's
state) is written in the implementor's preferred programming language. This
language can be object-oriented (for instance, C++) or procedural (for instance,
C).
<P>
A completely implemented class definition, then, consists of two main files:
<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->An IDL specification of the interface to instances
of the class - the interface definition file (or .idl file) and<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->Method procedures written in the implementor's language
of choice - the implementation file.<!-- lm: 0x2 1 -->
</UL>
<P>
The SOM Compiler provides the link between those two files: To assist users
in implementing classes, the SOM Compiler produces a template implementation
file - a type-correct guide for how the implementation of a class should
look. Then, the class implementor modifies this template file to fully implement
the class's methods.  That process is the subject of the remainder of this
chapter.
<P>
The SOM Compiler can also update the implementation file to reflect changes
subsequently made to a class's interface definition file (the .idl file).
These<I> incremental updates</I> include adding new stub procedures, adding
comments, and changing method prototypes to reflect changes made to the
method definitions in the IDL specification. These updates to the implementation
file, however, do<U> not</U> disturb existing code in the method procedures.
These updates are discussed further in "Running incremental updates of the
implementation template file" later in this section.
<P>
For C programmers, the SOM Compiler generates a &lt;<I>filestem</I>&gt;<B>.c
</B>file. For C++ programmers, the SOM Compiler generates a &lt;<I>filestem</I>&gt;<B>.C
</B> file (for AIX) or a &lt;<I>filestem</I>&gt;<B>.cpp</B> file (for OS/2).
To specify whether the SOM Compiler should generate a C or C++ implementation
template, set the value of the SMEMIT environment variable, or use the<B> -s
</B>option when running the SOM Compiler. (See "The SOM Compiler" in Chapter
4, "SOM IDL and the SOM Compiler.")
<P>
<B>Note: </B> As this chapter describes, a SOM class can be implemented
by using C++ to define the instance variables introduced by the class and
to define the procedures that implement the overridden and introduced methods
of the class. Be aware, however, that the C++ class defined by the C++ usage
bindings for a SOM class (described in Chapter 3) cannot be subclassed in
C++ to create new C++ or SOM classes. [The reason why the C++ implementation
of a SOM class involves the definition of C++ procedures (not C++ methods)
to support SOM methods is that there is no language-neutral way to call
a C++ method. Only C++  code can call C++ methods, and this calling code
must be generated by the same compiler that generates the method code. In
contrast, the method procedures that implement SOM methods must be callable
from any language, without knowledge on the part of the object client as
to which language is used to implement the resolved method procedure]<!-- lm: 0x2 1 -->
<P>


<P><HR>

<A HREF="136_L4_Directcallprocedures.html">[Back: Direct-call procedures]</A> <BR>
<A HREF="138_L3_Theimplementationtem.html">[Next: The implementation template]</A> 
</BODY>
</HTML>
