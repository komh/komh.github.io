<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Notes and advantages of 'before/after' usage</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Notes and advantages of 'before/after' usage</H1><!-- entering slot 386 -->
<P>
Notes on the dispatching of before/after methods:<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->A before (after) method is invoked just once per primary
method invocation.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->The dispatching of before/after methods is thread-safe.
<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->The dispatching of before/after methods is fast. The
time overhead for dispatching a primary method is on the order of N times
the time to invoke a before/after method as a procedure, where N is the
total number of before/after methods to be applied.<!-- lm: 0x2 1 -->
</UL>
<P>
In conclusion, consider an example that clearly demonstrates the power of
the composition of before/after metaclasses. Suppose you are creating a
class library that will have n classes. Further suppose there are p properties
that must be included in all combinations for all classes. Potentially,
the library must have n2p classes. Let us hypothesize that (fortunately)
all these properties can be captured by before/after metaclasses. In this
case, the size of the library is n+p.
<P>
The user of such a library need only produce those combinations necessary
for a given application. In addition, note that there is none of the usual
programming. Given the IDL for a combination of before/after metaclasses,
the SOM compiler generates the implementation of the combination (in either
C or C++) with no further manual intervention.

<P><HR>

<A HREF="336_L3_Compositionofbeforea.html">[Back: Composition of before/after metaclasses]</A> <BR>
<A HREF="338_L2_TheSOMMSingleInstanc.html">[Next: The 'SOMMSingleInstance' Metaclass]</A> 
</BODY>
</HTML>
