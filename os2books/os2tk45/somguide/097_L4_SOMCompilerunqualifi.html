<HTML>
<HEAD>
<TITLE>SOM Compiler unqualified modifiers</TITLE>
</HEAD>
<BODY>
<H1>SOM Compiler unqualified modifiers</H1><!-- entering slot 116 -->
<P>
Unqualified modifiers (described below) include the SOM Compiler-defined
identifiers<B> abstract, baseproxyclass, callstyle, classinit, directinitclasses,
dllname, filestem, functionprefix, majorversion, metaclass, memory_management,
</B><B>minorversion, somallocte and somdeallocate.</B><!-- lm: 0x2 1 -->
<UL>
<P>
<B>abstract</B><!-- lm: 0x2 26 -->
<UL> Specifies that the class is intended
for use as a parent for subclass derivations, but not for creating instances.
<!-- lm: 0x2 1 -->
</UL><B>baseproxyclass =</B>class<!-- lm: 0x2 26 -->
<UL> Specifies
the base proxy class to be used by DSOM when dynamically creating a proxy
class for the current class. The base proxy class must be derived from the
class<B> SOMDClientProxy</B>  The<B> SOMDClientProxy</B> class will be used
if the<B> baseproxyclass</B> modifier is unspecified. (See chapter 6, "distributed
SOM," for a discussion on customizing proxy classes.)<!-- lm: 0x2 1 -->
</UL><B> callstyle
</B><B>=</B><B> oidl</B><!-- lm: 0x2 26 -->
<UL> Specifies that the method
stub procedures generated by SOM's C/C++ bindings will not include the CORBA-specified
(<I>Environment *ev)</I> and (<I>context *ctx</I>) parameters.<!-- lm: 0x2 1 -->
</UL><B> classinit
=</B><I> procedure</I><!-- lm: 0x2 26 -->
<UL> Specifies a user-written
procedure that will be executed to complete the initialization of a class
object after it is created. The<B> classinit</B> modifier is needed if something
should happen exactly<I> once</I> when a class is created. (That is, you
want to define an action that will not be inherited when subclasses are
created. One example of this is for<B> staticdata</B> variables.) When the
<B>classinit</B> modifier is specified in the .idl file for a class, the
implementation file generated by the SOM Compiler provides a template for
the procedure, which includes a parameter that is a pointer to the class.
The class implementor can then fill in the body of this procedure template.
(For an example, see the examples following the<B> staticdata</B> modifier
under "SOM Compiler qualified modifiers.")<!-- lm: 0x2 1 -->
</UL><B> directinitclasses
=</B><I>"ancestor1, ancestor2, ..."</I>
<BR>
<!-- lm: 0x2 26 -->
<UL>Specifies the ancestor class(es) whose initializers
(and destructors) will be directly invoked by this class's initialization
(and destruction) routines.  If this modifier is not explicitly specified,
the default setting is the parents of the class. For further information,
see "Initializing and Uninitializing Objects" in Chapter 5, "Implementing
Classes in SOM."<!-- lm: 0x2 1 -->
</UL><B> dllname</B><B> =</B><I> filename
</I><!-- lm: 0x2 26 -->
<UL>Specifies the name of the library file that
will contain the class's implementation. If<I> filename</I> contains special
characters (e.g., periods, backslashes), then<I> filename</I> should be
surrounded by double quotes (""). The<I> filename</I> specified can be either
a full pathname, or an unqualified (or partially qualified) filename. In
the latter cases, the LIBPATH environment variable is used to locate the
file.<!-- lm: 0x2 1 -->
</UL><B> filestem</B> <B> =</B><I> stem</I><!-- lm: 0x2 26 -->
<UL> Specifies
how the SOM Compiler will construct file names for the binding files it
generates (&lt;stem&gt;.h, &lt;stem&gt;.c, etc.). The default stem is the
file stem of the .idl file for the class.<!-- lm: 0x2 1 -->
</UL><B> functionprefix
</B> <B>=</B><I> prefix</I><!-- lm: 0x2 26 -->
<UL> Directs the SOM Compiler
to construct method-procedure names by prefixing method names with "prefix".
For example, "functionprefix = xx;"  within an<B> implementation</B> statement
would result in a procedure name of xxfoo for method foo.  The default for
this attribute is the empty string. If an interface is defined in a module,
then the default function prefix is the fully scooped interface name.<U> Tip</U>:
 Using a function prefix with the same name as the class makes it easier
to remember method-procedure names when debugging.
<P>
When an .idl file defines multiple interfaces not contained within a module,
use of a function prefix for<!-- entering slot 117 --> each interface is
essential to avoid name collisions.  For example, if one interface introduces
a
<BR>
method and another interface in the same .idl file overrides it, then the
implementation file for the classes will contain two method procedures of
the same name (unless function prefixes are defined for one of the classes),
resulting in a name collision at compile time.<!-- lm: 0x2 1 -->
</UL><B> majorversion
=</B><I> number</I><!-- lm: 0x2 26 -->
<UL> Specifies the major version
number of the current class definition. The major version number of a class
definition usually changes only when a significant enhancement or incompatible
change is made to the class. The "number" must be a positive integer less
than 2[32]-1.  If a non-zero major version number is specified, SOM will
verify that any code that purports to implement the class has the same major
version number. The default major version number is zero.<!-- lm: 0x2 1 -->
</UL><B> memory_management
= corba</B>
<BR>
<!-- lm: 0x2 26 -->
<UL>Specifies that all methods introduced by the class
follow the CORBA specification for parameter memory management, except where
a particular method has an explicit modifier indicating otherwise (either
"object_owns_result" or "object_owns_parameters").  See the section in Chapter
6 entitled "Memory Management" for a discussion of the CORBA memory-management
requirements.<!-- lm: 0x2 1 -->
</UL><B> metaclass =</B><I> class</I><!-- lm: 0x2 26 -->
<UL> Specifies
the class's metaclass. The specified metaclass (or one automatically derived
from it at run time) will be used to create the class object for the class.
If a<B> metaclass</B> is specified, its .idl file (if separate) must be
included in the<B> include</B> section of the class's .idl file. If no metaclass
is specified, the metaclass will be defined automatically.<!-- lm: 0x2 1 -->
</UL><B> minorversion
=</B><I> number</I><!-- lm: 0x2 26 -->
<UL> Specifies the minor version
number of the current class definition. The minor version number of a class
definition changes whenever minor enhancements or fixes are made to a class.
Class implementers usually maintain backward compatibility across changes
in the minor version number. The "number" must be a positive integer less
than 2[32]-1. If a non-zero minor version number is specified, SOM will
verify that any code that purports to implement the class has the same or
a higher minor version number. The default minor version number is zero.
<!-- lm: 0x2 1 -->
</UL><B>somallocate=</B><I>procedure</I><!-- lm: 0x2 26 -->
<UL> Specifies
a user-written procedure that will be executed to allocate memory for class
instances when the<B> somAllocate</B> class method is invoked.<!-- lm: 0x2 1 -->
</UL><B> somdeallocate=</B><I>procedure
</I><!-- lm: 0x2 26 -->
<UL>Specifies a user-written procedure that will
be executed to deallocate memory for class instances when the<B> somDeallocate
</B>class method is invoked.<!-- lm: 0x2 1 -->
</UL>
<P>
The following example illustrates the specification of unqualified interface
modifiers:
<PRE>   implementation   {
     filestem = hello;
     functionprefix = hel;
     majorversion = 1;
     minorversion = 2;
     classinit = helloInit;
     metaclass = M_Hello;
   };
</PRE>


<P><HR>

<A HREF="096_L4_Modifierstatements.html">[Back: Modifier statements]</A> <BR>
<A HREF="098_L4_SOMCompilerqualified.html">[Next: SOM Compiler qualified modifiers]</A> 
</BODY>
</HTML>
