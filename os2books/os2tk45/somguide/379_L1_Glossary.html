<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Glossary</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Glossary</H1><!-- entering slot 432 -->
<P>
 
<P>
Note:  In the following definitions, words shown in<I> italics</I> are terms
for which separate glossary entries are also defined.<!-- lm: 0x2 1 -->
<UL>
<P>
<B>abstract class</B><!-- lm: 0x2 11 -->
<UL> A<I> class</I> that is not
designed to be instantiated, but serves as a<I> base class</I> for the definition
of subclasses. Regardless of whether an abstract class inherits<I> instance
data</I> and<I> methods</I> from<I> parent classes</I>, it will always introduce
methods that must be<I> overridden</I> in a<I> subclass,</I> in order to
produce a class whose objects are semantically valid.<!-- lm: 0x2 1 -->
</UL><B> affinity
group</B><!-- lm: 0x2 11 -->
<UL> An array of<I> class objects</I> that
were all registered with the<I> SOMClassMgr</I> object during the dynamic
loading of a<I> class</I>. Any class is a member of at most one affinity
group.<!-- lm: 0x2 1 -->
</UL><B> ancestor class</B><!-- lm: 0x2 11 -->
<UL> A
<I>class</I> from which another class inherits<I> instance methods, attributes,
</I>and<I> instance variables</I>, either directly or indirectly. A direct
descendant of an ancestor class is called a<I> child class, derived class,
</I>or<I>  subclass.</I> A direct ancestor of a class is called a<I> parent
class, base class</I>, or<I> superclass</I>.<!-- lm: 0x2 1 -->
</UL><B> aggregate
type</B><!-- lm: 0x2 11 -->
<UL> A user-defined data type that combines
basic types (such as, char, short, float, and so on) into a more complex
type (such as structs, arrays, strings, sequences, unions, or enums).<!-- lm: 0x2 1 -->
</UL><B> apply
stub</B><!-- lm: 0x2 11 -->
<UL> A<I> procedure</I> corresponding to a particular
<I>method</I> that accepts as arguments: the<I> object</I> on which the
method is to be invoked, a pointer to a location in memory where the method's
result should be stored, a pointer to the method's procedure, and the method's
arguments in the form of a va_list. The apply stub extracts the arguments
from the va_list, invokes the method with its arguments, and stores its
result in the specified location. Apply stubs are registered with class
objects when instance methods are defined, and are invoked using the somApply
function. Typically,<I> implementations</I> that<I> override</I> somDispatch
call somApply to invoke a method on a va_list of arguments.<!-- lm: 0x2 1 -->
</UL><B> attribute
</B><!-- lm: 0x2 11 -->
<UL>A specialized syntax for declaring "set" and
"get" methods. Method names corresponding to attributes always begin with
"_set_" or "_get_". An attribute name is declared in the body of the<I> interface
statement</I> for a class. Method procedures for get/set methods are automatically
defined by the<I> SOM Compiler</I> unless an attribute is declared as "noget/noset".
Likewise, a corresponding<I> instance variable</I> is automatically defined
unless an attribute is declared as "nodata". IDL also supports "readonly"
attributes, which specify only a "get" method. (Contrast an attribute with
an<I> instance variable.</I>)<!-- lm: 0x2 1 -->
</UL><B> auxiliary class
data structure:</B><!-- lm: 0x2 11 -->
<UL> A structure provided by the
SOM API to support efficient static access to<I> class</I>-specific information
used in dealing with SOM<I> objects</I>. The structure's name is &lt;<I>className</I>&gt;CClassData.
Its first component (parentMtab) is a list of<I> parent-class</I><I> method
tables</I> (used to support efficient parent method calls). Its second component
(instanceDataToken) is the<I> instance token</I> for the class (generally
used to locate the<I> instance data</I> introduced by<I> method procedures
</I>that implement<I> methods</I> defined by the class).<!-- lm: 0x2 1 -->
</UL><B> base
class</B><!-- lm: 0x2 11 -->
<UL> See<I> parent class.</I><!-- lm: 0x2 1 -->
</UL><B> behavior
(of an object)</B><!-- lm: 0x2 11 -->
<UL> The<I> methods</I> that an<I> object
</I>responds to. These methods are those either introduced or inherited
by the<I> class</I> of the object. See also<I> state.</I><!-- lm: 0x2 1 -->
</UL><B> bindings:
</B><!-- lm: 0x2 11 -->
<UL>Language-specific macros and procedures that
make implementing and using SOM classes more convenient. These bindings
offer a convenient interface to SOM that is tailored to a particular programming
language. The<I> SOM Compiler</I> generates binding files for C and C ++.
These binding files include an<I><!-- entering slot 433 --> implementation
template</I> for the class and two header files, one to be included in the
class's implementation file and the other in client programs.<!-- lm: 0x2 1 -->
</UL><B> BOA
(basic object adapter) class:</B><!-- lm: 0x2 11 -->
<UL> A CORBA<I> interface
</I>(represented as an<I> abstract class</I> in DSOM), which defines generic
<I>object-adapter (OA)</I> methods that a<I> server</I> can use to register
itself and its<I> objects</I> with an<I> ORB (object request broker)</I>.
See also<I> SOMOA (SOM object adapter) class.</I> <!-- lm: 0x2 1 -->
</UL><B> callback
</B><!-- lm: 0x2 11 -->
<UL>A user-provided procedure or method to the Event
Management Framework that gets invoked when a registered event occurs. (See
also<I> event</I> ).<!-- lm: 0x2 1 -->
</UL><B> casted dispatching</B><!-- lm: 0x2 11 -->
<UL> A
form of method dispatching that uses<I> casted method resolution</I>; that
is, it uses a designated ancestor class of the actual<I> target object's
</I>class to determine what procedure to call to execute a specified method.
<!-- lm: 0x2 1 -->
</UL><B>casted method resolution</B><!-- lm: 0x2 11 -->
<UL> A
<I>method resolution</I> technique that uses a<I> method procedure</I> from
the<I> method table</I> of an ancestor of the<I> class</I> of an<I> object
</I>(rather than using a procedure from the method table of the object's
own class).<!-- lm: 0x2 1 -->
</UL><B> child class</B><!-- lm: 0x2 11 -->
<UL> A
class that inherits<I> instance methods, attributes,</I> and<I> instance
variables</I> directly from another class, called the<I> parent class, base
class</I>, or<I> superclass,</I> or indirectly from an<I> ancestor class.
</I>A child class may also be called a<I> derived class</I> or<I> subclass.
</I><!-- lm: 0x2 1 -->
</UL><B>class</B><!-- lm: 0x2 11 -->
<UL> A way of
categorizing<I> objects</I> based on their behavior (the<I> methods</I> they
support) and shape (memory layout). A class is a definition of a generic
object. In SOM, a class is also a special kind of object that can manufacture
other objects that all have a common shape and exhibit similar behavior.
The specification of what comprises the shape and behavior of a set of objects
is referred to as the "definition" of a class. New classes are defined in
terms of existing classes through a technique known as<I> inheritance</I>.
See also<I> class object.</I><!-- lm: 0x2 1 -->
</UL><B> class variable
</B><!-- lm: 0x2 11 -->
<UL><I>Instance data</I> of a<I> class object</I>.
All instance data of an<I> object</I> is defined (through either introduction
or<I> inheritance</I>) by the object's class. Thus, class variables are
defined by<I> metaclasses</I>.<!-- lm: 0x2 1 -->
</UL><B> class data structure
</B><!-- lm: 0x2 11 -->
<UL>A structure provided by the SOM API to support
efficient static access to<I> class</I>-specific information used in dealing
with SOM<I> objects</I>. The structure's name is &lt;<I>className</I>&gt;ClassData.
Its first component (classObject) is a pointer to the corresponding<I> class
object</I>. The remaining components (named after the<I> instance methods
</I>and<I> instance variables</I>) are<I> method tokens</I> or<I> data tokens</I>,
in order as specified by the class's implementation. Data tokens are only
used to support data (public and private) introduced by classes declared
using<I> OIDL</I>; IDL<I> attributes</I> are supported with method tokens.
<!-- lm: 0x2 1 -->
</UL><B>class manager</B><!-- lm: 0x2 11 -->
<UL> An
<I>object</I> that acts as a run-time registry for all SOM<I> class objects
</I>that exist within the current process and which assists in the dynamic
loading and unloading of class libraries. A class implementor can define
a customized class manager by subclassing<I> SOMClassMgr</I> class to replace
the SOM-supplied SOMClassMgrObject. This is done to augment the functionality
of the default class-management registry (for example, to coordinate the
automatic quiescing and unloading of classes).<!-- lm: 0x2 1 -->
</UL><B> class
method</B><!-- lm: 0x2 11 -->
<UL> (Also known as<I> factory method</I> or
<I>constructor</I>.) A class method is a<I> method</I> that a<I> class object
</I>responds to (as opposed to an<I> instance method</I>). A class method
that class &lt;X&gt; responds to is provided by the<I> metaclass</I> of
class &lt;X&gt;. Class methods are executed without requiring any<I> instances
</I>of class &lt;X&gt; to exist, and are frequently used to create instances
of the class.<!-- lm: 0x2 1 -->
</UL><B> class object</B><!-- lm: 0x2 11 -->
<UL> The
run-time<I> object</I> representing a SOM<I> class.</I> In SOM, a class
object can perform the<!-- entering slot 434 --> same behavior common to
all<I> objects</I>, inherited from<I> SOMObject</I>.<!-- lm: 0x2 1 -->
</UL><B> client
code</B><!-- lm: 0x2 11 -->
<UL> (Or<I> client program</I> or<I> client</I>.)
An application program, written in the programmer's preferred language,
which invokes<I> methods</I> on<I> o  bjects</I> that are<I> instances</I> of
SOM<I> classes</I>. In DSOM, this could be a program that invokes a method
on a remote object.<!-- lm: 0x2 1 -->
</UL><B> constructor</B><!-- lm: 0x2 11 -->
<UL> See
<I>class method</I>.<!-- lm: 0x2 1 -->
</UL><B> context expression</B><!-- lm: 0x2 11 -->
<UL> An
optional expression in a method's IDL declaration, specifying identifiers
whose value (if any) can be used during SOM's<I> method resolution</I>  process
and/or by the<I> target object</I> as it executes the<I> method procedure</I>.
If a context expression is specified, then a related Context parameter is
required when the method is invoked. (This Context parameter is an<I> implicit
parameter</I> in the IDL specification of the method, but it is an explicit
parameter of the method's procedure.) No SOM-supplied methods require context
parameters.<!-- lm: 0x2 1 -->
</UL><B> CORBA</B><!-- lm: 0x2 11 -->
<UL> The
Common Object Request Broker Architecture established by the Object Management
Group. IBM's<I> Interface Definition Language</I> used to describe the<I> interface
</I>for SOM classes is fully compliant with CORBA standards.<!-- lm: 0x2 1 -->
</UL><B> daemon
</B><!-- lm: 0x2 11 -->
<UL>See<I> DSOM daemon</I>.<!-- lm: 0x2 1 -->
</UL><B> data
token</B><!-- lm: 0x2 11 -->
<UL> A value that identifies a specific<I> instance
variable</I> within an<I> object</I> whose<I> class</I><I> inherits</I> the
instance variable (as a result of being derived, directly or indirectly,
from the class that introduces the instance variable). An object and a data
token are passed to the SOM run-time procedure, somDataResolve, which returns
is a pointer to the specific instance variable corresponding to the data
token. (See also<I> instance token.</I>)<!-- lm: 0x2 1 -->
</UL><B> derived
class</B><!-- lm: 0x2 11 -->
<UL> See<I> subclass</I> and<I> subclassing.
</I><!-- lm: 0x2 1 -->
</UL><B>derived metaclass</B><!-- lm: 0x2 11 -->
<UL> (Or
<I>SOM-derived metaclass</I>.) A<I> metaclass</I>  that SOM creates automatically
(often even when the<I> class</I> implementor specifies an explicit metaclass)
as needed to ensure that, for any code that executes without<I> method-resolution
</I>error on an<I> instance</I> of a given class, the code will similarly
execute without method-resolution error on instances of any<I> subclass
</I>of the given class. SOM's ability to derive such metaclasses is a fundamental
necessity in order to ensure binary compatibility for client programs despite
any subsequent changes in class<I> implementations</I>.<!-- lm: 0x2 1 -->
</UL><B> descriptor
</B><!-- lm: 0x2 11 -->
<UL>(Or<I> method descriptor</I>.) An ID representing
the identifier of a<I> method</I> definition or an<I> attribute</I> definition
in the Interface Repository. The IR definition contains information about
the method's return type and the type of its arguments.<!-- lm: 0x2 1 -->
</UL><B> directive
</B><!-- lm: 0x2 11 -->
<UL>A message (a pre-defined character constant)
received by a<I> replica</I> from the Replication Framework. Indicates a
potential failure situation.<!-- lm: 0x2 1 -->
</UL><B> dirty object</B><!-- lm: 0x2 11 -->
<UL> A
persistent<I> object</I> that has been modified since it was last written
to persistent storage.<!-- lm: 0x2 1 -->
</UL><B> dispatch-function resolution
</B><!-- lm: 0x2 11 -->
<UL>Dispatch-function resolution is the slowest,
but most flexible, of the three<I> method-resolution</I> techniques SOM
offers. Dispatch functions permit method resolution to be based on arbitrary
rules associated with an<I> object'</I>s<I> class</I>. Thus, a class implementor
has complete freedom in determining how methods invoked on its<I> instances
</I>are resolved. See also<I> dispatch method</I> and<I> dynamic dispatching.
</I><!-- lm: 0x2 1 -->
</UL><B>dispatch method</B><!-- lm: 0x2 11 -->
<UL> A
<I>method</I> (such as somDispatch or somClassDispatch) that is invoked
(and passed an argument list and the ID of another method) in order to determine
the appropriate<I> method procedure</I> to execute. The use of dispatch
methods facilitates<I> dispatch-function resolution</I> in SOM applications
and enables method<!-- entering slot 435 --> invocation on remote objects
in DSOM applications. See also<I> dynamic dispatching</I>.<!-- lm: 0x2 1 -->
</UL><B> DLL
</B><!-- lm: 0x2 11 -->
<UL>Abbreviation for<I> dynamic link library</I>.
<!-- lm: 0x2 1 -->
</UL><B>DSOM daemon (somdd)</B><!-- lm: 0x2 11 -->
<UL> The
DSOM process (somdd) that locates and activates servers. The daemon (actually
known as the<I> location services daemon</I>) is primarily meant to provide
a client with the necessary communications information to allow the client
to connect with an implementation server.<!-- lm: 0x2 1 -->
</UL><B> dynamic
dispatching</B><!-- lm: 0x2 11 -->
<UL> Method dispatching using<I> dispatch-function
resolution</I>; the use of dynamic<I> method resolution</I> at run time.
See also<I> dispatch- function resolution</I> and<I> dynamic method.</I><!-- lm: 0x2 1 -->
</UL><B> Dynamic
Invocation Interface (DII)</B><!-- lm: 0x2 11 -->
<UL> The<I> CORBA</I>-specified
<I>interface</I>, implemented in DSOM, that is used to dynamically build
requests on remote<I> objects</I>. Note that DSOM applications can also
use the somDispatch method for<I> dynamic method</I> calls when the object
is remote. See also<I> dispatch method.</I><!-- lm: 0x2 1 -->
</UL><B> dynamic
link library</B><!-- lm: 0x2 11 -->
<UL> A piece of code that can be loaded
(activated) dynamically. This code is physically separate from its callers.
DLLs can be loaded at load time or at run time. Widely used term on OS/2,
Windows, and, to some extent, AIX.<!-- lm: 0x2 1 -->
</UL><B> dynamic method
</B><!-- lm: 0x2 11 -->
<UL>A method that is not declared in the IDL<I> interface
statement</I> for a<I> class</I> of<I> objects</I>, but is added to the
<I>interface</I> at run time, after which<I> instances</I> of the class
(or of its<I> subclasses</I>) will respond to the registered dynamic method.
Because dynamic methods are not declared,<I> usage bindings</I> for SOM
classes cannot support their use; thus,<I> offset method resolution</I> is
not available. Instead,<I> name-lookup</I> or<I> dispatch-function method
resolution</I> must be used to invoke dynamic methods. (There are currently
no known uses of dynamic methods by any SOM applications.) See also<I> method
</I>and<I> static method.</I><!-- lm: 0x2 1 -->
</UL><B> encapsulation</B><!-- lm: 0x2 11 -->
<UL> An
object-oriented programming feature whereby the implementation details of
a class are hidden from client programs, which are only required to know
the<I> interface</I> of a<I> class</I> (the signatures of its<I> methods
</I>and the names of its<I> attributes</I>) in order to use the class's
methods and attributes.<!-- lm: 0x2 1 -->
</UL><B> encoder/decoder</B><!-- lm: 0x2 11 -->
<UL> In
the Persistence Framework, a<I> class</I> that knows how to read/write the
persistent object format of a<I> persistent object</I>. Every persistent
object is associated with an Encoder/Decoder, and an encoder/decoder object
is created for each<I> attribute</I> and<I> instance variable</I>. An Encoder/Decoder
is supplied by the Persistence Framework by default, or an application can
define its own.<!-- lm: 0x2 1 -->
</UL><B> entry class</B><!-- lm: 0x2 11 -->
<UL> In
the Emitter Framework, a<I> class</I> that represents some syntactic unit
of an<I> interface</I> definition in the<I> IDL source file.</I><!-- lm: 0x2 1 -->
</UL><B> Environment
parameter</B><!-- lm: 0x2 11 -->
<UL> A<I> CORBA</I>-required parameter
in all<I> method procedures</I>, it represents a memory location where exception
information can be returned by the<I> object</I> of a method invocation.
[Certain methods are exempt (when the class contains a modifier of callstyle=oidl),
to maintain upward compatibility for client programs written using an earlier
release.]<!-- lm: 0x2 1 -->
</UL><B> emitter</B><!-- lm: 0x2 11 -->
<UL> Generically,
a program that takes the output from one system and converts the information
into a different form. Using the Emitter Framework, selected output from
the<I> SOM Compiler</I> (describing each syntactic unit in an<I> IDL source
file</I>) is transformed and formatted according to a user-defined template.
Example emitter output, besides the implementation template and language
bindings, might<!-- entering slot 436 --> include reference documentation,
class browser descriptions, or "pretty" printouts.<!-- lm: 0x2 1 -->
</UL><B> event
</B><!-- lm: 0x2 11 -->
<UL>The occurrence of a condition, or the beginning
or ending of an activity that is of interest to an application. Examples
are elapse of a time interval, sending or receiving of a message, and opening
or closing a file. (See also<I> event manager</I> and<I> callback</I>.)
<!-- lm: 0x2 1 -->
</UL><B>event manager (EMan)</B><!-- lm: 0x2 11 -->
<UL> The
chief component of the Event Management Framework that registers interest
in various<I> events</I> from calling modules and informs them through<I> callbacks
</I>when those events occur.<!-- lm: 0x2 1 -->
</UL><B> factory method</B><!-- lm: 0x2 11 -->
<UL> See
<I>class method</I>.<!-- lm: 0x2 1 -->
</UL><B> ID:</B><!-- lm: 0x2 11 -->
<UL> See
<I>somId.</I><!-- lm: 0x2 1 -->
</UL><B> IDL source file</B><!-- lm: 0x2 11 -->
<UL> A
user-written .idl file, expressed using the syntax of the<I> Interface Definition
Language</I> (IDL), which describes the<I> interface</I> for a particular
<I>class</I> (or classes, for a<I> module</I>). The IDL source file is processed
by the<I> SOM Compiler</I> to generate the<I> binding files</I> specific
to the programming languages of the class implementor and the client application.
(This file may also be called the "IDL file," the "source file," or the
"interface definition file.")<!-- lm: 0x2 1 -->
</UL><B> implementation
</B><!-- lm: 0x2 11 -->
<UL>(Or<I> object implementation</I>.) The specification
of what<I> instance variables</I> implement an<I> object'</I>s<I> state
</I>and what<I> procedures</I> implement its<I> methods</I> (or<I> behaviors</I>).
In DSOM, a remote object's implementation is also characterized by its<I> server
implementation</I> (a program).<!-- lm: 0x2 1 -->
</UL><B> Implementation
Repository</B><!-- lm: 0x2 11 -->
<UL> A database used by DSOM to store
the implementation definitions of DSOM<I> servers</I>.<!-- lm: 0x2 1 -->
</UL><B> implementation
statement</B><!-- lm: 0x2 11 -->
<UL> An optional declaration within the
body of the<I> interface</I>  definition of a<I> class</I> in a SOM<I> IDL
source file,</I> specifying information about how the class will be implemented
(such as, version numbers for the class, overriding of inherited methods,
or type of method resolution to be supported by particular methods). This
statement is a SOM-unique statement; thus, it must be preceded by the term
"#ifdef __SOMIDL__" and followed by "#endif". See also<I> interface declaration.
</I><!-- lm: 0x2 1 -->
</UL><B>implementation template</B><!-- lm: 0x2 11 -->
<UL> A
template file containing<I> stub procedures</I> for<I>  methods</I> that
a<I> class</I> introduces or<I> overrides</I>. The implementation template
is one of the<I> binding files</I> generated by the<I> SOM Compiler</I> when
it processes the<I> IDL source file</I> containing class<I> interface declarations.
</I>The class implementor then customizes the<I> implementation,</I> by
adding language-specific code to the<I> method procedures</I>.<!-- lm: 0x2 1 -->
</UL><B> implicit
method parameter</B><!-- lm: 0x2 11 -->
<UL> A<I> method</I> parameter that
is not included in the IDL<I> interface</I> specification of a method, but
which is a parameter of the<I> method'</I>s<I> procedure</I> and which is
required when the method is invoked from a<I> client program</I>. Implicit
parameters include the required<I> Environment</I> parameter indicating
where exception information can be returned, as well as a<I> Context</I> parameter,
if needed.<!-- lm: 0x2 1 -->
</UL><B> incremental update</B><!-- lm: 0x2 11 -->
<UL> A
revision to an<I> implementation template</I> file that results from reprocessing
of the<I> IDL source file</I> by the<I> SOM Compiler</I>. The updated implementation
file will contain new<I> stub procedures</I>, added comments, and revised
<I>method prototypes</I> reflecting changes made to the<I> method</I> definitions
in the IDL specification. Importantly, these updates do not disturb existing
code that the class implementor has defined for the prior method procedures.
<!-- lm: 0x2 1 -->
</UL><B>inheritance</B><!-- lm: 0x2 11 -->
<UL> The technique
of defining one<I> class</I> (called a<I> subclass, derived class,</I> or
<I>child class</I>) as incremental differences from another class (called
the<I>  parent class, base class, superclass,</I> or<I> ancestor class</I>).
From its parents, the subclass inherits variables and<I> methods</I> for
its<I> instances</I>. The subclass can also provide<!-- entering slot 437 --> additional
<I>instance variables</I> and methods. Furthermore, the subclass can provide
new procedures for implementing inherited methods. The subclass is then
said to<I> override</I> the parent class's methods. An overriding method
procedure can elect to call the parent class's<I> method procedure</I>.
(Such a call is known as a<I> parent method call</I>.)<!-- lm: 0x2 1 -->
</UL><B> inheritance
hierarchy</B><!-- lm: 0x2 11 -->
<UL> The sequential relationship from a
root class to a subclass, through which the subclass inherits<I> instance
methods, attributes,</I> and<I>  instance variables</I> from all of its
ancestors, either directly or indirectly. The root class of all SOM classes
is SOMObject.<!-- lm: 0x2 1 -->
</UL><B> instance</B><!-- lm: 0x2 11 -->
<UL> (Or
<I>object instance</I> or just<I> object</I>.) A specific object, as distinguished
from a<I> class</I> of objects. See also<I> object.</I><!-- lm: 0x2 1 -->
</UL><B> instance
method</B><!-- lm: 0x2 11 -->
<UL> A method valid for an object<I> instance
</I>(as opposed to a<I> class method</I>, which is valid for a<I> class
object</I>). An instance method that an object responds to is defined by
its class or inherited from an ancestor class.<!-- lm: 0x2 1 -->
</UL><B> instance
token</B><!-- lm: 0x2 11 -->
<UL> A<I> data token</I> that identifies the
first<I> instance variable</I> among those introduced by a given<I> class</I>.
The somGetInstanceToken<I> method</I> invoked on a<I> class object</I> returns
that class's instance token.<!-- lm: 0x2 1 -->
</UL><B> instance variables
</B><!-- lm: 0x2 11 -->
<UL>(Or,<I> instance data</I>.) Variables declared
for use within the<I> method procedures</I> of a<I> class</I>. An instance
variable is declared within the body of the<I> implementation statement
</I>in a SOM<I> IDL source file</I>. An instance variable is "private" to
the class and should not be accessed by a client program. (Contrast an instance
variable with an<I> attribute.</I>)<!-- lm: 0x2 1 -->
</UL><B> interface
</B><!-- lm: 0x2 11 -->
<UL>The information that a<I> client</I> must know
to use a<I> class</I>  namely, the names of its<I> attributes</I> and the
signatures of its<I> methods</I> . The interface is described in a formal
language (the<I> Interface Definition Language</I>, IDL) that is independent
of the programming language used to implement the class's methods.<!-- lm: 0x2 1 -->
</UL><B> interface
declaration</B><!-- lm: 0x2 11 -->
<UL> (Or<I> interface statement.</I>)
The statement in the<I> IDL source file</I> that specifies the name of a
new class and the names of its<I> parent class</I>(es). The "body" of the
interface declaration defines the<I> signature</I> of each new<I> method
</I>and any<I> attribute</I>(s) associated with the class. In SOM IDL, the
body may also include an<I> implementation statement</I> (where<I> instance
variables</I> are declared or a<I> modifier</I> is specified, for example
to<I> override</I>a method).<!-- lm: 0x2 1 -->
</UL><B> Interface Definition
Language (IDL)</B><!-- lm: 0x2 11 -->
<UL> The formal language (independent
of any programming language) by which the<I> interface</I> for a<I> class
</I>of<I> objects</I> is defined in a .idl file, which the<I> SOM Compiler
</I>then interprets to create an<I> implementation template</I> file and
<I>binding</I> files. SOM's Interface Definition Language is fully compliant
with standards established by the Object Management Group's Common Object
Request Broker Architecture (<I>CORBA</I>).<!-- lm: 0x2 1 -->
</UL><B> Interface
Repository (IR)</B><!-- lm: 0x2 11 -->
<UL> The database that SOM optionally
creates to provide persistent storage of objects representing the major
elements of<I> interface</I> definitions. Creation and maintenance of the
IR is based on information supplied in the<I> IDL source file.</I>  The
SOM IR Framework supports all interfaces described in the<I> CORBA</I> standard.
<!-- lm: 0x2 1 -->
</UL><B>Interface Repository Framework</B><!-- lm: 0x2 11 -->
<UL> A
set of<I> classes</I> that provide<I> methods</I> whereby executing programs
can access the persistent objects of the<I> Interface Repository</I> to
discover everything known about the programming<I> interfaces</I> of SOM
classes.<!-- lm: 0x2 1 -->
</UL><B> IR</B><!-- lm: 0x2 11 -->
<UL> Abbreviation
for<I> Interface Repository</I>.<!-- lm: 0x2 1 -->
</UL><B> location services
daemon (somdd)</B><!-- lm: 0x2 11 -->
<UL> A process whose primary purpose
is to give DSOM clients the communications information that they need to
connect with an implementation server.<!-- lm: 0x2 1 -->
</UL><B> macro
</B><!-- lm: 0x2 11 -->
<UL>An alias for executing a sequence of hidden
instructions; in SOM, typically the means of executing a command known within
a<I> binding file</I> created by the<I> SOM Compiler</I>.<!-- lm: 0x2 1 -->
</UL><B> metaclass
</B><!-- lm: 0x2 11 -->
<UL>A<I> class</I> whose<I> instances</I> are classes.
In SOM, any class descended from<I> SOMClass</I> is a metaclass. The<I> methods
</I>a class inherits from its metaclass are sometimes called<I> class methods
</I>(in Smalltalk) or<I> factory methods</I> (in Objective-C) or<I> constructors</I>.
See also<I> class method.</I><!-- lm: 0x2 1 -->
</UL><B> metaclass incompatibility
</B><!-- lm: 0x2 11 -->
<UL>A situation where a<I> subclass</I> does not
include all of the<I> class variables</I> or respond to all of the<I> class
methods</I> of its<I> ancestor classes</I>. This situation can easily arise
in<I> OOP</I> systems that allow programmers to explicitly specify<I> metaclasses</I>,
<!-- entering slot 438 -->but is not allowed to occur in SOM. Instead, SOM
automatically prevents this by creating and using<I> derived metaclasses
</I>whenever necessary.<!-- lm: 0x2 1 -->
</UL><B> method</B><!-- lm: 0x2 11 -->
<UL> A
combination of a<I> procedure</I> and a name, such that many different procedures
can be associated with the same name. In object-oriented programming, invoking
a method on an<I> object</I> causes the object to execute a specific<I> method
procedure</I>. The process of determining which method procedure to execute
when a method is invoked on an object is called<I> method resolution</I>.
(The<I> CORBA</I> standard uses the term "operation" for method invocation).
SOM supports two different kinds of methods: static methods and dynamic
methods. See also<I> static method</I> and<I> dynamic method.</I><!-- lm: 0x2 1 -->
</UL><B> method
descriptor</B><!-- lm: 0x2 11 -->
<UL> See<I> descriptor</I>.<!-- lm: 0x2 1 -->
</UL><B> method
ID</B><!-- lm: 0x2 11 -->
<UL> A number representing a zero-terminated string
by which SOM uniquely represents a<I> method</I> name. See also<I> somId.
</I><!-- lm: 0x2 1 -->
</UL><B>method pointer</B><!-- lm: 0x2 11 -->
<UL> A
pointer type that identifies one method procedure on a single class. Method
pointers are not ensured to be persistent among multiple processes.<!-- lm: 0x2 1 -->
</UL><B> method
procedure</B><!-- lm: 0x2 11 -->
<UL> A function or procedure, written in
an arbitrary programming language, that implements a<I> method</I> of a
<I>class</I>. A method procedure is defined by the class implementor within
the<I> implementation template</I> file generated by the<I> SOM Compiler.
</I><!-- lm: 0x2 1 -->
</UL><B>method prototype</B><!-- lm: 0x2 11 -->
<UL> A
<I>method</I> declaration that includes the types of the arguments. Based
on method definitions in an<I> IDL source file</I>, the<I> SOM Compiler
</I>generates method prototypes in the<I> implementation template</I>. A
class implementor uses the method prototype as a basis for writing the corresponding
<I>method procedure</I>code. The method prototype also shows all arguments
and their types that are required to invoke the method from a<I> client
program</I>.<!-- lm: 0x2 1 -->
</UL><B> method resolution</B><!-- lm: 0x2 11 -->
<UL> The
process of selecting a particular<I> method procedure</I>, given a<I> method
</I>name and an object<I> instance</I>. The process results in selecting
the particular function/procedure that implements the abstract method in
a way appropriate for the designated object. SOM supports a variety of method-resolution
mechanisms, including<I> offset method resolution, name-lookup resolution,
</I>and<I> dispatch-function resolution</I>.<!-- lm: 0x2 1 -->
</UL><B> method
table</B><!-- lm: 0x2 11 -->
<UL> A table of pointers to the<I>  method
procedures</I> that implement the<I> methods</I> that an<I> object</I> supports.
See also<I> method token.</I><!-- lm: 0x2 1 -->
</UL><B> method token</B><!-- lm: 0x2 11 -->
<UL> A
value that identifies a specific<I> method</I> introduced by a<I> class</I>.
A method token is used during<I> method resolution</I> to locate the<I> method
procedure</I> that implements the identified method. The two basic method-resolution
procedures are somResolve (which takes as arguments an<I> object</I> and
a method token, and returns a pointer to a procedure that implements the
identified method on the given object) and somClassResolve (which takes
as arguments a<I> class</I> and a method token, and returns a pointer to
a procedure that implements the identified method on an instance of the
given class).<!-- lm: 0x2 1 -->
</UL><B> modifier</B><!-- lm: 0x2 11 -->
<UL> Any
of a set of statements that control how a<I> class</I>, an<I> attribute</I>,
or a<I> method</I> will be implemented. Modifiers can be defined in the
<I>implementation statement</I> of a SOM<I> IDL source file</I>. The implementation
statement is a SOM-unique extension of the<I> CORBA</I> specification. [User-defined
modifiers can also be specified for use by user-written emitters or to store
information in the<I> Interface Repository</I>, which can then be accessed
via methods provided by the<I> Interface Repository Framework</I>.]<!-- lm: 0x2 1 -->
</UL><B> module
</B><!-- lm: 0x2 11 -->
<UL>The organizational structure required within
an<I> IDL source file</I> that contains<I> interface declarations</I> for
two (or more) classes that are not a class-metaclass pair. Such<I> interfaces
</I>must be grouped within a module declaration.<!-- lm: 0x2 1 -->
</UL><B> multiple
inheritance</B><!-- lm: 0x2 11 -->
<UL> The situation in which a<I> class
</I>is derived from (and inherits<I> interface</I> and<I> implementation
</I>from) multiple parent classes.<!-- lm: 0x2 1 -->
</UL><B> name-lookup
method resolution</B><!-- lm: 0x2 11 -->
<UL> Similar to the<I> method resolution
</I>techniques employed by Objective-C and Smalltalk. It is significantly
slower than<I> offset resolution</I>. Name-lookup resolution, unlike offset
resolution, can be used when the name of the method to be invoked is not
known until run time, or the method is added to the class interface at run
time, or the name of the class introducing the method is not known until
run time.<!-- lm: 0x2 1 -->
</UL><B> naming scope:</B><!-- lm: 0x2 11 -->
<UL> See
<I>scope</I>.<!-- lm: 0x2 1 -->
</UL><B> object</B><!-- lm: 0x2 11 -->
<UL> (Or
<I>object instance</I>  or just<I> instance</I>.) An entity that has<I><!-- entering slot 439 --> state
</I>(its data values) and<I> behavior</I> (its<I> methods</I>)<I>.</I> An
object is one of the elements of data and function that programs create,
manipulate, pass as arguments, and so forth. An object is a way to encapsulate
state and behavior.<I> Encapsulation</I> permits many aspects of the<I> implementation
</I>of an object to change without affecting client programs that depend
on the object's behavior. In SOM, objects are created by other objects called
<I>classes</I>.<!-- lm: 0x2 1 -->
</UL><B> object adapter (OA)</B><!-- lm: 0x2 11 -->
<UL> A
<I>CORBA</I><I></I> term denoting the primary interface a<I> server implementation
</I>uses to access<I> ORB</I> functions; in particular, it defines the mechanisms
that a server uses to interact with DSOM, and vice versa. This includes
server activation/deactivation, dispatching of<I> methods</I>, and authentication
of the<I> principal</I> making a call. The basic object adapter described
by CORBA is defined by the<I> BOA (basic object adapter) abstract class</I>;
DSOM's primary object adapter implementation is provided by the<I> SOMOA
</I>(<I>SOM Object Adapter</I>)<I> class</I>.<!-- lm: 0x2 1 -->
</UL><B> object
definition</B><!-- lm: 0x2 11 -->
<UL> See<I> class</I>.<!-- lm: 0x2 1 -->
</UL><B> object
implementation</B><!-- lm: 0x2 11 -->
<UL> See<I> implementation.</I><!-- lm: 0x2 1 -->
</UL><B> object
instance</B><!-- lm: 0x2 11 -->
<UL> See<I> instance</I> and<I> object</I>.
<!-- lm: 0x2 1 -->
</UL><B>object reference</B><!-- lm: 0x2 11 -->
<UL> A
<I>CORBA</I> term denoting the information needed to reliably identify a
particular<I> object</I>. This concept is implemented in DSOM with a<I> proxy
object</I> in a<I> client</I> process, or a<I> SOMDObject</I> in a<I> server
</I>process. See also<I> proxy object</I> and<I> SOMDObject.</I><!-- lm: 0x2 1 -->
</UL><B> object
request broker (ORB)</B><!-- lm: 0x2 11 -->
<UL> See<I> ORB</I>.<!-- lm: 0x2 1 -->
</UL><B> offset
method resolution:</B><!-- lm: 0x2 11 -->
<UL> The default mechanism for
performing<I> method resolution</I> in SOM, because it is the fastest (nearly
as fast as an ordinary procedure call). It is roughly equivalent to the
C ++ "virtual function" concept.  Using offset method resolution requires
that the name of the<I> method</I> to be invoked must be known at compile
time, the name of the<I> class</I> that introduces the method must be known
at compile time (although not necessarily by the programmer), and the method
to be invoked must be a<I> static method</I>.<!-- lm: 0x2 1 -->
</UL><B> OIDL
</B><!-- lm: 0x2 11 -->
<UL>The original language used for declaring SOM
<I>classes</I>. The acronym stands for Object Interface Definition Language.
OIDL is still supported by SOM release 2, but it does not include the ability
to specify<I> multiple inheritance</I> classes.<!-- lm: 0x2 1 -->
</UL><B> one-copy
serializable</B><!-- lm: 0x2 11 -->
<UL> The consistency property of the
Replication Framework which states that the concurrent execution of<I> methods
</I>on a<I> replicated object</I> is equivalent to the serial execution
of those same methods on a nonreplicated object.<!-- lm: 0x2 1 -->
</UL><B> OOP
</B><!-- lm: 0x2 11 -->
<UL>An acronym for "object-oriented programming."
<!-- lm: 0x2 1 -->
</UL><B>operation</B><!-- lm: 0x2 11 -->
<UL> See<I> method.
</I><!-- lm: 0x2 1 -->
</UL><B>operation logging</B><!-- lm: 0x2 11 -->
<UL> In
the Replication Framework, a technique for maintaining consistency among
<I>replicas</I> of a replicated object, whereby the execution of a<I> method
</I>that updates the<I> object</I> is repeated at the site of each replica.
<!-- lm: 0x2 1 -->
</UL><B>ORB (object request broker)</B><!-- lm: 0x2 11 -->
<UL> A
<I>CORBA</I> term designating the means by which<I> objects</I> transparently
make requests (that is, invoke<I> methods</I>) and receive responses from
objects, whether they are local or remote. With SOMobjects Developer Toolkit
and Runtimes, this functionality is implemented in the DSOM Framework. Thus,
the DSOM (Distributed SOM) system is an ORB. See also<I> BOA (basic object
adapter) class</I> and<I> SOMOA (SOM object adapter) class.</I><!-- lm: 0x2 1 -->
</UL><B> overridden
method</B><!-- lm: 0x2 11 -->
<UL> A method defined by a parent class and
reimplemented (redefined or overridden) in the current class.<!-- lm: 0x2 1 -->
</UL><B> override
</B><!-- lm: 0x2 11 -->
<UL>(Or<I> overriding method.</I>) The technique
by which a<I> class</I> replaces (redefines) the<I> implementation</I> of
a<I> method</I> that it inherits from one of its<I> parent classes</I>.
An overriding method can elect to call the parent class's<I> method procedure
</I>as part of its own implementation. (Such a call is known as a<I> parent
method call</I>.)<!-- lm: 0x2 1 -->
</UL><B> parent class</B><!-- lm: 0x2 11 -->
<UL> A
<I>class</I> from which<!-- entering slot 440 --> another class inherits
<I>instance methods</I>,<I> attributes</I>, and<I> instance variables</I>.
A parent class is sometimes called a<I> base class</I> or<I> superclass</I>.
<!-- lm: 0x2 1 -->
</UL><B>parent method call</B><!-- lm: 0x2 11 -->
<UL> A
technique where an<I> overriding method</I> calls the<I> method procedure
</I>of its<I> parent class</I> as part of its own<I> implementation</I>.
<!-- lm: 0x2 1 -->
</UL><B>persistent object</B><!-- lm: 0x2 11 -->
<UL> An
<I>object</I> whose<I> state</I> can be preserved beyond the termination
of the<I> process</I> that created it. Typically, such objects are stored
in files.<!-- lm: 0x2 1 -->
</UL><B> polymorphism</B><!-- lm: 0x2 11 -->
<UL> An
object-oriented programming feature that may take on different meanings
in different systems. Under various definitions of polymorphism, (a) a<I> method
</I>or<I> procedure</I> call can be executed using arguments of a variety
of types, or (b) the same variable can assume values of different types
at different times, or (c) a method name can denote more than one<I> method
procedure.</I>  The SOM system reflects the third definition (for example,
when a SOM class<I> overrides</I> a<I> parent class</I> definition of a
method to change its behavior). The term literally means "having many forms."
<!-- lm: 0x2 1 -->
</UL><B>principal</B><!-- lm: 0x2 11 -->
<UL> The user
on whose behalf a particular (remote)<I> method</I> call is being performed.
<!-- lm: 0x2 1 -->
</UL><B>procedure</B><!-- lm: 0x2 11 -->
<UL> A small
section of code that executes a limited, well-understood task when called
from another program. In SOM, a<I> method procedure</I> is often referred
to as a procedure. See also<I> method procedure.</I><!-- lm: 0x2 1 -->
</UL><B> process
</B><!-- lm: 0x2 11 -->
<UL>A series of instructions (a program or part
of a program) that a computer executes in a multitasking environment.<!-- lm: 0x2 1 -->
</UL><B> proxy
object</B><!-- lm: 0x2 11 -->
<UL> In DSOM, a SOM<I> object</I> in the<I> client</I>'s
address space that represents a remote<I> object.</I> The proxy object has
the same<I> interface</I>  as the remote object, but each<I> method</I> invoked
on the proxy is<I> overridden</I> by a<I> dispatch method</I> that forwards
the invocation request to the remote object. Under DSOM, a proxy object
is created dynamically and automatically in the client whenever a remote
method returns a pointer to an object that happens to be remote.<!-- lm: 0x2 1 -->
</UL><B> readers
and writers</B><!-- lm: 0x2 11 -->
<UL> In the Replication Framework, different
processes can access the same replicated object in different modes. A "reader"
is a process that does not intend to update the object, but wants to continually
watch the object as other processes update it. A "writer" is a process that
wants to update the object, as well as continually watch the updates performed
by others.<!-- lm: 0x2 1 -->
</UL><B> receiver</B><!-- lm: 0x2 11 -->
<UL> See
<I>target object.</I><!-- lm: 0x2 1 -->
</UL><B> redispatch stub</B><!-- lm: 0x2 11 -->
<UL> A
<I>procedure</I>, corresponding to a particular<I> method</I>, which has
the same<I> signature</I> as the method's procedure but which invokes somDispatch
to dispatch the method. The somOverrideMtab method can be used to replace
the procedure pointers in a<I> class</I>'s<I> method table</I> with the
corresponding redispatch stubs. This is done when<I> overriding</I> somDispatch
to customize<I> method resolution</I> so that all<I> static method</I> invocations
will be routed through somDispatch for selection of an appropriate<I> method
procedure</I>. (<I>Dynamic methods</I> have no entries in the method table,
so they cannot be supported with redispatch functionality.)<!-- lm: 0x2 1 -->
</UL><B> reference
data</B><!-- lm: 0x2 11 -->
<UL> Application-specific data that a<I> server
</I>uses to identify or describe an<I> object</I> in DSOM. The data, represented
by a sequence of up to 1024 bytes, is registered with DSOM when a server
creates an<I> object reference</I>. A server can later ask DSOM to return
the reference data associated with an object reference. See also<I> object
reference.</I><!-- lm: 0x2 1 -->
</UL><B> replica</B><!-- lm: 0x2 11 -->
<UL> When
an object is replicated among a set of processes (using the Replication
Framework), each process is said to have a replica of the object. From the
view point of<!-- entering slot 441 --> any application model, the replicas
together represent a single object.<!-- lm: 0x2 1 -->
</UL><B> replicated
object</B><!-- lm: 0x2 11 -->
<UL> An<I> object</I> for which<I> replicas
</I>(copies) exist.  See<I> replica.</I><!-- lm: 0x2 1 -->
</UL><B> run-time
environment</B><!-- lm: 0x2 11 -->
<UL> The data structures, objects, and
global variables that are created, maintained, and used by the functions,
procedures, and methods in the SOM run-time library.<!-- lm: 0x2 1 -->
</UL><B> scope
</B><!-- lm: 0x2 11 -->
<UL>(Or<I> naming scope.</I>) That portion of a
program within which an identifier name has "visibility" and denotes a unique
variable. In SOM, an<I> IDL source file</I> forms a scope. An identifier
can only be defined once within a scope; identifiers can be redefined within
a nested scope. In a .idl file, modules, interface statements, structures,
unions, methods, and exceptions form nested scopes.<!-- lm: 0x2 1 -->
</UL><B> serializable
</B><!-- lm: 0x2 11 -->
<UL>See<I> one-copy serializable</I>.<!-- lm: 0x2 1 -->
</UL><B> server
</B><!-- lm: 0x2 11 -->
<UL>(Or<I> server implementation.</I>) In DSOM,
a<I> process</I>, running in a distributed environment, that executes the
<I>implementation</I> of an<I>  object</I>. DSOM provides a default server
implementation that can dynamically load SOM<I> class</I> libraries, create
SOM objects, and make those objects accessible to<I> clients</I>. Developers
can also write application-specific servers for use with DSOM.<!-- lm: 0x2 1 -->
</UL><B> server
object</B><!-- lm: 0x2 11 -->
<UL> In DSOM, every<I> server</I> has an<I> object
</I>that defines<I> methods</I> for managing objects in that server. These
methods include object creation, object destruction, and maintaining mappings
between<I> object references</I> and the objects they reference. A server
object must be an<I> instance</I> of the<I> class</I> SOMDServer (or one
of its<I> subclasses</I>). See also<I> object reference</I> and<I> SOMDObject.
</I><!-- lm: 0x2 1 -->
</UL><B>shadowing</B><!-- lm: 0x2 11 -->
<UL> In
the Emitter Framework, a technique that is required when any of the<I> entry
classes</I> are subclassed. Shadowing causes instances of the new subclass(es)
(rather than instances of the original entry classes) to be used as input
for building the object graph, without requiring a recompile of emitter
framework code. Shadowing is accomplished by using the macro SOM_SubstituteClass.
<!-- lm: 0x2 1 -->
</UL><B>signature</B><!-- lm: 0x2 11 -->
<UL> The collection
of types associated with a<I> method</I> (the type of its return value,
if any, as well as the number, order, and type of each of its arguments).
<!-- lm: 0x2 1 -->
</UL><B>sister class object</B><!-- lm: 0x2 11 -->
<UL> A
duplicate of a<I> class object</I> that is created in order to save a copy
of the class's original<I> method table</I> before replacing the method
table to customize<I> method resolution.</I> The sister class object is
created so that some original<I> method procedures</I> can be called by
the replacement method procedures.<!-- lm: 0x2 1 -->
</UL><B> Sockets class
</B><!-- lm: 0x2 11 -->
<UL>A class that provides a common communications
interface to Distributed SOM, the Replication Framework, and the Event Management
Framework. The Sockets class provides the base interfaces (patterned after
TCP/IP sockets); the<I> subclasses</I> TCPIPSockets, NBSockets, and IPXSockets
provide actual implementations for TCP/IP, Netbios, and Netware IPX/SPX,
respectively.<!-- lm: 0x2 1 -->
</UL><B> SOM Compiler</B><!-- lm: 0x2 11 -->
<UL> A
tool provided by the SOM Toolkit that takes as input the interface definition
file for a class (the .idl file) and produces a set of<I> binding files
</I>that make it more convenient to implement and use SOM classes.<!-- lm: 0x2 1 -->
</UL><B> SOMClass
</B><!-- lm: 0x2 11 -->
<UL>One of the three primitive<I> class objects
</I>of the SOM run-time environment. SOMClass is the root (meta)class from
which all subsequent<I><!-- entering slot 442 --> metaclasses</I> are derived.
SOMClass defines the essential<I> behavior</I> common to all SOM<I> class
objects.</I><!-- lm: 0x2 1 -->
</UL><B> SOMClassMgr</B><!-- lm: 0x2 11 -->
<UL> One
of the three primitive<I> class objects</I> of the SOM run-time environment.
During SOM initialization, a single<I> instance</I> (<I>object</I>) of SOMClassMgr
is created, called SOMClassMgrObject. This object maintains a directory
of all SOM classes that exist within the current process, and it assists
with dynamic loading and unloading of class libraries.<!-- lm: 0x2 1 -->
</UL><B> SOM-derived
metaclass:</B><!-- lm: 0x2 11 -->
<UL> See<I> derived metaclass.</I><!-- lm: 0x2 1 -->
</UL><B> SOMDObject
</B><!-- lm: 0x2 11 -->
<UL>The<I> class</I> that implements the notion
of a<I> CORBA</I><I> "object reference</I>" in DSOM. An<I> instance</I> of
SOMDObject contains information about an object's<I> server implementation
</I>and<I> interface,</I> as well as a user-supplied identifier.<!-- lm: 0x2 1 -->
</UL><B> somId
</B><!-- lm: 0x2 11 -->
<UL>A pointer to a number that uniquely represents
a zero-terminated string. Such pointers are declared as type somId. In SOM,
somId's are used to represent<I> method</I> names,<I> class</I> names, and
so forth.<!-- lm: 0x2 1 -->
</UL><B> SOMObject</B><!-- lm: 0x2 11 -->
<UL> One
of the three primitive<I> class objects</I> of the SOM run-time environment.
SOMObject is the root class for all SOM (sub)classes. SOMObject defines
the essential<I> behavior</I> common to all SOM<I> objects.</I><!-- lm: 0x2 1 -->
</UL><B> SOMOA
(SOM object adapter) class</B><!-- lm: 0x2 11 -->
<UL> In DSOM, a<I> class
</I>that dispatches<I> methods</I> on a<I> server</I>'s<I> objects</I>,
using the<I> SOM Compiler</I> and run-time support. The SOMOA class implements
methods defined in the<I> abstract</I> BOA class (its<I> base class</I>).
See also<I> BOA class.</I><!-- lm: 0x2 1 -->
</UL><B> somSelf</B><!-- lm: 0x2 11 -->
<UL> Within
<I>method procedures</I>  in the<I> implementation</I> file for a class,
a parameter pointing to the<I> target object</I> that is an<I> instance
</I>of the<I> class</I> being implemented.  it is local to the<I> method
procedure</I>.<!-- lm: 0x2 1 -->
</UL><B> somThis</B><!-- lm: 0x2 11 -->
<UL> Within
<I>method procedures,</I> a local variable that points to a data structure
containing the<I> instance variables</I> introduced by the<I> class</I>.
If no instance variables are specified in the SOM<I> IDL source file</I>,
then the somThis assignment statement is commented out by the<I> SOM Compiler</I>.
<!-- lm: 0x2 1 -->
</UL><B>state (of an object)</B><!-- lm: 0x2 11 -->
<UL> The
data (<I>attributes, instance variables</I> and their values) associated
with an<I> object.</I> See also<I> behavior.</I><!-- lm: 0x2 1 -->
</UL><B> static
method</B><!-- lm: 0x2 11 -->
<UL> Any<I> method</I> that can be accessed
through<I> offset method resolution</I>.  Any method declared in the IDL
specification of a class is a static method. See also<I> method</I> and
<I>dynamic method.</I><!-- lm: 0x2 1 -->
</UL><B> stub procedures</B><!-- lm: 0x2 11 -->
<UL><I> Method
procedures</I> in the<I> implementation template</I> generated by the<I> SOM
Compiler</I>. They are procedures whose bodies are largely vacuous, to be
filled in by the implementor.<!-- lm: 0x2 1 -->
</UL><B> subclass</B><!-- lm: 0x2 11 -->
<UL> A
<I>class</I> that inherits<I> instance methods</I>,<I> attributes</I>, and
<I>instance variables</I> directly from another class, called the<I> parent
class, base class</I>,<I> superclass,</I> or indirectly from an<I> ancestor
class</I>. A subclass may also be called a<I> child class</I> or<I> derived
class.</I><!-- lm: 0x2 1 -->
</UL><B> subclassing</B><!-- lm: 0x2 11 -->
<UL> The
process whereby a new<I> class</I>, as it is created (or<I> derived</I>),
inherits<I> instance methods, attributes,</I> and<I> instance variables
</I>from one or more previously defined<I> ancestor classes</I>. The immediate
<I>parent class(es)</I> of a new class must be specified in the class's
<I>interface declaration.</I> see also<I> inheritance.</I><!-- lm: 0x2 1 -->
</UL><B> superclass
</B><!-- lm: 0x2 11 -->
<UL>See<I> parent class.</I><!-- lm: 0x2 1 -->
</UL><B> symbol
</B><!-- lm: 0x2 11 -->
<UL>In the Emitter Framework, any of a (standard
or user-defined) set of names (such as, className) that are used as placeholders
when building a text template to pattern the desired<I> emitter</I> output.
When a template is emitted, the symbols are replaced with their corresponding
values from the emitter's symbol table. Other symbols (such as, classSN)
have values that are used by section-emitting methods to identify major
sections of the template (which are correspondingly labeled as "classS"
or by a user-defined name).<!-- lm: 0x2 1 -->
</UL><B> target object</B><!-- lm: 0x2 11 -->
<UL> (Or
<I>receiver.</I>) The object responding to a<I> method</I> call. The target
object is always the first formal parameter of a<I> method procedure</I>.
For SOM's C-language bindings, the target object is the first argument<!-- entering slot 443 --> provided
to the method invocation macro, _<I>methodName</I>.<!-- lm: 0x2 1 -->
</UL><B> usage
bindings</B><!-- lm: 0x2 11 -->
<UL> The language-specific<I> binding</I> files
for a<I> class</I> that are generated by the<I> SOM Compiler</I> for inclusion
in client programs using the class.<!-- lm: 0x2 1 -->
</UL><B> value logging
</B><!-- lm: 0x2 11 -->
<UL>In the Replication Framework, a technique for
maintaining consistency among<I> replicas</I> of a replicated object, whereby
the new value of the object is distributed after the execution of a method
that updates the object.<!-- lm: 0x2 1 -->
</UL><B> view-data paradigm</B><!-- lm: 0x2 11 -->
<UL> A
Replication Framework construct similar to the Model-View-Controller paradigm
in SmallTalk. The "view" object contains only presentation-specific information,
while the "data" object contains the<I> state</I> of the application. The
"view" and "data" are connected by means of an "observation" protocol that
lets the "view" be notified whenever the "data" changes.<!-- lm: 0x2 1 -->
</UL><B> writers
</B><!-- lm: 0x2 11 -->
<UL>See<I> readers and writers.</I><!-- lm: 0x2 1 -->
</UL>

<P><HR>

<A HREF="378_L2_Trademarks.html">[Back: Trademarks]</A> <BR>
<A HREF="380_L0_.html">[Next: ]</A> 
</BODY>
</HTML>
