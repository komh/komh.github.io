<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Basic Concepts of the System Object Model (SOM)</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Basic Concepts of the System Object Model (SOM)</H1><!-- entering slot 19 -->
<P>
The<B> System Object Model (SOM),</B> provided by the<B> SOMobjects Developer
Toolkit</B>, is a set of libraries, utilities, and conventions used to create
binary class libraries that can be used by application programs written
in various object-oriented programming languages, such as C++ and Smalltalk,
or in traditional procedural languages, such as C and Cobol. The following
paragraphs introduce some of the basic terminology used when creating classes
in SOM:<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->An<I> object</I> is an OOP entity that has<I> behavior
</I>(its<I> methods</I> or operations) and<I> state</I> (its data values).
 In SOM, an object is a run-time entity with a specific set of methods and
<I></I>instance variables.  The methods are used by a client programmer
to make the object exhibit behavior (that is, to do something), and the
instance variables are used by the object to store its state.  (The state
of an object can change over time, which allows the object's behavior to
change.)  When a method is invoked on an object, the object is said to be
the<I> receiver</I> or<I> target</I> of the method call.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->An object's<I> implementation</I> is determined by
the procedures that execute its methods, and by the type and layout of its
instance variables.  The procedures and instance variables that implement
an object are normally<I> encapsulated</I>  (hidden from the caller), so
a program can use the object's methods without knowing anything about how
those methods are implemented. Instead, a user is given access to the object's
methods through its<I> interface</I> (a description of the methods in terms
of the data elements required as input and the type of value each method
returns).<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->An interface through which an object may be manipulated
is represented by an<I> object type</I>.  That is, by declaring a type for
an object variable, a programmer specifies the interface that is intended
to be used to access that object. <I> SOM</I><I> IDL</I> (the<B> SOM Interface
Definition Language</B>) is used to define object interfaces.  The<I> interface
names</I> used in these IDL definitions are also the type names used by
programmers when typing SOM object variables.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->In SOM, as in most approaches to object-oriented programming,
a<I> class</I> defines the implementation of objects. That is, the implementation
of any SOM object (as well as its interface) is defined by some specific
SOM class. A class definition begins with an IDL specification of the interface
to its objects, and the name of this interface is used as the class name
as well. Each object of a given class may also be called an<I> instance
</I>of the class, or an<I> instantiation</I> of the class.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 --><I>Inheritance,</I> or<I> class derivation</I>, is
a technique for developing new classes from existing classes. The original
class is called the<I> base</I> class, or the<I> parent</I> class, or sometimes
the direct<I> ancestor</I> class. The derived class is called a<I> child
</I>class or a<I> subclass</I>.  The primary advantage of inheritance is
that a derived class inherits all of its parent's methods and instance variables.
 Also through inheritance, a new class can<I> override</I> (or redefine)
methods of its parent, in order to provide enhanced functionality as needed.
 In addition, a derived class can introduce new methods of its own. If a
class results from several generations of successive class derivation, that
class "knows" all of its ancestors's methods (whether overridden or not),
and an object (or instance) of that class can execute any of those methods.
<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SOM classes can also take advantage of<I> multiple
inheritance,</I> which means that a new class is jointly derived from two
or more parent classes.  In this case, the derived class inherits methods
from all of its parents (and all of its ancestors), giving it greatly expanded
capabilities.  In the event that different parents have methods of the same
name that execute differently, SOM provides ways for avoiding conflicts.
<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->In the SOM run time, classes are themselves objects.
 That is, classes have their own methods and interfaces, and are themselves
defined by other classes. For this reason, a class is often called a<I> class
object</I>.  Likewise, the terms<I> class methods</I> and<I> class variables
</I>are used to<!-- entering slot 20 --> distinguish between the methods/variables
of a class object vs. those of its instances.  (Note that the type of an
object is<I> not</I> the same as the type of its class, which as a "class
object" has its own type.)<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->A class that defines the implementation of class objects
is called a<I> metaclass</I>.  Just as an instance of a class is an object,
so an instance of a metaclass is a class object.  Moreover, just as an ordinary
class defines methods that its objects respond to, so a metaclass defines
methods that a class object responds to.  For example, such methods might
involve operations that execute when a class (that is, a class object) is
creating an instance of itself (an object).  Just as classes are derived
from parent classes, so metaclasses can be derived from parent metaclasses,
in order to define new functionality for class objects.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->The SOM system contains three primitive classes that
are the basis for all subsequent classes:<!-- lm: 0x2 6 -->
<UL>
<P>
<B>SOMObject</B><!-- lm: 0x2 26 -->
<UL> the root ancestor class for all
SOM classes,<!-- lm: 0x2 6 -->
</UL><B> SOMClass</B><!-- lm: 0x2 26 -->
<UL> the
root ancestor class for all SOM metaclasses, and<!-- lm: 0x2 6 -->
</UL><B> SOMClassMgr
</B><!-- lm: 0x2 26 -->
<UL>the class of the SOMClassMgrObject, an object
created automatically during SOM initialization, to maintain a registry
of existing classes and to assist in dynamic class loading/unloading.<!-- lm: 0x2 6 -->
</UL><B> SOMClass
</B>is defined as a subclass (or child) of<B> SOMObject</B> and inherits
all generic object methods; this is why instances of a metaclass are class
<I>objects</I>  (rather than simply classes) in the SOM run time.<!-- lm: 0x2 1 -->
</UL>
<P>
SOM classes are designed to be<I> language neutral</I>. That is, SOM classes
can be implemented in one programming language and used in programs of another
language. To achieve language neutrality, the<I> interface</I> for a class
of objects must be defined separately from its<I> implementation</I>. That
is, defining interface and implementation requires two completely separate
steps (plus an intervening compile), as follows:<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->An<I> interface</I> is the information that a program
must know in order to use an object of a particular class. This interface
is described in an interface definition (which is also the class definition),
using a formal language whose syntax is independent of the programming language
used to implement the class's methods. For SOM classes, this is the SOM
Interface Definition Language (SOM IDL). The interface is defined in a file
known as the<I> IDL source file</I> (or, using its extension, this is often
called the<I> .idl file</I>).
<P>
An interface definition is specified within the<I> interface declaration
</I>(or<I> interface statement</I>) of the .idl file, which includes:<!-- lm: 0x2 6 -->
<UL>
<P>
<LI>a)<!-- lm: 0x2 17 -->
<UL> the interface name (or class name) and the
name(s) of the class's parent(s), and<!-- lm: 0x2 6 -->
</UL> (b)<!-- lm: 0x2 17 -->
<UL> the
names of the class's attributes and the signatures of its new methods. (Recall
that the complete set of available methods also includes all inherited methods.)
<!-- lm: 0x2 6 -->
</UL>Each<I> method signature</I> includes the method
name, and the type and order of its arguments, as well as the type of its
return value (if any). <I> Attributes</I> are instance variables for which
"set" and "get" methods will automatically be defined, for use by the application
program.  (By contrast, instance variables that are not attributes are hidden
from the user.)<!-- lm: 0x2 3 -->
</UL> <!-- lm: 0x2 6 -->
<UL>Once the
IDL source file is complete, the<I> SOM Compiler</I> is used to analyze
the .idl file and create the<I> implementation template file</I>, within
which the class implementation will be defined. Before issuing the SOM Compiler
command,<B> sc</B>, the class implementor can set an environment variable
that determines which<I> emitters</I> (output-generating programs) the SOM
Compiler will call and, consequently, which programming language and operating
system the resulting<I> binding files</I> will relate to. (Alternatively,
this emitter information can be placed on the command line for<B> sc</B>.)
 In addition to the implementation template file itself, the binding files
include two language-specific header files that will be #included in the
implementation template file and in application program files. The header
files define many useful SOM macros, functions, and procedures that can
be invoked from the files that include the header files.<!-- lm: 0x2 3 -->
</UL> <!-- lm: 0x2 6 -->
<UL>The
<I>implementation</I> of a class is done by the class implementor in the
<I>implementation template file</I> (often called just the<I> implementation
file</I> or the<I> template file</I>).  As produced by the SOM Compiler,
the template file contains<I> stub procedures</I>  for<!-- entering slot 21 --> each
method of the class.  These are incomplete method procedures that the class
implementor uses as a basis for implementing the class by writing the corresponding
code in the programming language of choice.<!-- lm: 0x2 1 -->
</UL>
<P>
In summary, the process of<I> implementing a SOM class</I> includes using
the SOM IDL syntax to create an IDL source file that specifies the interface
to a class of objects - that is, the methods and attributes that a program
can use to manipulate an object of that class.  The SOM Compiler is then
run to produce an implementation template file and two binding (header)
files that are specific to the designated programming language and operating
system. Finally, the class implementor writes language-specific code in
the template file to implement the method procedures.
<P>
At this point, the next step is to write the application (or client) program(s)
that use the objects and methods of the newly implemented class. (Observe,
here, that a programmer could write an application program using a class
implemented entirely by someone else.)  If not done previously, the SOM
compiler is run to generate usage bindings for the new class, as appropriate
for the language used by the client program (which may be different from
the language in which the class was implemented). After the client program
is finished, the programmer compiles and links it using a language-specific
compiler, and then executes the program. (Notice again, the client program
can invoke methods on objects of the SOM class without knowing how those
methods are implemented.)
<P>


<P><HR>

<A HREF="015_L1_TutorialforImplement.html">[Back: Tutorial for Implementing SOM Classes]</A> <BR>
<A HREF="017_L3_DevelopmentoftheTuto.html">[Next: Development of the Tutorial examples]</A> 
</BODY>
</HTML>
