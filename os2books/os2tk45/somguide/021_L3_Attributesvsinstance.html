<HTML>
<HEAD>
<TITLE>Attributes vs instance variables</TITLE>
</HEAD>
<BODY>
<H1>Attributes vs instance variables</H1><!-- entering slot 28 -->
<P>
As an alternative to defining "numberObjs" as an attribute, it could be
defined as an instance variable, with a "get_numberObjs" method also defined
for retrieving its value.  Instance variables are declared in an<B> implementation
</B> statement, as shown below:
<PRE>   interface Hello
   {
   <B>string get_msg() ;
   void set_msg(in string msg);</B>

   #ifdef __SOMIDL__
   <B>implementation</B>
   {
       <B>string message;</B>
   };
   #endif
   };
</PRE>

<P>
As demonstrated in this example, one disadvantage to using an instance variable
is that the "get_msg" and "set_msg" methods must be defined in the implementation
file by the class implementor. For attributes, by contrast, default implementations
of the "get" and "set" methods are generated automatically by the SOM Compiler
in the .ih and .xih header files.
<P>
Note: For some attributes (particularly those involving structures, strings,
and pointers) the default implementation generated by the SOM Compiler for
the "set" method may not be suitable. This happens because the SOM Compiler
only performs a "shallow copy," which typically is not useful for distributed
objects with these types of attributes.  In such cases, it is possible to
write your own implementations, as you do for any other method, by specifying
the "noset/noget" modifiers for the attribute. (See the subtopic "Modifier
statements" in Chapter 4 "SOM IDL and the SOM Compiler.")
<P>
Regardless of whether you let the SOM Compiler generate your implementations
or not, if access to instance data is required, either from a subclass or
a client program, then this access should be facilitated by using an attribute.
 Otherwise, instance data can be defined in the "implementation" statement
as above (using the same syntax as used to declare variables in C or C++),
with appropriate methods defined to access it. For more information about
"implementation" statements, see the topic "Implementation statements" in
Chapter 4.
<P>
As an example where instance variables would be used (rather than attributes),
consider a class "Date" that provides a method for returning the current
date. Suppose the date is represented by three instance variables-"mm",
"dd", and "yy". Rather than making "mm", "dd", and "yy" attributes (and
allowing clients to access them directly), "Date" defines "mm", "dd", and
"yy" as instance variables in the "implementation" statement, and defines
a method "get_date" that converts "mm", "dd", and "yy" into a string of
the form "mm/dd/yy":
<PRE>   <B>interface Date
   {
           string get_date() ;</B>

   #ifdef __SOMIDL__
   <B>implementation</B>
   {
       <B>long mm,dd,yy;</B>
   };
   #endif
   };
</PRE>

<P>
To access instance variables that a class introduces from within the class
implementation file, two forms of notation are available:
<P>
<I>somThis-&gt;variableName</I>
<P>
or
<P>
<I>_variableName</I>
<P>
For example, the implementation for "get_date" would
<P>
<!-- lm: 0x2 6 -->
<UL>
<P>
access the "mm" instance variable as somThis-&gt;mm or _mm,<!-- lm: 0x2 6 -->
<BR>
access "dd"  as somThis-&gt;dd or _dd, and<!-- lm: 0x2 6 -->
<BR>
access "yy" as somThis-&gt;yy or _yy.<!-- lm: 0x2 1 -->
</UL>
<P>
In C++ programs, the _<I>variableName</I>  form is available only if the
programmer first defines the macro VARIABLE_MACROS (that is, enter #define
VARIABLE_MACROS) in the implementation file prior to including the .xih
file for the class.

<P><HR>

<A HREF="020_L3_Example2AddinganAttr.html">[Back: Example 2-Adding an Attribute to the Hello class]</A> <BR>
<A HREF="022_L3_Example3Overridingan.html">[Next: Example 3-Overriding an Inherited Method]</A> 
</BODY>
</HTML>
