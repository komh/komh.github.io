<HTML>
<HEAD>
<TITLE>Declaring object variables</TITLE>
</HEAD>
<BODY>
<H1>Declaring object variables</H1><!-- entering slot 37 -->
<P>
When declaring an object variable, an<I> object interface</I> name defined
in IDL is used as the<I> type</I> of the variable. The exact syntax is slightly
different for C vs. C++ programmers. Specifically,<!-- lm: 0x2 1 -->
<UL>
<P>
&lt;<I>interfaceName</I>&gt;  obj ;<!-- lm: 0x2 26 -->
<UL> in C programs
or<!-- lm: 0x2 1 -->
</UL>&lt;<I>interfaceName</I>&gt; *obj ;<!-- lm: 0x2 26 -->
<UL> in C++
programs<!-- lm: 0x2 1 -->
</UL>
<P>
declares "obj" to be a pointer to an object that has type &lt;<I>interfaceName</I>&gt;.
In SOM, objects of this type are instances of the SOM<I> class</I> named
&lt;<I>interfaceName</I>&gt;, or of any SOM class derived from this class.
Thus, for example,<!-- lm: 0x2 1 -->
<P>
Animal obj;<!-- lm: 0x2 26 -->
<UL> in C programs or<!-- lm: 0x2 1 -->
</UL>Animal *obj;<!-- lm: 0x2 26 -->
<UL> in C++ programs<!-- lm: 0x2 1 -->
</UL>
<P>
declares "obj" as pointer to an object of type "Animal" that can be used
to reference an instance of the SOM class "Animal" or any SOM class derived
from "Animal". Note that the type of an object need not be the same as its
class<I>;</I> an object of type "Animal" might not be an instance of the
"Animal" class (rather, it might be an instance of some subclass of "Animal"
- the "Cat" class, perhaps).
<P>
All SOM objects are of type<B> SOMObject</B>, even though they may not be
instances of the<B> SOMObject</B> class. Thus, if it is not known at compile
time what type of object the variable will point to, the following declaration
can be used:<!-- lm: 0x2 1 -->
<P>
SOMObject obj;<!-- lm: 0x2 26 -->
<UL> in C programs or<!-- lm: 0x2 1 -->
</UL>SOMObject *obj;<!-- lm: 0x2 26 -->
<UL> in C++ programs.<!-- lm: 0x2 1 -->
</UL>
<P>
Because the sizes of SOM objects are not known at compile time, instances
of SOM classes must always be dynamically allocated. Thus, a variable declaration
must always define a pointer to an object.
<P>
Note: In the C usage bindings, as within an IDL specification, an interface
name used as a type implicitly indicates a pointer to an object that has
that interface (this is required by the CORBA specification). The C usage
bindings for SOM classes therefore hide the pointer with a C typedef for
<I>&lt;interfaceName&gt;</I>. But this is not appropriate in the C++  usage
bindings, which define a C++ class for<I> &lt;interfaceName&gt;</I>. Thus,
it is not correct in C++ to use a declaration of the form:<!-- lm: 0x2 1 -->
<P>
<I>&lt;interfaceName&gt;</I>  obj ;<!-- lm: 0x2 26 -->
<UL> not valid in
C++ programs<!-- lm: 0x2 1 -->
</UL>
<P>
Note: If a C programmer also prefers to use explicit pointers to &lt;<I>interfaceName</I>&gt;
types, then the SOM Compiler option<B> -maddstar</B> can be used when the
C binding files are generated, and the explicit " *" will then be required
in declarations of object variables. (This option is required for compatibility
with existing SOM OIDL code. For information on using the<B> -maddstar</B> option,
see "Running the SOM Compiler" in Chapter 4, "SOM IDL and the SOM Compiler.")

<P>
Users of other programming languages must also define object variables to
be pointers to the data structure used to represent SOM objects. The way
this is done is programming-language dependent. The header file "somtypes.h"
defines the structure of SOM objects for the C language.

<P><HR>

<A HREF="027_L2_UsingSOMClassestheBa.html">[Back: Using SOM Classes: the Basics]</A> <BR>
<A HREF="029_L3_Creatinginstancesofa.html">[Next: Creating instances of a class]</A> 
</BODY>
</HTML>
