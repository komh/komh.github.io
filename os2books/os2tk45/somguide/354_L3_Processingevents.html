<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Processing events</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Processing events</H1><!-- entering slot 403 -->
<P>
After all registrations are finished, an application typically turns over
control to EMan and is completely event driven thereafter. Typically, an
application main program ends with the following call to EMan:
<PRE>_someProcessEvents(some_gEMan, Ev);
</PRE>

<P>
An equivalent way to process events is to write a main loop and call<B> someProcessEvent
</B>from inside the main loop, as indicated:
<PRE>while (1) { /* do forever */
      _someProcessEvent( some_gEMan, Ev, EMProcessTimerEvent  Æ
                                         EMProcessSinkEvent   Æ
                                         EMProcessClientEvent Æ
                                         EMProcessWorkProcEvent );
      /***  Do other main loop work, as needed. ***/
}
</PRE>

<P>
The second way allows more precise control over what type of events to process
in each call. The example above enables all four types to be processed.
The required subset is formed by logically OR'ing the appropriate bit constants
(these are defined in "eventmsk.h)".  Another difference is that the second
way is a non-blocking call to EMan. That is, if there are no events to process,
control returns to the main loop immediately, whereas<B> someProcessEvents
</B>is a non-returning blocking call. For most applications, the first way
of calling EMan is better, since it does not waste processor cycles when
there are no events to process.

<P><HR>

<A HREF="353_L3_Examplesofusingother.html">[Back: Examples of using other events]</A> <BR>
<A HREF="355_L3_Interactiveapplicati.html">[Next: Interactive applications]</A> 
</BODY>
</HTML>
