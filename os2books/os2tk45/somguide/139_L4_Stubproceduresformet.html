<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Stub procedures for methods</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Stub procedures for methods</H1><!-- entering slot 169 -->
<P>
<U><I>For each method</I></U> introduced or overridden by the class, the
implementation template includes a<I> stub procedure</I>-a procedure that
is empty except for an<I> initialization</I> statement, a<I> debugging</I> statement,
and possibly a<I> return</I> statement. The stub procedure for a method
is preceded by any comments that follow the method's declaration in the
IDL specification.
<P>
For method "sayHello" above, the SOM Compiler generates the following prototype
of the stub procedure:
<PRE>   SOM_Scope void SOMLINK sayHello(Hello somSelf, Environment *ev)
</PRE>

<P>
The "SOM_Scope" symbol is defined in the implementation header file as either
"extern" or "static," as appropriate. The term "void" signifies the return
type of method "sayHello". The "SOMLINK" symbol is defined by SOM; it represents
the keyword needed to link to the C or C++ compiler, and its value is system-specific.
Using the "SOMLINK" symbol allows the code to work with a variety of compilers
without modification.
<P>
Following the "SOMLINK" symbol is the name of the procedure that implements
the method. If no<B> functionprefix</B> modifier has been specified for
the class, then the procedure name is the same as the method name. If a
<B>functionprefix</B> modifier is in effect, then the procedure name is
generated by prepending the specified prefix to the method name. For example,
if the class definition contained the following statement:
<PRE>   functionprefix = xx_;
</PRE>

<P>
then the prototype of the stub procedure for method "sayHello" would be:

<PRE>   SOM_Scope void SOMLINK xx_sayHello(Hello somSelf, Environment *ev)
</PRE>

<P>
The<B> functionprefix</B> can not be
<PRE>   &lt;classname&gt;_
</PRE>

<P>
since this is used in method invocation macros defined by the C usage bindings.

<P>
Following the procedure name is the formal parameter list for the method
procedure. Because each SOM method always receives at least one argument
(a pointer to the SOM object that responds to the method), the first parameter
name in the prototype of each stub procedure is called<B> somSelf</B>. (The
macros defined in the implementation header file rely on this convention.)
The<B> somSelf</B> parameter is a pointer to an object that is an instance
of the class being implemented (here, class "Hello") or an instance of a
class derived from it.
<P>
Unless the IDL specification of the class included the<B> callstyle=oidl
</B>modifier, then the formal parameter list will include one or two additional
parameters before the parameters declared in the IDL specification: an<B> (Environment
*ev)</B> input/output parameter, which permits the return of exception information,
and, if the IDL specification of the method includes a context specification,
a<B> (Context *ctx)</B> input parameter. These parameters are prescribed
by the CORBA standard.  For more information on using the<B> Environment
</B> and<B> Context</B> parameters, see the section entitled "Exceptions
and error handling" in Chapter 3, "Using SOM Classes in Client Programs,"
and the book<I> The Common Object Request Broker: Architecture and Specification</I>,
published by Object Management Group and X/Open.
<P>
The first statement in the stub procedure for method "sayHello" is the statement:

<PRE>   /* HelloData *somThis = HelloGetData(somSelf); */
</PRE>

<P>
This statement is enclosed in comments only when the class does<I> not</I> introduce
any instance variables. The purpose of this statement, for classes that
do introduce instance variables, is to initialize a local variable (<B>somThis</B>)
that points to a<U> structure</U> representing the instance variables introduced
by the class. The<B> somThis</B> pointer is used by the macros defined in
the "Hello" implementation header file to access those instance variables.
(These macros are described below.)  In this example, the "Hello" class
introduces no instance variables, so the statement is commented out. If
instance variables are later added to a class that initially had none, then
the comment characters can be<!-- entering slot 170 --> removed if access
to the variable is required.
<P>
The "HelloData" type and the "HelloGetData" macro used to initialize the
<B>somThis</B> pointer are defined in the implementation header file. Within
a method procedure, class implementers can use the<B> somThis</B> pointer
to access instance data, or they can use the convenience macros defined
for accessing each instance variable, as described below.
<P>
To implement a method so that it can modify a local copy of an object's
instance data without affecting the object's real instance data, declare
a variable of type &lt;<I>className</I>&gt;<B>Data</B> (for example, "HelloData")
and assign to it the structure that<B> somThis</B> points to; then make
the<B> somThis</B> pointer point to the copy. For example:
<PRE>   HelloData myCopy = *somThis;
   somThis = &amp;myCopy;
</PRE>

<P>
Next in the stub procedure for method "sayHello" is the statement:
<PRE>   HelloMethodDebug("Hello", "sayHello");
</PRE>

<P>
This statement facilitates debugging. The "HelloMethodDebug" macro is defined
in the implementation header file. It takes two arguments, a class name
and a method name. If debugging is turned on (that is, if global variable
<B>SOM_TraceLevel</B> is set to one in the calling program), the macro produces
a message each time the method procedure is entered. (See the next Chapter
3, "Using SOM Classes in Client Programs," for information on debugging
with SOM.)
<P>
Debugging can be permanently disabled (regardless of the setting of the
<B>SOM_TraceLevel</B> setting in the calling program) by redefining the
&lt;<I>className&gt;</I>MethodDebug macro to be<B> SOM_NoTrace(c,m)</B> following
the #include directive for the implementation header file. (This can yield
a slight performance improvement.) For example, to permanently disable debugging
for the "Hello" class, insert the following lines in the hello.c implementation
file following the line "#include hello.ih" (or "#include hello.xih," for
classes implemented in C++):
<PRE>   #undef HelloMethodDebug
   #define HelloMethodDebug(c,m) SOM_NoTrace(c,m)
</PRE>

<P>
The way in which the stub procedure ends is determined by whether the method
is a new or an overriding method.<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->For non-overriding (new) methods, the stub procedure
ends with a return statement (unless the return type of the method is<B> void</B>).
The class implementer should customize this return statement.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->For overriding methods, the stub procedure ends by
making a "parent method call" for each of the class's parent classes. If
the method has a return type that is not<B> void</B>, the last of these
parent method calls is returned as the result of the method procedure. The
class implementer can customize this return statement if needed (for example,
if some other value is to be returned, or if the parent method calls should
be made before the method procedure's own processing). See the next section
for a discussion of parent method calls.<!-- lm: 0x2 1 -->
</UL>
<P>
If a<B> classinit</B> modifier was specified to designate a user-defined
procedure that will initialize the "Hello" class object, as in the statement:

<PRE>   classinit = HInit;</PRE>

<P>
then the implementation template file would include the following stub procedure
for "HInit", in addition to the stub procedures for Hello's methods:
<PRE>   void  SOMLINK HInit(SOMClass *cls)
   {

   }
</PRE>

<P>
This stub procedure is then filled in by the class implementer. If the class
definition specifies a<B> functionprefix</B> modifier, the<B> classinit
</B>procedure name is generated by prepending the specified prefix to the
specified<B> classinit</B> name, as with other stub procedures.

<P><HR>

<A HREF="138_L3_Theimplementationtem.html">[Back: The implementation template]</A> <BR>
<A HREF="140_L3_Extendingtheimplemen.html">[Next: Extending the implementation template]</A> 
</BODY>
</HTML>
