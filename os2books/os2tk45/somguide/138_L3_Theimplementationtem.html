<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>The implementation template</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>The implementation template</H1><!-- entering slot 168 -->
<P>
Consider the following IDL description of the "Hello" class:
<PRE>   #include &lt;somobj.idl&gt;

   interface Hello : SOMObject
   {
       void sayHello();
       // This method outputs the string "Hello, World!".
   };
</PRE>

<P>
From this IDL description, the SOM Compiler generates the following C implementation
template, hello.c (a C++ implementation template, hello.C or hello.cpp,
is identical except that the<I> #include</I>d file is &lt;hello.xih&gt;
rather than &lt;hello.ih&gt;):
<PRE>   #define Hello_Class_Source
   #include &lt;hello.ih&gt;

   /*
    *  This method outputs the string "Hello, World!".
    */

   SOM_Scope void   SOMLINK sayHello(Hello somSelf, Environment *ev)
   {
       /* HelloData *somThis = HelloGetData(somSelf); */
       HelloMethodDebug("Hello","sayHello");
   }
</PRE>

<P>
The first line defines the "Hello_Class_Source" symbol, which is used in
the SOM-generated implementation header files for C to determine when to
define various functions, such as "HelloNewClass."  For interfaces defined
within a module, the directive "#define &lt;className&gt;_Class_Source"
is replaced by the directive "#define SOM_Module_&lt;moduleName&gt;_Source".

<P>
The second line (#include &lt;hello.ih&gt; for C, or #include &lt;hello.xih&gt;
for C++) includes the SOM-generated implementation header file. This file
defines a<B> struct</B> holding the class's instance variables, macros for
accessing instance variables, macros for invoking parent methods, and so
forth.

<P><HR>

<A HREF="137_L2_ImplementingSOMClass.html">[Back: Implementing SOM Classes]</A> <BR>
<A HREF="139_L4_Stubproceduresformet.html">[Next: Stub procedures for methods]</A> 
</BODY>
</HTML>
