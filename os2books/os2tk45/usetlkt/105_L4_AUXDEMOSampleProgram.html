<HTML GROUP=1>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<!-- extra bytes: 00 04 01 00 --><TITLE>AUXDEMO Sample Programs</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>AUXDEMO Sample Programs</H1><!-- entering slot 105 -->
<P>
The following Auxiliary Library samples are provided in the OS/2 Warp Toolkit:
<!-- lm: 0x2 3 -->
<UL>
<P>
<LI><!-- lm: 0x2 6 -->ACCANTI
<P>
This program shows accumulation of jittered objects with an orthographic
projection in order to antialias a scene.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ACCNOT
<P>
This program is basically the same as ACCANTI, but without the jittering
to show the same scene aliased.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ACCPERSP
<P>
This program shows the same scene as the prior ACCANTI and ACCNOT, but with
a perspective projection and accumulation of jittered images to antialias
the scene.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ACCUM
<P>
This program is another example of accumulating multiple images in order
to antialias a scene.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->AIM
<P>
This program calculates the fovy (field of view angle in the Y direction),
by using trigonometry, given the size of an object and its size.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ALPHA
<P>
This program draws several overlapping filled polygons to demonstrate the
effect order has on alpha blending results.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ALPHA3D
<P>
This program demonstrates how to intermix opaque and alpha blended polygons
in the same scene, by using glDepthMask(). By pressing the left mouse button,
you can toggle the eye position.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ANTI
<P>
This program draws antialiased lines in RGBA mode.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ANTIINDX
<P>
This program draws a wireframe icosahedron with antialiased lines, in color
index mode.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ANTIPIDX
<P>
This program draws antialiased points, in color index mode.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ANTIPOLY
<P>
This program draws filled polygons with antialiased edges.  The special
GL_SRC_ALPHA_SATURATE blending function is used. By pressing the left mouse
button, you can turn the antialiasing on and off.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ANTIPT
<P>
This program draws antialiased points, in RGBA mode.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->BEZCURVE
<P>
This program uses evaluators to draw a Bezier curve.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->BEZSURF
<P>
This program renders a lighted, filled Bezier surface, using two-dimensional
evaluators.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->BEZMESH
<P>
This program renders a wireframe Bezier surface, using two-dimensional evaluators.
<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CHECKER
<P>
This program texture maps a checkerboard image onto two rectangles.  This
program clamps the texture, if the texture coordinates fall outside 0.0
and 1.0.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CHECKER2
<P>
This program texture maps a checkerboard image onto two rectangles.  This
program repeats the texture, if the texture coordinates fall outside 0.0
and 1.0.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CHESS
<P>
This program texture maps a checkerboard image onto two rectangles.  The
texture coordinates for the rectangles are 0.0 to 3.0.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CLIP
<P>
This program demonstrates arbitrary clipping planes.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->COLORMAT
<P>
This program will be in ColorMaterial mode after initialization. By pressing
the mouse buttons, you can change the color of the diffuse reflection.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CONE
<P>
This program demonstrates the use of the GL lighting model. A sphere is
drawn using a grey material characteristic.  A single light source illuminates
the object.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CUBE
<P>
This program draws a 3-D cube, viewed with perspective, stretched along
the Y-axis.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->CURVE
<P>
This program uses the Utility Library NURBS routines to draw a one-dimensional
NURBS curve.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->DEPTHCUE
<P>
This program draws a wireframe model, which uses intensity (brightness)
to give clues to distance. Fog is used to achieve this effect.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->DISK
<P>
This program demonstrates the use of the quadrics Utility Library routines
to draw circles and arcs.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->DOF
<P>
This program demonstrates use of the accumulation buffer to create an out-of-focus
depth-of-field effect.  The teapots are drawn several times into the accumulation
buffer.  The viewing volume is jittered, except at the focal point, where
the viewing volume is at the same position, each time.  In this case, the
gold teapot remains in focus.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->DOFNOT
<P>
This program demonstrates the same scene as DOF.C, but without use of the
accumulation buffer, so that everything is in focus.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->DOUBLE
<P>
This program demonstrates double buffering for<!-- entering slot 106 --> flicker-free
animation. The left and middle mouse buttons start and stop the spinning
motion of the square.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->DRAWF
<P>
This program draws the bitmapped letter F on the screen several times. This
demonstrates use of the glBitmap() function.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->FEEDBACK
<P>
This program demonstrates use of OpenGL feedback.  First, a lighting environment
is set up and a few lines are drawn. Then feedback mode is entered and the
same lines are drawn.  The results in the feedback buffer are printed.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->FOG
<P>
This program draws five red teapots, each at a different Z-distance from
the eye, in different types of fog. By pressing the left mouse button, you
can choose between three types of fog:  exponential, exponential squared,
and linear. In this program, there is a fixed density value, as well as
fixed start and end values for the linear fog.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->FOGINDEX
<P>
This program demonstrates fog in color index mode. Three cones are drawn
at different Z-values in a linear fog.  Thirty-two contiguous colors (from
16 to 47) are loaded with a color ramp.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->FONT
<P>
This program draws some text in a bitmapped font using glBitmap() and other
pixel routines.  FONT also demonstrates use of display lists.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->LIGHT
<P>
This program demonstrates the use of the OpenGL lighting model.  A sphere
is drawn using a grey material characteristic. A single light source illuminates
the object.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->LINELIST
<P>
This program demonstrates the use of display lists to call different line
stipples.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->LINES
<P>
This program demonstrates different line stipples and widths.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->LIST
<P>
This program demonstrates how to make and execute a display list.  Note
that attributes, such as current color and matrix, are changed.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->LIST2
<P>
This program demonstrates the use of glGenList() and glPushAttrib(). The
matrix and color are restored before the line is drawn.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->MAPLIGHT
<P>
This program demonstrates the use of the GL lighting model. A sphere is
drawn using a magenta diffuse reflective and white specular material property.
A single light source illuminates the object.  This program illustrates
lighting in color-map mode.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->MATERIAL
<P>
This program demonstrates the use of the GL lighting model. Several objects
are drawn using different material characteristics. A single light source
illuminates the objects.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->MIPMAP
<P>
This program demonstrates using mipmaps for texture maps. To overtly show
the effect of mipmaps, each mipmap reduction level has a solid colored,
contrasting texture image. Thus, the quadrilateral is drawn with several
different colors.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->MODEL
<P>
This program demonstrates the use of OpenGL modeling transformations.  Four
triangles are drawn, each with a different transformation.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->MVLIGHT
<P>
This program demonstrates when to issue lighting and transformation commands
to render a model with a light, which is moved by a modeling transformation
(rotate or translate).  The light position is reset after the modeling transformation
is called.  The eye position does not change.
<P>
A sphere is drawn using a grey material characteristic. A single light source
illuminates the object.
<P>
By pressing the left or middle mouse button, you can alter the modeling
transformation (X-rotation) by 30 degrees. The scene is then redrawn with
the light in a new position.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->NURBS
<P>
This program shows a NURBS (Non-uniform rational B-splines) surface, shaped
like a heart.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->PICKDPTH
<P>
This program demonstrates picking.  In rendering mode, three overlapping
rectangles are drawn.  When you press the left mouse button, you enter selection
mode with the picking matrix. Rectangles that are drawn under the cursor
position are "<!-- entering slot 107 --> picked."  Note the depth value
range that is returned.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->PICKLINE
<P>
This program demonstrates picking.  Press the left mouse button to enter
picking mode.  You get two hits if you press the mouse, while the cursor
is where the lines intersect.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->PICKSQR
<P>
This program demonstrates using multiple names and picking. A 3x3 grid of
squares is drawn.  When you press the left mouse button, all squares under
the cursor position change color.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->PLANE
<P>
This program demonstrates the use of local versus infinite lighting on a
flat plane.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->PLANET
<P>
This program shows how to composite modeling transformations to draw translated
and rotated models.
<P>
By pressing the Left, Right, Up, or Down Arrow key, you can alter the rotation
of the planet around the sun.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->PLANETUP
<P>
In this program, the planets (from PLANET.C) have been rotated so their
polar regions are north/south.
<P>
By pressing the Left, Right, Up, or Down Arrow key, you can alter the rotation
of the planet around the sun.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->POLYS
<P>
This program demonstrates polygon stippling.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->ROBOT
<P>
This program shows how to composite modeling transformations to draw translated
and rotated hierarchical models.
<P>
By pressing any of the arrow keys, you can alter the rotation of the robot
arm.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SCENE
<P>
This program demonstrates the use of the GL lighting model. Objects are
drawn using a grey material characteristic. A single light source illuminates
the objects.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SCNBAMB
<P>
This program demonstrates use of a blue ambient light source.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SCNFLAT
<P>
This program draws lighted objects with flat shading.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SCNLIGHT
<P>
This program demonstrates the use of a colored (magenta, in this example)
light source.  Objects are drawn using a grey material characteristic. A
single light source illuminates the objects.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SELECT
<P>
This program is an illustration of the selection mode and name stack, which
detect whether objects collide with a viewing volume.  First, four triangles
and a rectangular box representing a viewing volume are drawn (drawScene
routine). The green triangle and yellow triangles appear to lie within the
viewing volume, but the red triangle appears to lie outside it.  Then, the
selection mode is entered (selectObjects routine). Drawing to the screen
ceases. To see if any collisions occur, the four triangles are called.  In
this example, the green triangle causes one hit with the name 1 and the
yellow triangles cause one hit with the name 3.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SIMPLE
<P>
This program draws a white rectangle on a black background.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SMOOTH
<P>
This program demonstrates smooth shading. A smooth shaded polygon is drawn
in a 2-D projection.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SPHERE
<P>
This program draws a wire frame sphere.  It uses glTranslatef() as a viewing
transformation.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->STENCIL
<P>
This program draws two rotated tori in a window. A diamond in the center
of the window masks out part of the scene.  Within this mask, a different
model (a sphere) is drawn in a different color.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->STROKE
<P>
This program demonstrates some characters of a stroke (vector) font.  The
characters are represented by display lists, which are given numbers which
correspond to the ASCII values of the characters. Use of glCallLists() is
demonstrated.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->SURFACE
<P>
This program draws a NURBS surface in the<!-- entering slot 108 --> shape
of a symmetrical hill.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->TEA
<P>
This program demonstrates two-sided lighting and compares it with one-sided
lighting.  Three teapots are drawn, with a clipping plane to expose the
interior of the objects.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->TEAAMB
<P>
This program renders three lighted, shaded teapots, with different ambient
values.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->TEAPOTS
<P>
This program demonstrates several material properties. A single light source
illuminates the objects.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->TEXGEN
<P>
This program draws a texture mapped teapot with automatically generated
texture coordinates.  The texture is rendered as stripes on the teapot.
<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->TEXSURF
<P>
This program uses evaluators to generate a curved surface and automatically
generated texture coordinates.<!-- lm: 0x2 3 -->
<P>
<LI><!-- lm: 0x2 6 -->TRIM
<P>
This program draws a NURBS surface in the shape of a symmetrical hill, using
both a NURBS curve and pwl (piecewise linear) curve to trim part of the
surface.<!-- lm: 0x2 1 -->
</UL>

<P><HR>

<A HREF="104_L3_OpenGLSamplePrograms.html">[Back: OpenGL Sample Programs]</A> <BR>
<A HREF="106_L4_GLUTDEMOSampleProgra.html">[Next: GLUTDEMO Sample Programs]</A> 
</BODY>
</HTML>
