<HTML>
<HEAD>
<TITLE>Interrupts</TITLE>
</HEAD>
<BODY>
<H1>Interrupts</H1><!-- entering slot 224 -->
<P>
When the processor is running in protected mode, interrupts are not vectored
from the base of memory.  Instead, each interrupt has a code which is used
as an index into an <A HREF="308_L2_interruptdescriptort.html"><B>Interrupt
Descriptor Table</B> (IDT)</A>, the base address of which is contained in
the Interrupt Descriptor Table Register.  There may be up to 256 interrupt
and exception codes, generated by devices or by software.
<P>
At system initialization, the IDT is loaded into memory by the operating
system, and its location is stored in the IDT register.  Each descriptor
in the IDT specifies the address of the interrupt handler routine, which
will service interrupts with that code.
<P>
There are three types of gate descriptors in the IDT:<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Interrupt gate descriptors<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Trap gate descriptors<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 -->Task gate descriptors.<!-- lm: 0x2 0 -->
<BR>

<P>
For interrupt and trap gates, the descriptor in the IDT contains the selector
of the gate, and therefore points indirectly to a procedure that will execute
within the current task, since the selector within the gate procedure points
directly to an executable segment descriptor in the GDT or the current LDT.
 This takes place exactly as if the 80386 were calling a procedure within
the current application.
<P>
For the task gate, however, the selector within the gate points to a TSS
descriptor in the GDT.  Invoking the task gate, therefore, causes a task
switch to occur.  There are certain advantages to the use of a task gate,
since it allows a program to pass control to a higher privilege level, and
the application may therefore invoke operating system routines to process
interrupts and exceptions.  In addition, the new task may be given its own
LDT to prevent it from accessing memory used by the current task, and the
TSS of the current task is automatically saved.
<P>
However, there are also performance implications in using task switching.
 Interrupt handling through task switching requires approximately 15 microseconds
on a 20 MHz 80386, while switching to a procedure within the current task
takes about 3.6 microseconds.  But, the advantages of having the operating
system manage exceptions (smaller application code,  greater portability,
standard exception handling) usually outweigh the slight performance penalty.


<P><HR>

<A HREF="200_L3_ReservedInstructions.html">[Back: Reserved Instructions]</A> <BR>
<A HREF="202_L2_InputOutputProcessin.html">[Next: Input/Output Processing]</A> 
</BODY>
</HTML>
