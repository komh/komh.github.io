<HTML>
<HEAD>
<TITLE>Simple Adapters</TITLE>
</HEAD>
<BODY>
<H1>Simple Adapters</H1><!-- entering slot 236 -->
<P>
Simple adapters are totally dependent on support from the main processor
or another master. This approach to adapter design was common in single
task systems, when the processor was dedicated to one adapter function at
a time. In such cases, the most economic approach is to use the minimum
of logic on the adapter card, and depend on software support. Adapters,
which use these techniques, are:<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 --><B>Polled adapters</B>
<P>
With polled adapters, the processor must periodically request information,
or poll, the adapter registers for status of the attached device.  This
can consume much of the processor's power.<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 --><B>Interrupt per character adapters</B>
<P>
With these adapters, the processor is free to perform other duties until
an interrupt is received from the adapter.  The overhead of servicing the
interrupt is several hundred instructions to save and restore the environment.

<P>
Devices with high data transfer rates (for example, fast communication adapters)
cause high interrupt rates and the overhead could then use up much of the
available processor power. This is even more of an issue in a multitasking
environment where the situation is more complex and the overhead for interrupt
processing is typically higher.<!-- lm: 0x2 0 -->
<P>
<LI><!-- lm: 0x2 2 --><B>Memory mapped adapters</B>
<P>
This type of adapter shares a segment of memory (on the adapter) and if
combined with the use of interrupts, can be much more efficient than the
interrupt per character type.  However, the adapter is still dependent on
the processor to move data between the adapter's storage and a dynamically
allocated buffer in system memory.  With the arbitration overhead and large
amounts of data (for example, bitmaps for a graphics adapter), this may
be a burden on the processor.
<P>
The biggest disadvantage with this type of adapter is that there is a limited
number of fixed assignments for shared I/O memory.  This limits the number
of possible configurations and designs.<!-- lm: 0x2 0 -->
<BR>


<P><HR>

<A HREF="211_L3_DMAAdapters.html">[Back: DMA Adapters]</A> <BR>
<A HREF="213_L2_DataTransferModes.html">[Next: Data Transfer Modes]</A> 
</BODY>
</HTML>
