<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>IsValidCodePage</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>IsValidCodePage</H1><!-- entering slot 180 -->
<P>
IsValidCodePage<!-- lm: 0x2 6 -->
<UL>
<P>
<B>Functional Difference from WIN95</B>
<P>
N/A<!-- lm: 0x2 6 -->
<P>
<B>Functional Difference from SBCS Open32</B>
<P>
New<!-- lm: 0x2 6 -->
<P>
<B>Implementation</B>
<P>
This API determines whether a specified code page is valid or not. A code
page is considered valid if it is installed in the system like as WIN95.
 As for the code-page identifier, see '<A HREF="146_L4_ComparisonTableofSup.html">Comparison
table of code pages</A>'. The list of the valid codepages are initialized
by Open32 constructor<I> useNLS when</I> the process begins.  Open32 gets
the codepages by WinQueryCpList.  Among them, Open32 determines them as
valid, when  they are listed in the Open32  hard-coded list of ANSI codepages
and OEM codepages.  In fact, Open32 should, furthermore, confirm that ULS
codepage object for these codepages are available.  ULS codepage object
is the file; IBMxxx (xxx is the codepage ID) at the "ULSPATH"/codepage.
 "ULSPATH" is the environment variable. But this confirmation is not always
true because there's a case whose ULS codepage object is an alias to another
ULS codepage object.  In  this case, what we can do is only to try to create
the UCONV object, but it takes time to load a large codepage object.  That's
why this confirmation is skipped.<!-- lm: 0x2 1 -->
</UL>

<P><HR>

<A HREF="170_L3_GetUserDefaultLangID.html">[Back: GetUserDefaultLangID]</A> <BR>
<A HREF="172_L3_IsValidLocale.html">[Next: IsValidLocale]</A> 
</BODY>
</HTML>
