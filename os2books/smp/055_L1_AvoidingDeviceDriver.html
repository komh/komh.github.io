<HTML>
<HEAD>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=UTF-8">
<TITLE>Avoiding Device Driver Deadlocks</TITLE>
<STYLE>
PRE {
  FONT-FAMILY: Consolas, "Lucida Console", "Courier New", Courier, MONOSPACE;
}
</STYLE>
</HEAD>
<BODY>
<H1>Avoiding Device Driver Deadlocks</H1><!-- entering slot 56 -->
<P>
Deadlock can be defined as an unresolved contention for use of a resource.
Whenever any mutual exclusion primitive is used, the possibility of deadlock
is introduced. This is evident even in uniprocessor system such as OS/2
with the use of semaphores. The possibilities of deadlock are greater in
a multiprocessor environment because of the large requirement for mutual
exclusion. The method of mutual exclusion for device drivers and the OS/2
SMP kernel is the spinlock. Using spinlocks incorrectly can result in deadlock
conditions where an application or device driver will become hung. In the
case of a device driver, no more activity will take place on that processor
if the device driver enters a deadlock state. Writing device drivers and
code for OS/2 for SMP V2.11 requires the programmer to think about the conditions
in the code which might cause a deadlock condition, and then use spinlocks
to protect those resources.
<P>
While it would be impossible to list every cause of deadlock, a few of the
most common code examples are given below in pseudo-code that can result
in deadlock. These examples are not exhaustive, but represent the majority
of situations that will probably be encountered. Being aware of these types
of conditions can help you reduce the chances of deadlock within your device
driver or applications.

<P><HR>

<A HREF="054_L3_DosQuerySysInfo.html">[Back: DosQuerySysInfo]</A> <BR>
<A HREF="056_L2_UseofCLISTI.html">[Next: Use of CLI/STI]</A> 
</BODY>
</HTML>
